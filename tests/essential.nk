describe 'count' [
  it should 'leave 0 for empty block' [
    [ ] count 0 assert=
  ]

  it should 'leave 0 for empty quote' [
    '' count 0 assert=
  ]

  it should 'count the amount of elements in blocks' [
    [ 1 2 3 4 ] count 4 assert=
  ]

  it should 'count the amount of characters (graphemes) in quotes' [
    'Ⓐs°Ämanчеловек' count 14 assert=
  ]
]

describe 'asWord' [
  it should 'noop if already word' [
    #hello asWord #hello assert=
  ]

  it should 'convert quote to word' [
    'hello' asWord #hello assert=
  ]

  it should 'peel off all quoting' [
    ########hello asWord #hello assert=
  ]

  it dies 'when quote is empty' [
    '' asWord
  ]

  it dies 'when quote is whitespace' [
    ' ' asWord
  ]

  it dies 'when quote is newline + whitespace' [
    '


    ' asWord
  ]

  it dies 'when quote contains whitespace' [
    'hello world' asWord
  ]
]

describe 'uppercase?' [
  it should 'leave false for empty quote' [
    '' uppercase? false assert=
  ]

  it should 'leave false for whitespace quote' [
    [ ] [
      ' ' uppercase? false assert=
      '     ' uppercase? false assert=
      '
      ' uppercase? false assert=
    ] there [ ] all?
  ]

  it should 'work for single-letter quotes' [
    [ ] [
      'H' uppercase?  true assert=
      'Á' uppercase?  true assert=
      'c' uppercase? false assert=
      '.' uppercase? false assert=
    ] there [ ] all?
  ]

  it should 'work for multi-letter quotes' [
    [ ] [
      'HELLO' uppercase?  true assert=
        'HÁË' uppercase?  true assert=
      'HeLLO' uppercase? false assert=
      'HÁËå'  uppercase? false assert=
    ] there [ ] all?
  ]
]

describe 'toUppercase' [
  it dies 'when not given a quote #1' [
    0 toUppercase
  ]

  it dies 'when not given a quote #2' [
    #foo toUppercase
  ]

  it should 'leave empty quote unchanged' [
    '' toUppercase '' assert=
  ]

  it should 'leave whitespace/single-uppercase-character quote unchanged' [
    [ ] [
      ' ' toUppercase ' ' assert=
      'C' toUppercase 'C' assert=
      'Ä' toUppercase 'Ä' assert=
      '.' toUppercase '.' assert=
      '0' toUppercase '0' assert=
      '°' toUppercase '°' assert=
      '€' toUppercase '€' assert=
    ] there [ ] all?
  ]


  it should 'uppercase single lowercase character' [
    [ ] [
      'c' toUppercase 'C' assert=
      'ä' toUppercase 'Ä' assert=
      'ā' toUppercase 'Ā' assert=
    ] there [ ] all?
  ]

  it should 'uppercase multi-character quotes' [
    [ ] [
      'HI' toUppercase 'HI' assert=
      'Hi' toUppercase 'HI' assert=
      'hI' toUppercase 'HI' assert=
      'Ḧï' toUppercase 'ḦÏ' assert=
      'Ãuxi£åÅ' toUppercase 'ÃUXI£ÅÅ' assert=
    ] there [ ] all?
  ]
]

describe 'sliceQuoteAt' [
  it dies 'when given non-quote #1' [
    0 1 sliceQuoteAt
  ]

  it dies 'when given non-quote #2' [
    #foobar 1 sliceQuoteAt
  ]

  it dies 'when given non-quote #3' [
    ##foobar 1 sliceQuoteAt
  ]

  it dies 'when given non-quote #4' [
    [ 1 2 3 ] 1 sliceQuoteAt
  ]

  it dies 'when given empty quote' [
    '' 0 sliceQuoteAt
  ]

  it dies 'when slicepoint is negative' [
    'foobar' -1 sliceQuoteAt
  ]

  it dies 'when slicepoint > quote count' [
    'foobar' 7 sliceQuoteAt
  ]

  it should 'handle slicepoint 0 = case' [
    [ ] [ 'foobar' 0 sliceQuoteAt ] there [ '' 'foobar' ] assert=
  ]

  it should 'handle slicepoint quote count = case' [
    [ ] [ 'foobar' 6 sliceQuoteAt ] there [ 'foobar' '' ] assert=
  ]

  it should 'properly slice in bounds' [
    [ ] [ 'foo|bar' 3 sliceQuoteAt ] there [ 'foo' '|bar' ] assert=
  ]
]

describe '|slice' [
  it dies 'when given non-block #1' [
    #foobar |slice
  ]

  it dies 'when given non-block #2' [
    true |slice
  ]

  it dies 'when given non-block #4' [
    'foobar' |slice
  ]

  it dies 'when given non-block #5' [
    100 |slice
  ]

  it should 'slice when |at 0' [
    [ ] [ [ ] |slice ] there [ [ ] [ ] ] assert=
    [ ] [ [ 1 2 3 ] dup 0 |to |slice ] there [ [ ] [ 1 2 3 ] ] assert=
  ]

  it should 'slice when |at count' [
    [ ] [ [ 1 2 3 ] |slice ] there [ [ 1 2 3 ] [ ] ] assert=
  ]

  it should 'slice when |at in first half' [
    [ ] [ [ 1 2 3 4 ] dup 1 |to |slice ] there [ [ 1 ] [ 2 3 4 ] ]
  ]

  it should 'slice when |at in second half' [
    [ ] [ [ 1 2 3 4 ] dup 3 |to |slice ] there [ [ 1 2 3 ] [ 4 ] ]
  ]
]
