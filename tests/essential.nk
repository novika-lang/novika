describe 'anyof?' [
  in lang

  it should 'leave false for empty block' [
    [ ] [ ] anyof? false assert=
    123 [ ] anyof? false assert=
    false [ ] anyof? false assert=
    "..etc"
  ]

  it should 'check for booleans' [
    true [ true false false ] anyof? false assert= "because true/false is a word"
    #true [ true false false ] anyof? true assert= "as you can see here"

    true [ true false false ] vals anyof? true assert=
    false [ true true ] vals anyof? false assert=
  ]

  it should 'check for decimals' [
    1 [ 1 2 3 ] anyof? true assert=
  ]

  it should 'check for words and qwords' [
    #hello [ 1 hello 2 3 ] anyof? true assert=
    #hello [ 1 2 3 ] anyof? false assert=
    ##hello [ 1 #hello 2 3 ] anyof? true assert=
    ##hello [ 1 hello 2 3 ] anyof? false assert=
    ###hello [ 1 ##hello 2 3 ] anyof? true assert=
    ##hello [ 1 2 3 #hElLo ] anyof? false assert=
    ##hello [ 1 2 3 ] anyof? false assert=
  ]

  it should 'check for quotes' [
    '' [ 'hello' false 0 -100 true ] anyof? false assert=
    '' [ 'hello' '' false 0 -100 true ] anyof? true assert=
    'hello world' [ 'hello' 'world' ] anyof? false assert=
    'hello world' [ 'hello world' 1 2 'hello world' ] anyof? true assert=
  ]

  it should 'check for colors' [
    [ 0 0 0 rgb
      100 201 201 rgb
    ] vals $: colors

    0 0 0 rgb colors anyof? true assert=
    0 1 0 rgb colors anyof? false assert=

    100 201 201 rgb getHSL hsl colors anyof? true assert=
  ]

  it should 'check for builtins' [
    [ #+ here #- here #* here #/ here ] vals $: bins

    #+ here bins anyof? true assert=
    #/ here bins anyof? true assert=
    #** here bins anyof? false assert=
  ]

  it should 'check for blocks' [
    [ [ 1 2 3 ] [ 4 5 6 ] ] $: b

    [ 1 2 3 ] b anyof? true assert=
    [ 4 5 6 ] b anyof? true assert=
    [ 1 3 2 ] b anyof? false assert=
    [ 4 5 '6' ] b anyof? false assert=
    b new first b anyof? true assert=
    b first shallowCopy b anyof? true assert=
  ]
]


describe 'toOrphan' [
  in lang

  it should 'convert block into orphan' [
    0 $: x
    [ ] $: b
    b . x 0 assert=
    b toOrphan
    [ b . x ] 'undefined dictionary property: x' assertDies
  ]
]


describe 'shallowCopy' [
  in lang

  it should 'create a shallow copy' [
    [ 1 2 3 ] $: a
    a #x 0 pushes
    a shallowCopy $: b
    b #y 1 pushes
    b 1 shove

    a toTape [ 1 2 3 ] assert=
    a ls [ x ] assert=

    b toTape [ 1 2 3 1 ] assert=
    b ls [ x y ] assert=
  ]
]


describe 'resub' [
  in lang

  it should 'replace substrate of block with other block\'s' [
    [ 1 2 3 ] $: a
    [ 'a' 'b' 'c' ] $: b
    b #x 0 pushes

    b toTape [ 'a' 'b' 'c' ] assert=
    b |at 3 assert=
    b ls [ x ] assert=

    b 2 |-
    a b resub
    b toTape [ 1 2 3 ] dup 1 |to assert=
    b ls [ x ] assert=
  ]
]


describe 'round' [
  in lang

  it should 'round good cases' [
    1 round 1 assert=
    1.23 round 1 assert=
    1.67 round 2 assert=
  ]

  it should 'do banker\'s rounding' [
    1.5 round 2 assert=
    2.5 round 2 assert=
    5.5 round 6 assert=
    6.5 round 6 assert=
  ]
]


describe 'trunc' [
  it should 'truncate decimals' [
    1 trunc 1 assert=
    1.23 trunc 1 assert=
    1.67 trunc 1 assert=
    2.5 trunc 2 assert=
  ]
]


describe 'sin' [
  in lang

  "Copied from https://github.com/Raku/roast/blob/ed50f3c48d84972a0603a87ab4b698c642db6cb4/S32-trig/sin.t#L12"

  it should 'compute sine in radians' [
    -360 deg->rad sin 0 assertApprox=
    135 360 - deg->rad sin 1 2 / 2 sqrt * assertApprox=
    330 360 - deg->rad sin -0.5 assertApprox=
    0 deg->rad sin 0 assertApprox=
    30 deg->rad sin 0.5 assertApprox=
    45 deg->rad sin 1 2 / 2 sqrt * assertApprox=
    90 deg->rad sin 1 assertApprox=
    135 deg->rad sin  1 2 / 2 sqrt * assertApprox=
    180 deg->rad sin 0 assertApprox=
    225 deg->rad sin 1 2 / 2 sqrt * flipSign assertApprox=
    270 deg->rad sin -1 assertApprox=
    315 deg->rad sin 1 2 / 2 sqrt * flipSign assertApprox=
    360 deg->rad sin 0 assertApprox=
    30 360 + deg->rad sin 0.5 assertApprox=
    225 360 + deg->rad sin 1 2 / 2 sqrt * flipSign assertApprox=
    720 deg->rad sin 0 assertApprox=
  ]
]


describe 'cos' [
  in lang

  "Copied from: https://github.com/Raku/roast/blob/ed50f3c48d84972a0603a87ab4b698c642db6cb4/S32-trig/cos.t#L31"

  it should 'compute cosine in radians' [
    -360 deg->rad 90 deg->rad - cos 0 assertApprox=
    135 360 - deg->rad 90 deg->rad - cos  1 2 / 2 sqrt * assertApprox=
    330 360 - deg->rad 90 deg->rad - cos -0.5 assertApprox=
    0 deg->rad 90 deg->rad - cos 0 assertApprox=
    30 deg->rad 90 deg->rad - cos 0.5 assertApprox=
    45 deg->rad 90 deg->rad - cos  1 2 / 2 sqrt * assertApprox=
    90 deg->rad 90 deg->rad - cos 1 assertApprox=
    135 deg->rad 90 deg->rad - cos  1 2 / 2 sqrt * assertApprox=
    180 deg->rad 90 deg->rad - cos 0 assertApprox=
    225 deg->rad 90 deg->rad - cos 1 2 / 2 sqrt * flipSign assertApprox=
    270 deg->rad 90 deg->rad - cos -1 assertApprox=
    315 deg->rad 90 deg->rad - cos 1 2 / 2 sqrt * flipSign assertApprox=
    360 deg->rad 90 deg->rad - cos 0 assertApprox=
    30 360 + deg->rad 90 deg->rad - cos 0.5 assertApprox=
    225 360 + deg->rad 90 deg->rad - cos 1 2 / 2 sqrt * flipSign assertApprox=
    720 deg->rad 90 deg->rad - cos 0 assertApprox=
  ]
]


describe 'desc' [
  in lang

  it should 'leave correct descriptions for value forms' [
    true desc 'boolean true' assert=
    false desc 'boolean false' assert=
    100 desc 'decimal number 100' assert=
    100.5 desc 'decimal number 100.5' assert=
    'hello world' desc 'quote \'hello world\'' assert=
    #foo desc 'word named \'foo\'' assert=
    ##foo desc 'quoted word \'foo\'' assert=
    ###foo desc 'quoted word \'#foo\'' assert=
  ]

  it should 'leave correct descriptions for blocks' [
    [ ] desc 'a block' assert=
    [ "hello world" ] desc 'hello world' assert=
    [ "" "" "" "hello world" ] desc 'hello world' assert=
    [ "" "" 1 "hello world" 3 ] desc 'a block' assert=
    [ "foo" [ "boo" ] "baa" ] desc 'foo' assert=
  ]

  it should 'leave correct descriptions for builtin' [
    #+ here desc '( A B -- S ): leaves the Sum of two decimals.' assert=
  ]
]

describe 'typedesc' [
  in lang

  it should 'leave correct descriptions for value forms' [
    true typedesc 'boolean' assert=
    false typedesc 'boolean' assert=
    #+ here typedesc 'builtin' assert=
    123 typedesc 'decimal' assert=
    123.456 typedesc 'decimal' assert=
    'hello world' typedesc 'quote' assert=
    #foo typedesc 'word' assert=
    ##foo typedesc 'quoted word' assert=
  ]

  it should 'leave correct descriptions for blocks' [
    [ ] typedesc 'block' assert=
    [ 1 2 3 ] typedesc 'block' assert=
    [ "foobar" ] typedesc 'block' assert=
  ]
]

describe 'block?' [
  in lang

  it should 'leave true for block' [ [] block? true assert= ]
  it should 'leave false for others' [
    'foo' block? false assert=
    123 block? false assert=
    "..."
  ]
]

describe 'word?' [
  in lang

  it should 'leave true for word' [ #foo word? true assert= ]
  it should 'leave true for block implementing *asWord' [
    [ #foo  $: *asWord this ] @: x
    [ [ x ] @: *asWord this ] @: y
    x word? true assert=
    y word? true assert=
  ]

  it should 'leave false for others' [
    'foo' word? false assert=
    123 word? false assert=
    [ ] word? false assert=
    "..."
  ]
]


describe 'private?' [
  in lang

  it should 'leave whether a word is private' [
    #_ private? false assert=
    #hello private? false assert=
    #_hello private? true assert=
  ]
]


describe 'quotedWord?' [
  in lang

  it should 'leave true for quoted word' [ ##foo quotedWord? true assert= ]
  it should 'leave true for block implementing *asQuotedWord' [
    [ ##foo $: *asQuotedWord this ] @: x
    [ [ x ] @: *asQuotedWord this ] @: y
    x quotedWord? true assert=
    y quotedWord? true assert=
  ]

  it should 'leave false for others' [
    'foo' quotedWord? false assert=
    123 quotedWord? false assert=
    [ ] quotedWord? false assert=
    #foo quotedWord? false assert=
    "..."
  ]
]

describe 'decimal?' [
  in lang

  it should 'leave true for decimal' [ 100 decimal? true assert= ]
  it should 'leave true for block implementing *asDecimal' [
    [ 100   $: *asDecimal this ] @: x
    [ [ x ] @: *asDecimal this ] @: y
    x decimal? true assert=
    y decimal? true assert=
  ]

  it should 'leave false for other types' [
    [ ] decimal? false assert=
    true decimal? false assert=
    #foobar decimal? false assert=
    '1234' decimal? false assert=
    "..."
  ]
]

describe 'quote?' [
  in lang

  it should 'leave true for quote' [ 'foo' quote? true assert= ]
  it should 'leave true for block implementing *asQuote' [
    [ 'foo' $: *asQuote this ] @: x
    [ [ x ] @: *asQuote this ] @: y
    x quote? true assert=
    y quote? true assert=
  ]

  it should 'leave false for other types' [
    [ ] quote? false assert=
    true quote? false assert=
    #foobar quote? false assert=
    1234 quote? false assert=
    " ... etc ... "
  ]
]

describe 'boolean?' [
  in lang

  it should 'leave true for boolean' [ true boolean? true assert= ]
  it should 'leave true for block implementing *asBoolean' [
    [ true  $: *asBoolean this ] @: x
    [ [ x ] @: *asBoolean this ] @: y
    x boolean? true assert=
    y boolean? true assert=
  ]

  it should 'leave false for other types' [
    [ ] boolean? false assert=
    #true boolean? false assert=
    #foobar boolean? false assert=
    '1234' boolean? false assert=
    " ... etc ... "
  ]
]

describe 'color?' [
  in lang

  it should 'leave true for color' [ 0 0 0 rgb color? true assert= ]
  it should 'leave true for block implementing *asColor' [
    [ 0 0 0 rgb $: *asColor this ] @: x
    [ [ x ] @: *asColor this ] @: y
    x color? true assert=
    y color? true assert=
  ]

  it should 'leave false for other types' [
    [ ] color? false assert=
    #true color? false assert=
    #foobar color? false assert=
    '1234' color? false assert=
    " ... etc ... "
  ]
]


describe 'byteslice?' [
  in lang

  it should 'leave true for byteslice' [ 'hello world' toByteslice byteslice? true assert= ]
  it should 'leave true for block implementing *asByteslice' [
    [ 'hello' toByteslice $: *asByteslice this ] @: x
    [ [ x ] @: *asByteslice this ] @: y
    x byteslice? true assert=
    y byteslice? true assert=
  ]

  it should 'leave false for other types' [
    [ ] byteslice? false assert=
    #true byteslice? false assert=
    #foobar byteslice? false assert=
    '1234' byteslice? false assert=
    " ... etc ... "
  ]
]


describe 'asDecimal' [
  in lang

  it dies 'when given quote' [ 'foo' asDecimal ]
  it dies 'when given word' [ #foo asDecimal ]
  it dies 'when given quoted word' [ ##foo asDecimal ]
  it dies 'when given boolean' [ true asDecimal ]
  it dies 'when given block' [ [] asDecimal ]
  it should 'leave decimal when given decimal' [
    100 dup asDecimal assert=
  ]

  [ $: x x $: *asDecimal this ] @: a

  it dies 'when given quote in *asDecimal' [ 'foo' a asDecimal ]
  it dies 'when given word in *asDecimal' [ #foo a asDecimal ]
  it dies 'when given quoted word in *asDecimal' [ ##foo a asDecimal ]
  it dies 'when given boolean in *asDecimal' [ true a asDecimal ]
  it dies 'when given block in *asDecimal' [ [] a asDecimal ]
  it should 'leave instance when given decimal in *asDecimal' [
    100 a dup asDecimal same? true assert=
  ]
]

describe 'asQuote' [
  in lang

  it dies 'when given decimal' [ 100 asQuote ]
  it dies 'when given word' [ #foo asQuote ]
  it dies 'when given quoted word' [ ##foo asQuote ]
  it dies 'when given boolean' [ true asQuote ]
  it dies 'when given block' [ [] asQuote ]
  it should 'leave quote when given quote' [
    'foo' dup asQuote assert=
  ]

  [ $: x x $: *asQuote this ] @: a

  it dies 'when given decimal in *asQuote' [ 100 a asQuote ]
  it dies 'when given word in *asQuote' [ #foo a asQuote ]
  it dies 'when given quoted word in *asQuote' [ ##foo a asQuote ]
  it dies 'when given boolean in *asQuote' [ true a asQuote ]
  it dies 'when given block in *asQuote' [ [] a asQuote ]
  it should 'leave instance when given quote in *asQuote' [
    'foo' a dup asQuote same? true assert=
  ]
]

describe 'asWord' [
  in lang

  it dies 'when given decimal' [ 100 asWord ]
  it dies 'when given quote' [ 'foo' asWord ]
  it dies 'when given quoted word' [ ##foo asWord ]
  it dies 'when given boolean' [ true asWord ]
  it dies 'when given block' [ [] asWord ]
  it should 'leave word when given word' [
    #foo dup asWord assert=
  ]

  [ $: x x $: *asWord this ] @: a

  it dies 'when given decimal in *asWord' [ 100 a asWord ]
  it dies 'when given quote in *asWord' [ 'foo' a asWord ]
  it dies 'when given quoted word in *asWord' [ ##foo a asWord ]
  it dies 'when given boolean in *asWord' [ true a asWord ]
  it dies 'when given block in *asWord' [ [] a asWord ]
  it should 'leave instance when given word in *asWord' [
    #foo a dup asWord same? true assert=
  ]
]

describe 'asQuotedWord' [
  in lang

  it dies 'when given decimal' [ 100 asQuotedWord ]
  it dies 'when given quote' [ 'foo' asQuotedWord ]
  it dies 'when given word' [ #foo asQuotedWord ]
  it dies 'when given boolean' [ true asQuotedWord ]
  it dies 'when given block' [ [] asQuotedWord ]
  it should 'leave quoted word when given quoted word' [
    ##foo dup asQuotedWord assert=
  ]

  [ $: x x $: *asQuotedWord this ] @: a

  it dies 'when given decimal in *asQuotedWord' [ 100 a asQuotedWord ]
  it dies 'when given quote in *asQuotedWord' [ 'foo' a asQuotedWord ]
  it dies 'when given word in *asQuotedWord' [ #foo a asQuotedWord ]
  it dies 'when given boolean in *asQuotedWord' [ true a asQuotedWord ]
  it dies 'when given block in *asQuotedWord' [ [] a asQuotedWord ]
  it should 'leave instance when given quoted word in *asQuotedWord' [
    ##foo a dup asQuotedWord same? true assert=
  ]
]

describe 'asBoolean' [
  in lang

  it dies 'when given decimal' [ 100 asBoolean ]
  it dies 'when given quote' [ 'foo' asBoolean ]
  it dies 'when given word' [ #foo asBoolean ]
  it dies 'when given quoted word' [ ##foo asBoolean ]
  it dies 'when given block' [ [] asBoolean ]
  it should 'leave boolean when given boolean' [
    true dup asBoolean assert=
  ]

  [ $: x x $: *asBoolean this ] @: a

  it dies 'when given decimal in *asBoolean' [ 100 a asBoolean ]
  it dies 'when given quote in *asBoolean' [ 'foo' a asBoolean ]
  it dies 'when given word in *asBoolean' [ #foo a asBoolean ]
  it dies 'when given quoted word in *asBoolean' [ ##foo a asBoolean ]
  it dies 'when given block in *asBoolean' [ [] a asBoolean ]
  it should 'leave instance when given boolean in *asBoolean' [
    true a dup asBoolean same? true assert=
  ]
]


describe 'asByteslice' [
  in lang

  it should 'accept byteslice only' [
    [ 100 asByteslice ] 'bad type: decimal, expected: a byteslice' assertDies
    [ 'foo' asByteslice ] 'bad type: quote, expected: a byteslice' assertDies
    [ #foo asByteslice ] 'bad type: word, expected: a byteslice' assertDies
    [ ##foo asByteslice ] 'bad type: quoted word, expected: a byteslice' assertDies
    [ [] asByteslice ] 'bad type: block, expected: a byteslice' assertDies
    [ true asByteslice] 'bad type: boolean, expected: a byteslice' assertDies
    'hello world' toByteslice dup asByteslice assert=
  ]


  it should 'it should accept block with *asByteslice' [
    [ $: x x $: *asByteslice this ] @: a

    [ 100 a asByteslice ] 'bad type: decimal, expected: a byteslice' assertDies
    [ 'foo' a asByteslice ] 'bad type: quote, expected: a byteslice' assertDies
    [ #foo a asByteslice ] 'bad type: word, expected: a byteslice' assertDies
    [ ##foo a asByteslice ] 'bad type: quoted word, expected: a byteslice' assertDies
    [ [] a asByteslice ] 'bad type: block, expected: a byteslice' assertDies
    [ true a asByteslice ] 'bad type: boolean, expected: a byteslice' assertDies
    'hello world' toByteslice a dup asByteslice same? true assert=
  ]
]


describe 'asBlock' [
  in lang

  it dies 'when given decimal' [ 100 asBlock ]
  it dies 'when given quote' [ 'foo' asBlock ]
  it dies 'when given word' [ #foo asBlock ]
  it dies 'when given quoted word' [ ##foo asBlock ]
  it dies 'when given boolean' [ true asBlock ]
  it should 'leave same block when given block' [
    [] dup asBlock same? true assert=
  ]
]

describe 'toQuote' [
  in lang

  it should 'enquote boolean true' [ true toQuote 'true' assert= ]
  it should 'enquote boolean false' [ false toQuote 'false' assert= ]
  it should 'enquote builtin' [ #+ here toQuote '[native code for: \'+\']' assert= ]
  it should 'enquote decimal' [ 100 toQuote '100' assert= ]
  it should 'enquote -decimal' [ -100 toQuote '-100' assert= ]
  it should 'enquote +decimal' [ +100 toQuote '100' assert= ]
  it should 'enquote quote' [ 'hello world' toQuote 'hello world' assert= ]
  it should 'enquote word' [ #hello toQuote 'hello' assert= ]
  it should 'enquote quoted word' [ ##hello toQuote '#hello' assert= ]
]

describe 'toQuote block' [
  in lang

  it should 'enquote empty block' [
    orphan toQuote '[ ]' assert=
    [ ] toQuote '[ ]' assert=
  ]

  it should 'enquote small block' [
    [ 1 2 3 ] toQuote '[ 1 2 3 ]' assert=
    [ 1 2 3 ] dup 0 |to toQuote '[ | 1 2 3 ]' assert=
    [ 1 2 3 ] dup 1 |to toQuote '[ 1 | 2 3 ]' assert=
    [ 'hello world' 1 2 3 ] toQuote '[ \'hello world\' 1 2 3 ]' assert=
  ]

  it should 'enquote nested blocks' [
    [ [ 1 2 3 ] [ x y z ] ] toQuote '[ [ 1 2 3 ] [ x y z ] ]' assert=
    [ [ 1 2 3 ] [ x [] z ] ] toQuote '[ [ 1 2 3 ] [ x [ ] z ] ]' assert=
  ]

  it should 'enquote dict blocks' [
    orphan $: dict
    dict #x 100 pushes
    dict #y 200 pushes
    dict #z [ 1 2 3 ] pushes
    dict #inc [ "( N -- N' ): does fancy stuff. Does ( a lot - of - Fancy stuff): see?" 1 + ] opens
    dict #foo #+ here pushes
    dict toQuote '[ · ${x :: 100} ${y :: 200} ${z :: a block} @{inc :: ( N -- N\' )} ${foo :: ( A B -- S )} ]' assert=
  ]

  it should 'enquote list+dict blocks' [
    [ 100 $: x 200 $: y ] obj $: foo
    foo toQuote '[ 100 $: x 200 $: y · x -> 100, y -> 200 ]'
  ]

  it should 'enquote reflections' [
    [ ] $: a
    a a shove
    a toQuote '[ ⭮ ]' assert=

    [ 1 2 3 ] $: b
    b b shove
    b toQuote '[ 1 2 3 ⭮ ]' assert=

    [ 1 2 3 ] $: c
    c 1 |to
    c toQuote '[ 1 | 2 3 ]' assert=

    c c shove
    c toQuote '[ 1 ⭮ | 2 3 ]' assert=
  ]

  it should 'respect quote reprs' [
    [ 'fooBar' $: *asQuote ] obj $: x
    x toQuote 'fooBar' assert=
  ]

  it should 'enquote reflection keys' [
    orphan $: x
    x x 100 pushes
    x x 200 pushes
    x toQuote '[ · ${⭮ :: 200} ]' assert=
    orphan $: y
    y x y pushes
    x y x pushes
    x toQuote '[ · ${⭮ :: 200} ${[ · ${⭮ :: a block} ] :: a block} ]' assert=
    y toQuote '[ · ${[ · ${⭮ :: 200} ${⭮ :: a block} ] :: a block} ]' assert=
  ]

  "todo more tests"
]

describe 'effect' [
  in lang

  it should 'work for forms other than block & builtin' [
    100 effect '100' assert=
    true effect 'true' assert=
    'hello \n world' effect '\'hello \\n world\'' assert=
  ]

  it should 'work for builtins' [
    #+ here effect '( A B -- S )' assert=
  ]

  it should 'work for blocks' [
    [] effect 'a block' assert=
    [ "Hello World" ] effect 'a block' assert=
    [ "( -- )"] effect 'a block' assert=
    [ "( -- ) fooBoo"] effect 'a block' assert=
    [ "( -- ): hello world"] effect '( -- )' assert=
    #map: here effect '( Lb map: B -- MLb )' assert=
  ]
]

describe 'builtin?' [
  in lang

  it should 'leave true for builtin' [
    #+ here builtin? true assert=
  ]

  it should 'leave false for everything else' [
    [ ] builtin? false assert=
    123 builtin? false assert=
    "..."
  ]
]

describe 'asBuiltin' [
  in lang

  it should 'leave builtins as is' [
    #+ here asBuiltin #+ here assert=
  ]

  it should 'die when not a builtin' [
    [ 123 asBuiltin ] 'bad type: decimal, expected: a builtin' assertDies
    [ '123' asBuiltin ] 'bad type: quote, expected: a builtin' assertDies
    [ [ ] asBuiltin ] 'bad type: block, expected: a builtin' assertDies
  ]
]

describe 'color?' [
  in lang

  it should 'leave true for colors' [
    0 0 0 rgb color? true assert=
  ]

  it should 'leave false for other forms' [
    123 color? false assert=
    '123' color? false assert=
    [ ] color? false assert= "...etc.."
  ]

  it should 'leave false for block implementing *asColor' [
    [   0 0 0 rgb  $: *asColor this ] $: x
    [ [ 0 0 0 rgb] @: *asColor this ] $: y
    x color? false assert=
    y color? false assert=
  ]

  [ $: x x $: *asColor this ] @: a

  it should 'leave instance when given color in *asColor' [
    0 0 0 rgb a dup asColor same? true assert=
  ]

  it should 'die when not given color in *asColor' [
    [ 'foo' a asColor ] 'bad type: quote, expected: a color' assertDies
  ]
]

describe 'asColor' [
  in lang

  it should 'leave colors as is' [
    0 0 0 rgb asColor 0 0 0 rgb assert=
  ]

  it should 'die when not a color' [
    [ 123 asColor ] 'bad type: decimal, expected: a color' assertDies
    [ '123' asColor ] 'bad type: quote, expected: a color' assertDies
    [ [ ] asColor ] 'bad type: block, expected: a color' assertDies
  ]
]

describe 'stitch' [
  in lang

  it should 'stitch two empty quotes' [
    '' '' stitch '' assert=
  ]

  it should 'stitch char + empty quotes' [
    'f' '' stitch 'f' assert=
  ]

  it should 'stitch char/multichar + empty quotes' [
    '' 'f' stitch 'f' assert=
    'f' '' stitch 'f' assert=
    'hello' '' stitch 'hello' assert=
    '' 'hello' stitch 'hello' assert=
  ]

  it should 'stitch single character quotes' [
    'x' 'y' stitch 'xy' assert=
    'ä' '🤖' stitch 'ä🤖' assert=
    '👽' '😡' stitch '👽😡' assert=
  ]

  it should 'stitch single-char + multi-char quote' [
    'x' 'yzzy' stitch 'xyzzy' assert=
    'xyzz' 'y' stitch 'xyzzy' assert=
    '😡' '😈ああax💩🤡' stitch '😡😈ああax💩🤡' assert=
    '😡😈ああax💩' '🤡' stitch '😡😈ああax💩🤡' assert=
  ]

  it should 'stitch multi-char + multi-char quote' [
    'xy' 'zzy' stitch 'xyzzy' assert=
    '😈ああax💩' '👽😡fubar' stitch '😈ああax💩👽😡fubar' assert=
  ]
]

describe 'count' [
  in lang

  it should 'leave 0 for empty block' [
    [ ] count 0 assert=
  ]

  it should 'leave 0 for empty quote' [
    '' count 0 assert=
  ]

  it should 'count the amount of elements in blocks' [
    [ 1 2 3 4 ] count 4 assert=
  ]

  it should 'count one grapheme' [
    '👨‍👩‍👧' count 1 assert=
  ]

  it should 'count one character' [
    'f' count 1 assert=
  ]

  it should 'count one unicode character' [
    'å' count 1 assert=
  ]

  it should 'count Unicode extended grapheme clusters correctly' [
    '🍎👨‍👩‍👧' count 2 assert= "apple followed by family"
    '😡😈ああax💩🤡' count 8 assert=
  ]

  it should 'count the amount of characters (graphemes) in quotes' [
    'Ⓐs°Ämanчеловек' count 14 assert=
  ]

  it should 'die when invalid type' [
    [ 123 count ] 'bad type: decimal, expected: a block, byteslice, or quote' assertDies
  ]
]

describe 'fromLeft' [
  in lang

  it dies 'when block is empty' [
    [ ] 0 fromLeft
  ]

  it dies 'when quote is empty' [
    '' 0 fromLeft
  ]

  it dies 'when index is negative for block' [
    [ 1 2 3 ] -1 fromLeft
  ]

  it dies 'when index is negative for quote' [
    'hello world' -1 fromLeft
  ]

  it should 'leave block element when index is in bounds' [
    [ 1 2 3 ] 0 fromLeft 1 assert=
    [ 1 2 3 ] 1 fromLeft 2 assert=
    [ 1 2 3 ] 2 fromLeft 3 assert=
  ]

  it should 'leave quote grapheme when index is in bounds' [
    '👨‍👩‍👧🍎' 0 fromLeft '👨‍👩‍👧' assert= "family followed by apple"
    '👨‍👩‍👧🍎' 1 fromLeft   '🍎' assert=

    'Ⓐs°Ämanчел' 0 fromLeft 'Ⓐ' assert=
    'Ⓐs°Ämanчел' 1 fromLeft 's' assert=
    'Ⓐs°Ämanчел' 2 fromLeft '°' assert=
    'Ⓐs°Ämanчел' 3 fromLeft 'Ä' assert=
    'Ⓐs°Ämanчел' 6 fromLeft 'n' assert=
    'Ⓐs°Ämanчел' 9 fromLeft 'л' assert=
  ]

  it dies 'when block index is out of bounds' [
    [ 1 2 3 ] 4 fromLeft
  ]

  it dies 'when quote index is out of bounds' [
    'hœllö' 5 fromLeft
  ]

  it should 'die when argument is not block/quote' [
    [ 123 0 fromLeft ] 'bad type: decimal, expected: a block, byteslice, or quote' assertDies
  ]
]


describe 'fromRight' [
  in lang

  it should 'leave nth from right in block/quote' [
    [ 1 2 3 ] 0 fromRight 3 assert=
    [ 1 2 3 ] 1 fromRight 2 assert=
    [ 1 2 3 ] 2 fromRight 1 assert=
    'hello world' 0 fromRight 'd' assert=

    [ 123 0 fromRight ] 'bad type: decimal, expected: a block, byteslice, or quote' assertDies
    [ 'he' 'llo' fromRight ] 'bad type: quote, expected: a decimal' assertDies
  ]

  it should 'index quotes correctly' [
    '👨‍👩‍👧🍎' 0 fromRight   '🍎' assert= "family followed by apple"
    '👨‍👩‍👧🍎' 1 fromRight '👨‍👩‍👧' assert=

    'Ⓐs°Ämanчел' 9 fromRight 'Ⓐ' assert=
    'Ⓐs°Ämanчел' 8 fromRight 's' assert=
    'Ⓐs°Ämanчел' 7 fromRight '°' assert=
    'Ⓐs°Ämanчел' 6 fromRight 'Ä' assert=
    'Ⓐs°Ämanчел' 3 fromRight 'n' assert=
    'Ⓐs°Ämanчел' 0 fromRight 'л' assert=
  ]

  it should 'die when index is invalid' [
    [ [ ] 0 fromRight ] 'index out of bounds' assertDies
    [ '' 0 fromRight ] 'grapheme index out of bounds' assertDies
    [ [ 1 2 3 ] 3 fromRight ] 'index out of bounds' assertDies
    [ [ 1 2 3 ] -1 fromRight ] 'decimal is not a positive integer: -1' assertDies
  ]
]


describe 'fromLeft*' [
  in lang

  it should 'take n items from left in block/quote' [
    [ 1 2 3 ] 0 fromLeft* [ ] assert=
    [ 1 2 3 ] 1 fromLeft* [ 1 ] assert=
    [ 1 2 3 ] 2 fromLeft* [ 1 2 ] assert=
    [ 1 2 3 ] 3 fromLeft* [ 1 2 3 ] assert=
    [ 1 2 3 ] 4 fromLeft* [ 1 2 3 ] assert=

    [ ] 0 fromLeft* [ ] assert=
    [ ] 123 fromLeft* [ ] assert=
    '' 0 fromLeft* '' assert=
    '' 123 fromLeft* '' assert=

    'hello world' 0 fromLeft* '' assert=
    'hello world' 1 fromLeft* 'h' assert=
    'hello world' 2 fromLeft* 'he' assert=
    'hello world' 5 fromLeft* 'hello' assert=
    'hello world' 100 fromLeft* 'hello world' assert=

    [ 123 0 fromLeft* ] 'bad type: decimal, expected: a block, byteslice, or quote' assertDies
    [ 'he' 'llo' fromLeft* ] 'bad type: quote, expected: a decimal' assertDies
  ]

  it should 'index quotes correctly' [
    '👨‍👩‍👧🍎' 1 fromLeft* '👨‍👩‍👧' assert= "family followed by apple"
    '👨‍👩‍👧🍎' 2 fromLeft* '👨‍👩‍👧🍎' assert=

    'Ⓐs°Ämanчел' 0 fromLeft* '' assert=
    'Ⓐs°Ämanчел' 1 fromLeft* 'Ⓐ' assert=
    'Ⓐs°Ämanчел' 2 fromLeft* 'Ⓐs' assert=
    'Ⓐs°Ämanчел' 3 fromLeft* 'Ⓐs°' assert=
    'Ⓐs°Ämanчел' 4 fromLeft* 'Ⓐs°Ä' assert=
    'Ⓐs°Ämanчел' 7 fromLeft* 'Ⓐs°Äman' assert=
    'Ⓐs°Ämanчел' 10 fromLeft* 'Ⓐs°Ämanчел' assert=
  ]

  it should 'die when index is invalid' [
    [ [ 1 2 3 ] -1 fromLeft* ] 'decimal is not a positive integer: -1' assertDies
  ]
]


describe 'fromRight' [
  in lang

  it should 'leave nth from right in block/quote' [
    [ 1 2 3 ] 0 fromRight* [ ] assert=
    [ 1 2 3 ] 1 fromRight* [ 3 ] assert=
    [ 1 2 3 ] 2 fromRight* [ 2 3 ] assert=
    [ 1 2 3 ] 3 fromRight* [ 1 2 3 ] assert=
    [ 1 2 3 ] 4 fromRight* [ 1 2 3 ] assert=

    [ ] 0 fromRight* [ ] assert=
    [ ] 123 fromRight* [ ] assert=
    '' 0 fromRight* '' assert=
    '' 123 fromRight* '' assert=

    'hello world' 0 fromRight* '' assert=
    'hello world' 1 fromRight* 'd' assert=
    'hello world' 2 fromRight* 'ld' assert=
    'hello world' 5 fromRight* 'world' assert=
    'hello world' 100 fromRight* 'hello world' assert=

    [ 123 0 fromRight* ] 'bad type: decimal, expected: a block, byteslice, or quote' assertDies
    [ 'he' 'llo' fromRight* ] 'bad type: quote, expected: a decimal' assertDies
  ]

  it should 'index quotes correctly' [
    '👨‍👩‍👧🍎' 1 fromRight*   '🍎' assert= "family followed by apple"
    '👨‍👩‍👧🍎' 2 fromRight*'👨‍👩‍👧🍎' assert=

    'Ⓐs°Ämanчел' 10 fromRight* 'Ⓐs°Ämanчел' assert=
    'Ⓐs°Ämanчел' 9 fromRight* 's°Ämanчел' assert=
    'Ⓐs°Ämanчел' 8 fromRight* '°Ämanчел' assert=
    'Ⓐs°Ämanчел' 7 fromRight* 'Ämanчел' assert=
    'Ⓐs°Ämanчел' 4 fromRight* 'nчел' assert=
    'Ⓐs°Ämanчел' 1 fromRight* 'л' assert=
  ]

  it should 'die when index is invalid' [
    [ [ 1 2 3 ] -1 fromRight* ] 'decimal is not a positive integer: -1' assertDies
  ]
]


describe 'toWord' [
  in lang

  it should 'noop if already word' [
    #hello toWord #hello assert=
  ]

  it should 'convert quote to word' [
    'hello' toWord #hello assert=
  ]

  it should 'peel off all quoting' [
    ########hello toWord #hello assert=
  ]

  it should 'convert when quote has grapheme clusters' [
    'x👻👺🤖' toWord #x👻👺🤖 assert=
  ]

  it should 'die when quote is invalid' [
    [ '' toWord ] 'toWord: quote argument is empty' assertDies
    [ ' ' toWord ] 'toWord: quote argument contains whitespace' assertDies
    [
    '


    ' toWord ] 'toWord: quote argument contains whitespace' assertDies
    [ 'hello world' toWord ] 'toWord: quote argument contains whitespace' assertDies
  ]

  it should 'die when of invalid type' [
    [ 123 toWord ] 'bad type: decimal, expected: a quote, quoted word, or word' assertDies
  ]
]

describe 'uppercase?' [
  in lang

  it should 'leave false for empty quote' [
    '' uppercase? false assert=
  ]

  it should 'leave false for whitespace quote' [
    ' ' uppercase? false assert=
    '     ' uppercase? false assert=
    '
    ' uppercase? false assert=
  ]

  it should 'work for single-letter quotes' [
    'H' uppercase?  true assert=
    'Á' uppercase?  true assert=
    'c' uppercase? false assert=
    '.' uppercase? false assert=
  ]

  it should 'work for multi-letter quotes' [
    'HELLO' uppercase?  true assert=
      'HÁË' uppercase?  true assert=
    'HeLLO' uppercase? false assert=
    'HÁËå'  uppercase? false assert=
  ]
]

describe 'toUppercase' [
  in lang

  it dies 'when not given a quote #1' [
    0 toUppercase
  ]

  it dies 'when not given a quote #2' [
    #foo toUppercase
  ]

  it should 'leave empty quote unchanged' [
    '' toUppercase '' assert=
  ]

  it should 'leave whitespace/single-uppercase-character quote unchanged' [
    ' ' toUppercase ' ' assert=
    'C' toUppercase 'C' assert=
    'Ä' toUppercase 'Ä' assert=
    '.' toUppercase '.' assert=
    '0' toUppercase '0' assert=
    '°' toUppercase '°' assert=
    '€' toUppercase '€' assert=
  ]


  it should 'uppercase single lowercase character' [
    'c' toUppercase 'C' assert=
    'ä' toUppercase 'Ä' assert=
    'ā' toUppercase 'Ā' assert=
  ]

  it should 'uppercase multi-character quotes' [
    'HI' toUppercase 'HI' assert=
    'Hi' toUppercase 'HI' assert=
    'hI' toUppercase 'HI' assert=
    'Ḧï' toUppercase 'ḦÏ' assert=
    'Ãuxi£åÅ' toUppercase 'ÃUXI£ÅÅ' assert=
  ]
]

describe 'sliceQuoteAt' [
  in lang

  it dies 'when given non-quote #1' [
    0 1 sliceQuoteAt
  ]

  it dies 'when given non-quote #2' [
    #foobar 1 sliceQuoteAt
  ]

  it dies 'when given non-quote #3' [
    ##foobar 1 sliceQuoteAt
  ]

  it dies 'when given non-quote #4' [
    [ 1 2 3 ] 1 sliceQuoteAt
  ]

  it dies 'when given empty quote' [
    '' 0 sliceQuoteAt
  ]

  it dies 'when slicepoint is negative' [
    'foobar' -1 sliceQuoteAt
  ]

  it dies 'when slicepoint > quote count' [
    'foobar' 7 sliceQuoteAt
  ]

  it should 'handle slicepoint 0 = case' [
    [ 'foobar' 0 sliceQuoteAt ] vals [ '' 'foobar' ] assert=
  ]

  it should 'handle slicepoint quote count = case' [
    [ 'foobar' 6 sliceQuoteAt ] vals [ 'foobar' '' ] assert=
  ]

  it should 'properly slice in bounds' [
    [ 'foo|bar' 3 sliceQuoteAt ] vals [ 'foo' '|bar' ] assert=
  ]

  it should 'properly slice when Unicode characters present' [
    [ 'Ⓐs°Ämanчел' 4 sliceQuoteAt ] vals [ 'Ⓐs°Ä' 'manчел' ] assert=
  ]

  it should 'properly slice single grapheme cluster' [
    [ '👨‍👩‍👧' 0 sliceQuoteAt ] vals [ '' '👨‍👩‍👧' ] assert=
    [ '👨‍👩‍👧' 1 sliceQuoteAt ] vals [ '👨‍👩‍👧' '' ] assert=
  ]

  it should 'properly slice multiple grapheme clusters + characters' [
    [ '©oobaz👨‍👩‍👧🍎föobar' 7 sliceQuoteAt ] vals [ '©oobaz👨‍👩‍👧' '🍎föobar' ] assert=
  ]
]

describe '|slice' [
  in lang

  it dies 'when given non-block #1' [
    #foobar |slice
  ]

  it dies 'when given non-block #2' [
    true |slice
  ]

  it dies 'when given non-block #4' [
    'foobar' |slice
  ]

  it dies 'when given non-block #5' [
    100 |slice
  ]

  it should 'slice when |at 0' [
    [ [ ] |slice ] vals [ [ ] [ ] ] assert=
    [ [ 1 2 3 ] dup 0 |to |slice ] vals [ [ ] [ 1 2 3 ] ] assert=
  ]

  it should 'slice when |at count' [
    [ [ 1 2 3 ] |slice ] vals [ [ 1 2 3 ] [ ] ] assert=
  ]

  it should 'slice when |at in first half' [
    [ [ 1 2 3 4 ] dup 1 |to |slice ] vals [ [ 1 ] [ 2 3 4 ] ] assert=
  ]

  it should 'slice when |at in second half' [
    [ [ 1 2 3 4 ] dup 3 |to |slice ] vals [ [ 1 2 3 ] [ 4 ] ] assert=
  ]
]


describe 'slurp' [
  in lang

  it should 'handle empty quote' [
    [ ] '' slurp [ ] assert=
  ]

  it should 'slurp words properly' [
    [ ] 'hello-world 2boo 2.foo x.yzzy a.b.c 0. .0' slurp [ hello-world 2boo 2 . foo x . yzzy a . b . c 0 . . 0 ] assert=
  ]

  it should 'slurp grapheme cluster words properly' [
    [ ] '👨‍👩‍👧 👨‍👨‍👦‍👦 🍏🍏🍏 🦊.Hi!.x <<🐘Bye!>>' slurp $: uniwords
    uniwords 0 fromLeft #👨‍👩‍👧 assert=
    uniwords 1 fromLeft #👨‍👨‍👦‍👦 assert=
    uniwords 2 fromLeft #🍏🍏🍏 assert=
    uniwords 5 fromRight #🦊 assert=
    uniwords 4 fromRight #. assert=
    uniwords 3 fromRight #Hi! assert=
    uniwords 2 fromRight #. assert=
    uniwords 1 fromRight #x assert=
    uniwords 0 fromRight #<<🐘Bye!>> assert=
  ]

  it should 'slurp quoted words' [
    [ ] '# #x #x👻👺🤖 #x.y #x.#y.#z' slurp [ # #x #x👻👺🤖 #x.y #x.#y.#z ] assert=
    [ ] '## #x #x👻👺🤖 #x.y #x.#y.#z' slurp vals [ ## #x #x👻👺🤖 #x.y #x.#y.#z ] vals assert=
  ]

  it should 'slurp decimals properly' [
    [ ] '123 -123 +123 1_23 1__23 -12_3 -_1 -1_ +_1 +1_ 0000 0.000 .123 123. _.123 123._ 0.1 0.23 0.23_4 0_.23_4 _0.234 0.23_ 0._23 0.123456789123456789123456789' slurp
      [
        123
        -123
        123
        123
        123
        -123
        #-_1
        #-1_
        #+_1
        #+1_
        0
        0
        #. 123
        123 #.
        #_ #. 123
        123 #. #_
        0.1
        0.23
        0.234
        #0_ #. 234
        #_0 #. 234
        0 #. #23_
        0 #. #_23
        0.123456789123456789123456789
      ] vals assert=
  ]

  it should 'slurp quotes correctly' [
    [ ] '\'🐒hello 👋 \invalid \Escape \\\'world!!!\\\' \\\\n \\n \n\n 👨‍👨‍👦‍👦!🐹\'' slurp val
    '🐒hello 👋 \invalid \Escape \'world!!!\' \\n \n \n\n 👨‍👨‍👦‍👦!🐹' assert=

    [ [ ] '\'hello world!!' slurp ] 'unterminated excerpt: no matching ｢\'｣' assertDies
    [ [ ] 'hello world!!\'' slurp ] 'unterminated excerpt: no matching ｢\'｣' assertDies
    [ [ ] '\'\\' slurp ] 'excerpt ended suddenly: expected escape sequence, grapheme, or ｢\'｣' assertDies
  ]

  it should 'slurp comments correctly' [
    [ ] '[ "🐒hello 👋 \invalid \Escape \"world!!!\" \\\\n \\n \n\n 👨‍👨‍👦‍👦!🐹" ]' slurp top desc
      '🐒hello 👋 \invalid \Escape "world!!!" \\n \\n \n\n👨‍👨‍👦‍👦!🐹' assert=
  ]

  it should 'slurp block open/close brackets properly' [
    [ ] '[]' slurp [ [ ] ] assert=
    [ ] '[.]' slurp [ [ . ] ] assert=
    [ ] '[ ]' slurp [ [ ] ] assert=
    [ ] '[🐒 ]' slurp [ [ 🐒 ] ] assert=
    [ ] '[👨‍👨‍👦‍👦]' slurp [ [ 👨‍👨‍👦‍👦 ] ] assert=
    [ ] '[👨‍👨‍👦 👋]' slurp [ [ 👨‍👨‍👦 👋 ] ] assert=
    [ ] '[ 👨‍👨‍👦 👋]' slurp [ [ 👨‍👨‍👦 👋 ] ] assert=
    [ ] '[👨‍👨‍👦 👋 ]' slurp [ [ 👨‍👨‍👦 👋 ] ] assert=

    [ [ ] '[' slurp ] 'missing \']\'' assertDies
    [ [ ] ']' slurp ] 'mismatched \']\' in block' assertDies
  ]
]
