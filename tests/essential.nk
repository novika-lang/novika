describe 'quote?' [
  it should 'leave false for block' [ [ ] quote? not ]
  it should 'leave false for true' [ true quote? not ]
  it should 'leave false for false' [ false quote? not ]
  it should 'leave false for decimal' [ 1234 quote? not ]
  it should 'leave false for word' [ #foobar quote? not ]
  it should 'leave false for quoted word' [ ##foobar quote? not ]
  it should 'leave true for quote' [ 'hello world' quote? ]
  it should 'leave false for block implementing *asQuote' [
    [   'foo'   $: *asQuote this ] $: x
    [ [ 'foo' ] @: *asQuote this ] $: y
    x quote? false assert=
    y quote? false assert=
  ]
]

describe 'enquote' [
  "TODO: enquote block. It needs a pretty large set of tests
   for itself."
  it should 'enquote boolean true' [ true enquote 'true' assert= ]
  it should 'enquote boolean false' [ false enquote 'false' assert= ]
  it should 'enquote builtin' [ #+ here enquote '[native code]' assert= ]
  it should 'enquote decimal' [ 100 enquote '100' assert= ]
  it should 'enquote -decimal' [ -100 enquote '-100' assert= ]
  it should 'enquote +decimal' [ +100 enquote '100' assert= ]
  it should 'enquote quote' [ 'hello world' enquote 'hello world' assert= ]
  it should 'enquote word' [ #hello enquote 'hello' assert= ]
  it should 'enquote quoted word' [ ##hello enquote '#hello' assert= ]
]

describe 'stitch' [
  it should 'stitch two empty quotes' [
    '' '' stitch '' assert=
  ]

  it should 'stitch char + empty quotes' [
    'f' '' stitch 'f' assert=
  ]

  it should 'stitch char/multichar + empty quotes' [
    '' 'f' stitch 'f' assert=
    'f' '' stitch 'f' assert=
    'hello' '' stitch 'hello' assert=
    '' 'hello' stitch 'hello' assert=
  ]

  it should 'stitch single character quotes' [
    'x' 'y' stitch 'xy' assert=
    'Ã¤' 'ğŸ¤–' stitch 'Ã¤ğŸ¤–' assert=
    'ğŸ‘½' 'ğŸ˜¡' stitch 'ğŸ‘½ğŸ˜¡' assert=
  ]

  it should 'stitch single-char + multi-char quote' [
    'x' 'yzzy' stitch 'xyzzy' assert=
    'xyzz' 'y' stitch 'xyzzy' assert=
    'ğŸ˜¡' 'ğŸ˜ˆã‚ã‚axğŸ’©ğŸ¤¡' stitch 'ğŸ˜¡ğŸ˜ˆã‚ã‚axğŸ’©ğŸ¤¡' assert=
    'ğŸ˜¡ğŸ˜ˆã‚ã‚axğŸ’©' 'ğŸ¤¡' stitch 'ğŸ˜¡ğŸ˜ˆã‚ã‚axğŸ’©ğŸ¤¡' assert=
  ]

  it should 'stitch multi-char + multi-char quote' [
    'xy' 'zzy' stitch 'xyzzy' assert=
    'ğŸ˜ˆã‚ã‚axğŸ’©' 'ğŸ‘½ğŸ˜¡fubar' stitch 'ğŸ˜ˆã‚ã‚axğŸ’©ğŸ‘½ğŸ˜¡fubar' assert=
  ]
]

describe 'count' [
  it should 'leave 0 for empty block' [
    [ ] count 0 assert=
  ]

  it should 'leave 0 for empty quote' [
    '' count 0 assert=
  ]

  it should 'count the amount of elements in blocks' [
    [ 1 2 3 4 ] count 4 assert=
  ]

  it should 'count one grapheme' [
    'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§' count 1 assert=
  ]

  it should 'count one character' [
    'f' count 1 assert=
  ]

  it should 'count one unicode character' [
    'Ã¥' count 1 assert=
  ]

  it should 'count Unicode extended grapheme clusters correctly' [
    'ğŸğŸ‘¨â€ğŸ‘©â€ğŸ‘§' count 2 assert= "apple followed by family"
    'ğŸ˜¡ğŸ˜ˆã‚ã‚axğŸ’©ğŸ¤¡' count 8 assert=
  ]

  it should 'count the amount of characters (graphemes) in quotes' [
    'â’¶sÂ°Ã„manÑ‡ĞµĞ»Ğ¾Ğ²ĞµĞº' count 14 assert=
  ]
]

describe 'fromLeft' [
  it dies 'when block is empty' [
    [ ] 0 fromLeft
  ]

  it dies 'when quote is empty' [
    '' 0 fromLeft
  ]

  it dies 'when index is negative for block' [
    [ 1 2 3 ] -1 fromLeft
  ]

  it dies 'when index is negative for quote' [
    'hello world' -1 fromLeft
  ]

  it should 'leave block element when index is in bounds' [
    [ 1 2 3 ] 0 fromLeft 1 assert=
    [ 1 2 3 ] 1 fromLeft 2 assert=
    [ 1 2 3 ] 2 fromLeft 3 assert=
  ]

  it should 'leave quote grapheme when index is in bounds' [
    'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ğŸ' 0 fromLeft 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§' assert= "family followed by apple"
    'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ğŸ' 1 fromLeft   'ğŸ' assert=

    'â’¶sÂ°Ã„manÑ‡ĞµĞ»' 0 fromLeft 'â’¶' assert=
    'â’¶sÂ°Ã„manÑ‡ĞµĞ»' 1 fromLeft 's' assert=
    'â’¶sÂ°Ã„manÑ‡ĞµĞ»' 2 fromLeft 'Â°' assert=
    'â’¶sÂ°Ã„manÑ‡ĞµĞ»' 3 fromLeft 'Ã„' assert=
    'â’¶sÂ°Ã„manÑ‡ĞµĞ»' 6 fromLeft 'n' assert=
    'â’¶sÂ°Ã„manÑ‡ĞµĞ»' 9 fromLeft 'Ğ»' assert=
  ]

  it dies 'when block index is out of bounds' [
    [ 1 2 3 ] 4 fromLeft
  ]

  it dies 'when quote index is out of bounds' [
    'hÅ“llÃ¶' 5 fromLeft
  ]
]

describe 'toWord' [
  it should 'noop if already word' [
    #hello toWord #hello assert=
  ]

  it should 'convert quote to word' [
    'hello' toWord #hello assert=
  ]

  it should 'peel off all quoting' [
    ########hello toWord #hello assert=
  ]

  it should 'convert when quote has grapheme clusters' [
    'xğŸ‘»ğŸ‘ºğŸ¤–' toWord #xğŸ‘»ğŸ‘ºğŸ¤– assert=
  ]

  it dies 'when quote is empty' [
    '' toWord
  ]

  it dies 'when quote is whitespace' [
    ' ' toWord
  ]

  it dies 'when quote is newline + whitespace' [
    '


    ' toWord
  ]

  it dies 'when quote contains whitespace' [
    'hello world' toWord
  ]
]

describe 'uppercase?' [
  it should 'leave false for empty quote' [
    '' uppercase? false assert=
  ]

  it should 'leave false for whitespace quote' [
    [ ] [
      ' ' uppercase? false assert=
      '     ' uppercase? false assert=
      '
      ' uppercase? false assert=
    ] there [ ] all?
  ]

  it should 'work for single-letter quotes' [
    [ ] [
      'H' uppercase?  true assert=
      'Ã' uppercase?  true assert=
      'c' uppercase? false assert=
      '.' uppercase? false assert=
    ] there [ ] all?
  ]

  it should 'work for multi-letter quotes' [
    [ ] [
      'HELLO' uppercase?  true assert=
        'HÃÃ‹' uppercase?  true assert=
      'HeLLO' uppercase? false assert=
      'HÃÃ‹Ã¥'  uppercase? false assert=
    ] there [ ] all?
  ]
]

describe 'toUppercase' [
  it dies 'when not given a quote #1' [
    0 toUppercase
  ]

  it dies 'when not given a quote #2' [
    #foo toUppercase
  ]

  it should 'leave empty quote unchanged' [
    '' toUppercase '' assert=
  ]

  it should 'leave whitespace/single-uppercase-character quote unchanged' [
    [ ] [
      ' ' toUppercase ' ' assert=
      'C' toUppercase 'C' assert=
      'Ã„' toUppercase 'Ã„' assert=
      '.' toUppercase '.' assert=
      '0' toUppercase '0' assert=
      'Â°' toUppercase 'Â°' assert=
      'â‚¬' toUppercase 'â‚¬' assert=
    ] there [ ] all?
  ]


  it should 'uppercase single lowercase character' [
    [ ] [
      'c' toUppercase 'C' assert=
      'Ã¤' toUppercase 'Ã„' assert=
      'Ä' toUppercase 'Ä€' assert=
    ] there [ ] all?
  ]

  it should 'uppercase multi-character quotes' [
    [ ] [
      'HI' toUppercase 'HI' assert=
      'Hi' toUppercase 'HI' assert=
      'hI' toUppercase 'HI' assert=
      'á¸¦Ã¯' toUppercase 'á¸¦Ã' assert=
      'ÃƒuxiÂ£Ã¥Ã…' toUppercase 'ÃƒUXIÂ£Ã…Ã…' assert=
    ] there [ ] all?
  ]
]

describe 'sliceQuoteAt' [
  it dies 'when given non-quote #1' [
    0 1 sliceQuoteAt
  ]

  it dies 'when given non-quote #2' [
    #foobar 1 sliceQuoteAt
  ]

  it dies 'when given non-quote #3' [
    ##foobar 1 sliceQuoteAt
  ]

  it dies 'when given non-quote #4' [
    [ 1 2 3 ] 1 sliceQuoteAt
  ]

  it dies 'when given empty quote' [
    '' 0 sliceQuoteAt
  ]

  it dies 'when slicepoint is negative' [
    'foobar' -1 sliceQuoteAt
  ]

  it dies 'when slicepoint > quote count' [
    'foobar' 7 sliceQuoteAt
  ]

  it should 'handle slicepoint 0 = case' [
    [ ] [ 'foobar' 0 sliceQuoteAt ] there [ '' 'foobar' ] assert=
  ]

  it should 'handle slicepoint quote count = case' [
    [ ] [ 'foobar' 6 sliceQuoteAt ] there [ 'foobar' '' ] assert=
  ]

  it should 'properly slice in bounds' [
    [ ] [ 'foo|bar' 3 sliceQuoteAt ] there [ 'foo' '|bar' ] assert=
  ]

  it should 'properly slice when Unicode characters present' [
    [ ] [ 'â’¶sÂ°Ã„manÑ‡ĞµĞ»' 4 sliceQuoteAt ] there [ 'â’¶sÂ°Ã„' 'manÑ‡ĞµĞ»' ] assert=
  ]

  it should 'properly slice single grapheme cluster' [
    [ ] [ 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§' 0 sliceQuoteAt ] there [ '' 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§' ] assert=
    [ ] [ 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§' 1 sliceQuoteAt ] there [ 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§' '' ] assert=
  ]

  it should 'properly slice multiple grapheme clusters + characters' [
    [ ] [ 'Â©oobazğŸ‘¨â€ğŸ‘©â€ğŸ‘§ğŸfÃ¶obar' 7 sliceQuoteAt ] there [ 'Â©oobazğŸ‘¨â€ğŸ‘©â€ğŸ‘§' 'ğŸfÃ¶obar' ] assert=
  ]
]

describe '|slice' [
  it dies 'when given non-block #1' [
    #foobar |slice
  ]

  it dies 'when given non-block #2' [
    true |slice
  ]

  it dies 'when given non-block #4' [
    'foobar' |slice
  ]

  it dies 'when given non-block #5' [
    100 |slice
  ]

  it should 'slice when |at 0' [
    [ ] [ [ ] |slice ] there [ [ ] [ ] ] assert=
    [ ] [ [ 1 2 3 ] dup 0 |to |slice ] there [ [ ] [ 1 2 3 ] ] assert=
  ]

  it should 'slice when |at count' [
    [ ] [ [ 1 2 3 ] |slice ] there [ [ 1 2 3 ] [ ] ] assert=
  ]

  it should 'slice when |at in first half' [
    [ ] [ [ 1 2 3 4 ] dup 1 |to |slice ] there [ [ 1 ] [ 2 3 4 ] ]
  ]

  it should 'slice when |at in second half' [
    [ ] [ [ 1 2 3 4 ] dup 3 |to |slice ] there [ [ 1 2 3 ] [ 4 ] ]
  ]
]
