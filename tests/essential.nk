describe 'new' [
  in lang

  it should 'force-reparent only immediate children, otherwise simply recurse' [
    [ $: x [ x ] ] @: newBox

    1 newBox $: fooBox1
    2 newBox $: fooBox2
    3 newBox $: fooBox3

    fooBox1 open 1 assert=
    fooBox2 open 2 assert=
    fooBox3 open 3 assert=

    [ fooBox1 fooBox2 fooBox3 ] vals $: boxes

    boxes 0 fromLeft open 1 assert=
    boxes 1 fromLeft open 2 assert=

    boxes new $: boxesInstance
    boxesInstance 0 fromLeft open 1 assert=
    boxesInstance 1 fromLeft open 2 assert=
    boxesInstance 2 fromLeft open 3 assert=

    "fooBox instances are children of the respective fooBoxes"
    (boxesInstance 0 fromLeft parent) (boxes 0 fromLeft) same? true assert=
    (boxesInstance 1 fromLeft parent) (boxes 1 fromLeft) same? true assert=
    (boxesInstance 2 fromLeft parent) (boxes 2 fromLeft) same? true assert=

    boxes boxesInstance same? false assert=

    (boxesInstance parent) boxes same? true assert=

    [ ] $: b
    [ ] $: ca
    [ ] $: cb

    b ca << cb << drop

    b new $: bi
    (bi 0 fromLeft) ca same? false assert=
    (bi 1 fromLeft) cb same? false assert=
    (bi 0 fromLeft parent) ca same? true assert=
    (bi 1 fromLeft parent) cb same? true assert=

    bi new $: bi2
    (bi2 0 fromLeft) ca same? false assert=
    (bi2 1 fromLeft) cb same? false assert=
    (bi2 0 fromLeft parent) (bi 0 fromLeft) same? true assert=
    (bi2 1 fromLeft parent) (bi 1 fromLeft) same? true assert=
  ]

  it should 'skip force-reparenting even if member of ancestry' [
    [ ] $: b

    "ba and bb are immediate children, therefore, they
    are going to be force-reparented."
    b new $: ba
    b new $: bb
    b ba << bb << drop

    "now these are not immediate children of b even though b is
     one of their parents; so they won't be force-reparented:"
    ba new $: ba2
    bb new $: bb2

    b ba2 << bb2 << drop


    b new $: bi

    (bi 0 fromLeft parent) bi same? true assert=
    (bi 1 fromLeft parent) bi same? true assert=
    (bi 2 fromLeft parent) ba2 same? true assert=
    (bi 3 fromLeft parent) bb2 same? true assert=
  ]

  it should 'self-references carry over after non-reparenting recursive instantiation' [
    [ ] $: foo
    [ ] [foo] there $: bar

    foo bar shove

    foo new $: instance

    (instance 0 fromLeft parent) bar same? true assert=
    (instance 0 fromLeft 0 fromLeft) instance same? true assert=
  ]
]


describe 'shallowNew' [
  in lang

  it should 'instantiate a block but not the sub-blocks' [
    [ "Some docs" [ 1 2 | 3 4 ] | [ 5 6 | 7 8 ] ] $: foos


    foos extend: [ 100 $: x ]
    foos 0 fromLeft extend: [ 'foo' $: a ]
    foos 0 fromRight extend: [ 'bar' $: b ]

    foos shallowNew $: si
    si desc 'Some docs' assert=

    si parent foos same? true assert=
    si foos = false assert= "not equal because of foos's dict"
    si (foos toTape) assert=
    si.x 100 assert=

    si 0 fromLeft parent foos same? true assert= "sub-blocks unchanged"
    si 0 fromRight parent foos same? true assert=
    si 0 fromLeft .a 'foo' assert=
    si 0 fromRight .b 'bar' assert=
  ]

  it should 'work as described in the docs example' [
    [ $: x [ x ] ] @: newBox

    1 newBox $: fooBox1
    2 newBox $: fooBox2
    3 newBox $: fooBox3

    fooBox1 open 1 assert=
    fooBox2 open 2 assert=
    fooBox3 open 3 assert=

    [ fooBox1 fooBox2 fooBox3 ] vals $: boxes

    boxes shallowNew $: shallowBoxesInstance
    shallowBoxesInstance 0 fromLeft open 1 assert=
    shallowBoxesInstance 1 fromLeft open 2 assert=
    shallowBoxesInstance 2 fromLeft open 3 assert=

    "Works as expected! Note that sub-blocks are exactly the same as
      those in the original 'boxes' block. However, 'shallowBoxesInstance'
      and 'boxes' are different blocks now:"

    (shallowBoxesInstance 0 fromLeft) (boxes 0 fromLeft) same? true assert=
    (shallowBoxesInstance 1 fromLeft) (boxes 1 fromLeft) same? true assert=
    (shallowBoxesInstance 2 fromLeft) (boxes 2 fromLeft) same? true assert=

    boxes shallowBoxesInstance same? false assert=

    "... and 'shallowBoxesInstance' does indeed have 'boxes' as its parent:"

    (shallowBoxesInstance parent) boxes same? true assert=
  ]
]


describe 'same?' [
  in lang

  it should 'leave whether two forms are the same' [
    1 1 same? true assert=
    1 2 same? false assert=
    1 2 + 3 same? true assert=

    'hello' 'hello' same? true assert=
    'hello' 'hello world' same? false assert=

    true true same? true assert=
    false true same? false assert=

    (0 0 0 rgb) (0 0 0 rgb) same? true assert=
    (0 0 0 rgb) (0 1 0 rgb) same? false assert=

    (#+ here) (#+ here) same? true assert=
    (#+ here) (#- here) same? false assert=

    #+ #+ same? true assert=
    #+ #- same? false assert=

    ##+ ##+ same? true assert=
    ##+ ##- same? false assert=

    [ 1 2 + ] $: b1
    [ 1 2 + ] $: b2

    b1 b2 same? false assert=
    b1 b1 same? true assert=
    b2 b2 same? true assert=

    [ ] $: b3
    b3 b3 shove
    b3 b3 same? true assert=
    (b3 first) b3 same? true assert=

    'hello' toByteslice $: bs1
    'hello' toByteslice $: bs2
    bs1 bs2 same? false assert=
    bs1 bs1 same? true assert=
    bs2 bs2 same? true assert=
  ]
]


describe '=' [
  in lang

  it should 'leaves whether two Forms are equal' [
    1 1 = true assert=
    1 2 = false assert=
    1 2 + 3 = true assert=

    'hello' 'hello' = true assert=
    'hello' 'hello world' = false assert=

    true true = true assert=
    false true = false assert=

    (0 0 0 rgb) (0 0 0 rgb) = true assert=
    (0 0 0 rgb) (0 1 0 rgb) = false assert=

    (#+ here) (#+ here) = true assert=
    (#+ here) (#- here) = false assert=

    #+ #+ = true assert=
    #+ #- = false assert=

    ##+ ##+ = true assert=
    ##+ ##- = false assert=

    [ 1 2 + ] $: b1
    [ 1 2 + ] $: b2

    b1 b2 = true assert=
    b1 b1 = true assert=
    b2 b2 = true assert=

    [ ] $: b3
    b3 b3 shove
    b3 b3 = true assert=
    (b3 first) b3 = true assert=

    'hello' toByteslice $: bs1
    'hello' toByteslice $: bs2
    bs1 bs2 = true assert=
    bs1 bs1 = true assert=
    bs2 bs2 = true assert=
  ]
]


describe 'anyof?' [
  in lang

  it should 'leave false for empty block' [
    [ ] [ ] anyof? false assert=
    123 [ ] anyof? false assert=
    false [ ] anyof? false assert=
    "..etc"
  ]

  it should 'check for booleans' [
    true [ true false false ] anyof? false assert= "because true/false is a word"
    #true [ true false false ] anyof? true assert= "as you can see here"

    true [ true false false ] vals anyof? true assert=
    false [ true true ] vals anyof? false assert=
  ]

  it should 'check for decimals' [
    1 [ 1 2 3 ] anyof? true assert=
  ]

  it should 'check for words and qwords' [
    #hello [ 1 hello 2 3 ] anyof? true assert=
    #hello [ 1 2 3 ] anyof? false assert=
    ##hello [ 1 #hello 2 3 ] anyof? true assert=
    ##hello [ 1 hello 2 3 ] anyof? false assert=
    ###hello [ 1 ##hello 2 3 ] anyof? true assert=
    ##hello [ 1 2 3 #hElLo ] anyof? false assert=
    ##hello [ 1 2 3 ] anyof? false assert=
  ]

  it should 'check for quotes' [
    '' [ 'hello' false 0 -100 true ] anyof? false assert=
    '' [ 'hello' '' false 0 -100 true ] anyof? true assert=
    'hello world' [ 'hello' 'world' ] anyof? false assert=
    'hello world' [ 'hello world' 1 2 'hello world' ] anyof? true assert=
  ]

  it should 'check for colors' [
    [ 0 0 0 rgb
      100 201 201 rgb
    ] vals $: colors

    0 0 0 rgb colors anyof? true assert=
    0 1 0 rgb colors anyof? false assert=

    100 201 201 rgb getHSL hsl colors anyof? true assert=
  ]

  it should 'check for builtins' [
    [ #+ here #- here #* here #/ here ] vals $: bins

    #+ here bins anyof? true assert=
    #/ here bins anyof? true assert=
    #** here bins anyof? false assert=
  ]

  it should 'check for blocks' [
    [ [ 1 2 3 ] [ 4 5 6 ] ] $: b

    [ 1 2 3 ] b anyof? true assert=
    [ 4 5 6 ] b anyof? true assert=
    [ 1 3 2 ] b anyof? false assert=
    [ 4 5 '6' ] b anyof? false assert=
    b new first b anyof? true assert=
    b first shallowCopy b anyof? true assert=
  ]
]


describe 'occurrences' [
  in lang

  it should 'expect block/quote as source' [
    [ 0 0 occurrences ] 'bad type: decimal, expected: a block or quote' assertDies
  ]

  it should 'handle empty cases' [
    [ ] 0 occurrences [ ] assert=
    '' 'foobar' occurrences [ ] assert=
    'foobar' '' occurrences [ ] assert=
  ]

  it should 'leave occurrences of form in block' [
    [ 1 2 34 5 5 8 7 1 9 20 ] 100 occurrences [ ] assert=
    [ 1 2 34 5 5 8 7 1 9 20 ] 20 occurrences [ 9 ] assert=
    [ 1 2 34 5 5 8 7 5 9 20 ] 1 occurrences [ 0 ] assert=
    [ 1 2 34 5 5 8 7 5 9 20 ] 5 occurrences [ 3 4 7 ] assert=

    [ 100 $: x
      200 $: y
      this
    ] $: haystack

    haystack #$: occurrences [ 1 4 ] assert=
    haystack #this occurrences [ 6 ] assert=
    haystack ##this occurrences [ ] assert=
  ]

  it should 'leave occurrences when ASCII-ASCII' [
    'x' 'x' occurrences [ 0 ] assert=
    '\n' '\n' occurrences [ 0 ] assert=
    'hello world' 'o'  occurrences [ 4 7 ] assert=
    'foobar baz boo' 'o' occurrences [ 1 2 12 13 ] assert=
    'foobar baz boo' 'ba' occurrences [ 3 7 ] assert=
    'foobar baz boo' 'oo' occurrences [ 1 12 ] assert=
    'foobar baz boo' 'baz' occurrences [ 7 ] assert=
  ]

  it should 'leave occurrences when Unicodish-Unicodish' [
    'Ã¤' 'ğŸ¤–' occurrences [ ] assert=
    'Ã¤' 'Ã¤' occurrences [ 0 ] assert=
    'ğŸ¤–' 'ğŸ¤–' occurrences [ 0 ] assert=

    'ğŸ‘½ğŸ˜¡' 'ğŸ‘½' occurrences [ 0 ] assert=
    'ğŸ‘½ğŸ˜¡' 'ğŸ˜¡' occurrences [ 1 ] assert=

    'ğŸ˜¡ğŸ˜ˆã‚ã‚axğŸ’©ğŸ¤¡' 'x' occurrences [ 5 ] assert=
    'ğŸ˜¡ğŸ˜ˆã‚ã‚axğŸ’©ğŸ¤¡' 'ã‚' occurrences [ 2 3 ] assert=
    'ğŸ˜¡ğŸ˜ˆã‚ã‚axğŸ’©ğŸ¤¡' 'ax' occurrences [ 4 ] assert=
    'ğŸ˜¡ğŸ˜ˆã‚ã‚axğŸ’©ğŸ¤¡' 'axğŸ’©ğŸ¤¡' occurrences [ 4 ] assert=
    'ğŸ˜¡ğŸ˜ˆã‚ğŸ˜ˆã‚axğŸ’©ğŸ¤¡' 'ğŸ˜ˆã‚' occurrences [ 1 3 ] assert=
  ]
]


describe 'toOrphan' [
  in lang

  it should 'convert block into orphan' [
    0 $: x
    [ ] $: b
    b . x 0 assert=
    b toOrphan
    [ b . x ] 'no value form for \'x\'' assertDies
  ]
]


describe 'entry:submit' [
  in lang

  it should 'replace the value form of an existing definition in this' [
    100 $: x

    this #x 'foobar' entry:submit

    x 'foobar' assert=
    stack count 0 assert=
  ]

  it should 'replace the value form of an existing definition in parents' [
    100 $: x

    [ 200 $: y
      [ 300 $: z
        this #x 'I am x' entry:submit
        this #y 'I am y' entry:submit
        this #z 'I am z' entry:submit
        z 'I am z' assert=
      ] do
      y 'I am y' assert=
      this #z entry:exists? false assert=
    ] do
    x 'I am x' assert=
    this #y entry:exists? false assert=

    stack count 0 assert=
  ]

  it should 'replace the value form of an existing definition in friends' [
    [ 100 $: a ] obj toOrphan $: x
    [ 123 $: a 200 $: b ] obj toOrphan $: y

    x Â·> y Â·> x drop

    x.a 100 assert=
    x.b 200 assert=

    y.a 123 assert=
    y.b 200 assert=

    x #a 'I am a changed from X' entry:submit
    x #b 'I am b changed from X' entry:submit

    x.a 'I am a changed from X' assert=
    y.a 123 assert=

    "y owns b so it's changed"
    x.b 'I am b changed from X' assert=
    y.b 'I am b changed from X' assert=

    y #a 'I am a changed from Y' entry:submit

    x.a 'I am a changed from X' assert=
    y.a 'I am a changed from Y' assert=

    x.b 'I am b changed from X' assert=
    y.b 'I am b changed from X' assert=

    y #b 'I am b changed from Y' entry:submit

    x.a 'I am a changed from X' assert=
    y.a 'I am a changed from Y' assert=

    x.b 'I am b changed from Y' assert=
    y.b 'I am b changed from Y' assert=

    stack count 0 assert=
  ]

  it should 'replace the value form of an existing definition in deep friends' [
    'outer' $: testOuter

    [ 123 $: x1 ] obj $: f1 "< note no toOrphan"
    [ 456 $: x2 ] obj toOrphan $: f2
    [ 789 $: x3 ] obj toOrphan $: f3

    f1 Â·> f2 Â·> f3 Â·> f1 drop

    f1 #x1 'f1 x1' entry:submit
    f1.x1 'f1 x1' assert=

    f2 #x1 'f2 x1' entry:submit
    f1.x1 'f2 x1' assert=

    f3 #x1 'f3 x1' entry:submit
    f1.x1 'f3 x1' assert=

    f1 #x2 'f1 x2' entry:submit
    f2.x2 'f1 x2' assert=

    f2 #x2 'f2 x2' entry:submit
    f2.x2 'f2 x2' assert=

    f3 #x2 'f3 x2' entry:submit
    f2.x2 'f3 x2' assert=

    f1 #x3 'f1 x3' entry:submit
    f3.x3 'f1 x3' assert=

    f2 #x3 'f2 x3' entry:submit
    f3.x3 'f2 x3' assert=

    f3 #x3 'f3 x3' entry:submit
    f3.x3 'f3 x3' assert=

    f1 #testOuter 'outer changed f1' entry:submit
    f1.testOuter 'outer changed f1' assert=
    testOuter 'outer changed f1' assert=

    f2 #testOuter 'outer changed f2' entry:submit
    f2.testOuter 'outer changed f2' assert=
    testOuter 'outer changed f2' assert=

    f3 #testOuter 'outer changed f3' entry:submit
    f3.testOuter 'outer changed f3' assert=
    testOuter 'outer changed f3' assert=

    stack count 0 assert=
  ]

  it should 'leave unchanged whether the definition pushes or opens' [
    123 $: x
    [ 123 1 + ] @: y

    x 123 assert=
    y 124 assert=

    this #x [ 4 5 + ] entry:submit
    this #y [ 6 7 + ] entry:submit

    x [ 4 5 + ] assert=
    y 13 assert=
  ]

  it should 'die if no definition' [
    [ this #xyzzy 123 entry:submit ] 'no entry to submit to' assertDies
  ]

  it should 'properly replace if name form is not a word' [
    [
      'number' $: 0
      'quote' $: 'hello world'
      'quoted word' $: #quotedWord
      this true 'boolean' pushes
      'block' $: [1 2 3]
    ] obj toOrphan $: store

    store 0 'number changed' entry:submit
    [ store 123 '' entry:submit ] 'no entry to submit to' assertDies

    store 'hello world' 'quote changed' entry:submit
    [ store 'foobar baz' '' entry:submit ] 'no entry to submit to' assertDies

    store ##quotedWord 'quoted word changed' entry:submit
    [ store ##booboo '' entry:submit ] 'no entry to submit to' assertDies

    store true 'boolean changed' entry:submit
    [ store false '' entry:submit ] 'no entry to submit to' assertDies

    store [ 1 2 3 ] 'block changed' entry:submit
    [ store [ 4 5 6 ] '' entry:submit ] 'no entry to submit to' assertDies

    store -> 0 'number changed' assert=
    store -> 'hello world' 'quote changed' assert=
    store -> #quotedWord 'quoted word changed' assert=
    store true entry:fetch 'boolean changed' assert=
    store [ 1 2 3 ] entry:fetch 'block changed' assert=

    stack count 0 assert=
  ]

  it should 'work as in the example from docs' [
    [ 'John Doe' $: fullName
      [ fullName count ] @: fullNameLength
    ] obj $: person

    person.fullName 'John Doe' assert=
    person.fullNameLength 8 assert=

    person #fullName 'Alice Bobette' entry:submit

    person.fullName 'Alice Bobette' assert=
    person.fullNameLength 13 assert=

    person #fullNameLength [ person.fullName 'tt' occurrences count ] entry:submit
    person.fullNameLength 1 assert=

    person #fullName 'Tette Mopettitte' entry:submit
    person.fullName 'Tette Mopettitte' assert=
    person.fullNameLength 3 assert=
  ]
]

"TODO: test: entry:exists? entry:fetch entry:fetch? entry:open entry:flatFetch? entry:opener?"


describe 'entry:delete' [
  in lang

  it should 'delete the entry corresponding to name form' [
    'hello world' $: z

    [ 100 $: x
      200 $: y ] obj $: point

    point.x 100 assert=
    point.y 200 assert=

    point #x entry:delete
    [ point.x ] 'no value form for \'x\'' assertDies
    point.y 200 assert=

    point #y entry:delete
    [ point.x ] 'no value form for \'x\'' assertDies
    [ point.y ] 'no value form for \'y\'' assertDies

    point #z entry:delete

    z 'hello world' assert=

    this #z entry:delete

    [ z ] 'definition for z not found in the enclosing block(s)' assertDies

    stack count 0 assert=
  ]

  it should 'run the example from docs' [
    100 $: x

    [ 200 $: x ] obj $: foo

    "'x' of foo shadows 'x' of toplevel block"
    foo.x 200 assert=

    "Let's try to remove it so it doesn't:"
    foo #x entry:delete
    foo.x 100 assert=

    stack count 0 assert=
  ]
]


describe 'entry:wipeout' [
  in lang

  it should 'remove all owned entries in block' [
    orphan $: a
    orphan $: b

    a -- b drop

    b entry:wipeout
    b entry:names [ ] assert=

    a extend: [ 100 $: x ]
    b entry:wipeout
    a entry:names [ x ] assert=
    b entry:names [ ] assert=

    b extend: [ 200 $: y 300 $: z ]
    b entry:names [ y z ] assert=

    a entry:wipeout
    a entry:names [ ] assert=
    b entry:names [ y z ] assert=

    b entry:wipeout
    b entry:names [ ] assert=

    stack count 0 assert=
  ]
]


describe 'entry:pathTo?' [
  in lang

  it should 'run the example from docs' [
    [ 100 $: x  'a' $: __quote__ ] obj $: a
    [ 200 $: y  'b' $: __quote__ ] obj $: b
    [ 300 $: z  'c' $: __quote__ ] obj $: c

    a -- b -- c drop

    [ a #x entry:pathTo? ] vals sepBy: ' ' '[ a ] 100 true' assert=
    [ b #x entry:pathTo? ] vals sepBy: ' ' '[ b a ] 100 true' assert=
    [ c #x entry:pathTo? ] vals sepBy: ' ' '[ c b a ] 100 true' assert=

    [ b #y entry:pathTo? ] vals sepBy: ' ' '[ b ] 200 true' assert=
    [ c #y entry:pathTo? ] vals sepBy: ' ' '[ c b ] 200 true' assert=

    [ c #z entry:pathTo? ] vals sepBy: ' ' '[ c ] 300 true' assert=

    [ c #foo entry:pathTo? ] vals sepBy: ' ' 'false' assert=
  ]
]


describe 'entry:names' [
  in lang

  it should 'leave owned entry names' [
    [ 100 200 ${ x y } ] obj $: myParent
    [ 300 $: z ] obj $: myChild
    [ 'Hello World' $: greeting ] obj $: myFriend

    myParent -- myChild drop
    myParent Â·> myFriend drop
    myChild Â·> myFriend drop

    myParent entry:names [ y x ] assert=
    myChild entry:names [ z ] assert=
    myFriend entry:names [ greeting ] assert=

    this entry:names [ myParent myChild myFriend ] assert=
  ]
]


describe 'entry:names*' [
  in lang

  it should 'leave reachable entry names' [
    [ 100 200 ${ x y } ] obj toOrphan $: myParent
    [ 300 $: z ] obj toOrphan $: myChild
    [ 'Hello World' $: greeting ] obj toOrphan $: myFriend

    myParent -- myChild drop
    myParent Â·> myFriend drop
    myChild Â·> myFriend drop

    myParent entry:names* [ y x greeting ] assert=
    myChild entry:names* [ z y x greeting ] assert=
    myFriend entry:names* [ greeting ] assert=
  ]
]


describe 'entry:values' [
  in lang

  it should 'leave owned entry values' [
    [ 100 200 ${ x y } ] obj $: myParent
    [ 300 $: z ] obj $: myChild
    [ 'Hello World' $: greeting ] obj $: myFriend

    myParent -- myChild drop
    myParent Â·> myFriend drop
    myChild Â·> myFriend drop

    myParent entry:values [ 200 100 ] assert=
    myChild entry:values [ 300 ] assert=
    myFriend entry:values [ 'Hello World' ] assert=

    this entry:values [ myParent myChild myFriend ] vals assert=
    stack count 0 assert=
  ]
]


describe 'entry:values*' [
  in lang

  it should 'leave reachable entry values' [
    [ 100 200 ${ x y } ] obj toOrphan $: myParent
    [ 300 $: z ] obj toOrphan $: myChild
    [ 'Hello World' $: greeting ] obj toOrphan $: myFriend
    [ 'Bye World' $: greeting ] obj toOrphan $: myFriend2

    myParent -- myChild drop
    myParent Â·> myFriend drop
    myChild Â·> myFriend drop
    myChild Â·> myFriend2 drop

    myParent entry:names* [ y x greeting ] assert=
    myParent entry:values* [ 200 100 'Hello World' ] assert=

    myChild entry:names* [ z y x greeting ] assert=
    myChild entry:values* [ 300 200 100 'Bye World' 'Hello World' ] assert=

    myFriend entry:names* [ greeting ] assert=
    myFriend entry:values* [ 'Hello World' ] assert=

    myFriend2 entry:names* [ greeting ] assert=
    myFriend2 entry:values* [ 'Bye World' ] assert=
  ]
]


describe 'entry:count' [
  in lang

  it should 'leave the amount of owned entries' [
    [ ] $: b
    b entry:count 0 assert=
    b extend: [ 100 200 300 ${ x y z } ]
    b entry:count 3 assert=
    b #x entry:delete
    b entry:count 2 assert=
    b #y entry:delete
    b entry:count 1 assert=
    b #z entry:delete
    b entry:count 0 assert=
  ]
]


describe 'shallowCopy' [
  in lang

  it should 'create a shallow copy' [
    [ 1 2 3 ] $: a
    a #x 0 pushes
    a shallowCopy $: b
    b #y 1 pushes
    b 1 shove

    a toTape [ 1 2 3 ] assert=
    a entry:names [ x ] assert=

    b toTape [ 1 2 3 1 ] assert=
    b entry:names [ x y ] assert=
  ]
]


describe 'resub' [
  in lang

  it should 'replace substrate of block with other block\'s' [
    [ 1 2 3 ] $: a
    [ 'a' 'b' 'c' ] $: b
    b #x 0 pushes

    b toTape [ 'a' 'b' 'c' ] assert=
    b |at 3 assert=
    b entry:names [ x ] assert=

    b 2 |-
    a b resub
    b toTape [ 1 | 2 3 ] assert=
    b entry:names [ x ] assert=
  ]
]


describe 'round' [
  in lang

  it should 'round good cases' [
    1 round 1 assert=
    1.23 round 1 assert=
    1.67 round 2 assert=
  ]

  it should 'do banker\'s rounding' [
    1.5 round 2 assert=
    2.5 round 2 assert=
    5.5 round 6 assert=
    6.5 round 6 assert=
  ]
]


describe 'floor' [
  in lang

  it should 'round decimals down' [
    1 floor 1 assert=
    1.23 floor 1 assert=
    1.67 floor 1 assert=
    2.5 floor 2 assert=
  ]

  it should 'round negative decimals down' [
    -1 floor -1 assert=
    -1.23 floor -2 assert=
    -1.67 floor -2 assert=
    -2.5 floor -3 assert=
  ]
]


describe 'ceil' [
  in lang

  it should 'round decimals up' [
    1 ceil 1 assert=
    1.23 ceil 2 assert=
    1.67 ceil 2 assert=
    2.5 ceil 3 assert=
  ]

  it should 'round negative decimals up' [
    -1 ceil -1 assert=
    -1.23 ceil -1 assert=
    -1.67 ceil -1 assert=
    -2.5 ceil -2 assert=
  ]
]


describe 'trunc' [
  in lang

  it should 'truncate decimals' [
    1 trunc 1 assert=
    1.23 trunc 1 assert=
    1.67 trunc 1 assert=
    2.5 trunc 2 assert=
  ]

  it should 'truncate negative decimals' [
    -1 trunc -1 assert=
    -1.23 trunc -1 assert=
    -1.67 trunc -1 assert=
    -2.5 trunc -2 assert=
  ]
]


describe 'sin' [
  in lang

  "Copied from https://github.com/Raku/roast/blob/ed50f3c48d84972a0603a87ab4b698c642db6cb4/S32-trig/sin.t#L12"

  it should 'compute sine in radians' [
    -360 deg->rad sin 0 assertApprox=
    135 360 - deg->rad sin 1 2 / 2 sqrt * assertApprox=
    330 360 - deg->rad sin -0.5 assertApprox=
    0 deg->rad sin 0 assertApprox=
    30 deg->rad sin 0.5 assertApprox=
    45 deg->rad sin 1 2 / 2 sqrt * assertApprox=
    90 deg->rad sin 1 assertApprox=
    135 deg->rad sin  1 2 / 2 sqrt * assertApprox=
    180 deg->rad sin 0 assertApprox=
    225 deg->rad sin 1 2 / 2 sqrt * flipSign assertApprox=
    270 deg->rad sin -1 assertApprox=
    315 deg->rad sin 1 2 / 2 sqrt * flipSign assertApprox=
    360 deg->rad sin 0 assertApprox=
    30 360 + deg->rad sin 0.5 assertApprox=
    225 360 + deg->rad sin 1 2 / 2 sqrt * flipSign assertApprox=
    720 deg->rad sin 0 assertApprox=
  ]
]


describe 'cos' [
  in lang

  "Copied from: https://github.com/Raku/roast/blob/ed50f3c48d84972a0603a87ab4b698c642db6cb4/S32-trig/cos.t#L31"

  it should 'compute cosine in radians' [
    -360 deg->rad 90 deg->rad - cos 0 assertApprox=
    135 360 - deg->rad 90 deg->rad - cos  1 2 / 2 sqrt * assertApprox=
    330 360 - deg->rad 90 deg->rad - cos -0.5 assertApprox=
    0 deg->rad 90 deg->rad - cos 0 assertApprox=
    30 deg->rad 90 deg->rad - cos 0.5 assertApprox=
    45 deg->rad 90 deg->rad - cos  1 2 / 2 sqrt * assertApprox=
    90 deg->rad 90 deg->rad - cos 1 assertApprox=
    135 deg->rad 90 deg->rad - cos  1 2 / 2 sqrt * assertApprox=
    180 deg->rad 90 deg->rad - cos 0 assertApprox=
    225 deg->rad 90 deg->rad - cos 1 2 / 2 sqrt * flipSign assertApprox=
    270 deg->rad 90 deg->rad - cos -1 assertApprox=
    315 deg->rad 90 deg->rad - cos 1 2 / 2 sqrt * flipSign assertApprox=
    360 deg->rad 90 deg->rad - cos 0 assertApprox=
    30 360 + deg->rad 90 deg->rad - cos 0.5 assertApprox=
    225 360 + deg->rad 90 deg->rad - cos 1 2 / 2 sqrt * flipSign assertApprox=
    720 deg->rad 90 deg->rad - cos 0 assertApprox=
  ]
]


describe 'desc' [
  in lang

  it should 'leave correct descriptions for value forms' [
    true desc 'boolean true' assert=
    false desc 'boolean false' assert=
    100 desc 'decimal number 100' assert=
    100.5 desc 'decimal number 100.5' assert=
    'hello world' desc 'quote \'hello world\'' assert=
    #foo desc 'word named \'foo\'' assert=
    ##foo desc 'quoted word \'foo\'' assert=
    ###foo desc 'quoted word \'#foo\'' assert=
  ]

  it should 'leave correct descriptions for blocks' [
    [ ] desc 'a block' assert=
    [ "hello world" ] desc 'hello world' assert=
    [ "" "" "" "hello world" ] desc 'hello world' assert=
    [ "" "" 1 "hello world" 3 ] desc 'a block' assert=
    [ "foo" [ "boo" ] "baa" ] desc 'foo' assert=
  ]

  it should 'leave correct descriptions for builtin' [
    #+ here desc '( A B -- S ): leaves the Sum of two decimals.' assert=
  ]
]

describe 'typedesc' [
  in lang

  it should 'leave correct descriptions for value forms' [
    true typedesc 'boolean' assert=
    false typedesc 'boolean' assert=
    #+ here typedesc 'builtin' assert=
    123 typedesc 'decimal' assert=
    123.456 typedesc 'decimal' assert=
    'hello world' typedesc 'quote' assert=
    #foo typedesc 'word' assert=
    ##foo typedesc 'quoted word' assert=
  ]

  it should 'leave correct descriptions for blocks' [
    [ ] typedesc 'block' assert=
    [ 1 2 3 ] typedesc 'block' assert=
    [ "foobar" ] typedesc 'block' assert=
  ]
]

describe 'block?' [
  in lang

  it should 'leave true for block' [ [] block? true assert= ]
  it should 'leave false for others' [
    'foo' block? false assert=
    123 block? false assert=
    "..."
  ]
]

describe 'word?' [
  in lang

  it should 'leave true for word' [ #foo word? true assert= ]
  it should 'leave true for block implementing __word__' [
    [ #foo  $: __word__ this ] @: x
    [ [ x ] @: __word__ this ] @: y
    x word? true assert=
    y word? true assert=
  ]

  it should 'leave false for others' [
    'foo' word? false assert=
    123 word? false assert=
    [ ] word? false assert=
    "..."
  ]
]


describe 'private?' [
  in lang

  it should 'leave whether a word is private' [
    #_ private? false assert=
    #hello private? false assert=
    #_hello private? true assert=
  ]
]


describe 'quotedWord?' [
  in lang

  it should 'leave true for quoted word' [ ##foo quotedWord? true assert= ]
  it should 'leave true for block implementing __quotedWord__' [
    [ ##foo $: __quotedWord__ this ] @: x
    [ [ x ] @: __quotedWord__ this ] @: y
    x quotedWord? true assert=
    y quotedWord? true assert=
  ]

  it should 'leave false for others' [
    'foo' quotedWord? false assert=
    123 quotedWord? false assert=
    [ ] quotedWord? false assert=
    #foo quotedWord? false assert=
    "..."
  ]
]

describe 'decimal?' [
  in lang

  it should 'leave true for decimal' [ 100 decimal? true assert= ]
  it should 'leave true for block implementing __decimal__' [
    [ 100   $: __decimal__ this ] @: x
    [ [ x ] @: __decimal__ this ] @: y
    x decimal? true assert=
    y decimal? true assert=
  ]

  it should 'leave false for other types' [
    [ ] decimal? false assert=
    true decimal? false assert=
    #foobar decimal? false assert=
    '1234' decimal? false assert=
    "..."
  ]
]

describe 'quote?' [
  in lang

  it should 'leave true for quote' [ 'foo' quote? true assert= ]
  it should 'leave true for block implementing __quote__' [
    [ 'foo' $: __quote__ this ] @: x
    [ [ x ] @: __quote__ this ] @: y
    x quote? true assert=
    y quote? true assert=
  ]

  it should 'leave false for other types' [
    [ ] quote? false assert=
    true quote? false assert=
    #foobar quote? false assert=
    1234 quote? false assert=
    " ... etc ... "
  ]
]

describe 'boolean?' [
  in lang

  it should 'leave true for boolean' [ true boolean? true assert= ]
  it should 'leave true for block implementing __boolean__' [
    [ true  $: __boolean__ this ] @: x
    [ [ x ] @: __boolean__ this ] @: y
    x boolean? true assert=
    y boolean? true assert=
  ]

  it should 'leave false for other types' [
    [ ] boolean? false assert=
    #true boolean? false assert=
    #foobar boolean? false assert=
    '1234' boolean? false assert=
    " ... etc ... "
  ]
]

describe 'color?' [
  in lang

  it should 'leave true for color' [ 0 0 0 rgb color? true assert= ]
  it should 'leave true for block implementing __color__' [
    [ 0 0 0 rgb $: __color__ this ] @: x
    [ [ x ] @: __color__ this ] @: y
    x color? true assert=
    y color? true assert=
  ]

  it should 'leave false for other types' [
    [ ] color? false assert=
    #true color? false assert=
    #foobar color? false assert=
    '1234' color? false assert=
    " ... etc ... "
  ]
]


describe 'byteslice?' [
  in lang

  it should 'leave true for byteslice' [ 'hello world' toByteslice byteslice? true assert= ]
  it should 'leave true for block implementing __byteslice__' [
    [ 'hello' toByteslice $: __byteslice__ this ] @: x
    [ [ x ] @: __byteslice__ this ] @: y
    x byteslice? true assert=
    y byteslice? true assert=
  ]

  it should 'leave false for other types' [
    [ ] byteslice? false assert=
    #true byteslice? false assert=
    #foobar byteslice? false assert=
    '1234' byteslice? false assert=
    " ... etc ... "
  ]
]


describe 'asDecimal' [
  in lang

  it dies 'when given quote' [ 'foo' asDecimal ]
  it dies 'when given word' [ #foo asDecimal ]
  it dies 'when given quoted word' [ ##foo asDecimal ]
  it dies 'when given boolean' [ true asDecimal ]
  it dies 'when given block' [ [] asDecimal ]
  it should 'leave decimal when given decimal' [
    100 dup asDecimal assert=
  ]

  [ $: x x $: __decimal__ this ] @: a

  it dies 'when given quote in __decimal__' [ 'foo' a asDecimal ]
  it dies 'when given word in __decimal__' [ #foo a asDecimal ]
  it dies 'when given quoted word in __decimal__' [ ##foo a asDecimal ]
  it dies 'when given boolean in __decimal__' [ true a asDecimal ]
  it dies 'when given block in __decimal__' [ [] a asDecimal ]
  it should 'leave instance when given decimal in __decimal__' [
    100 a dup asDecimal same? true assert=
  ]
]

describe 'asQuote' [
  in lang

  it dies 'when given decimal' [ 100 asQuote ]
  it dies 'when given word' [ #foo asQuote ]
  it dies 'when given quoted word' [ ##foo asQuote ]
  it dies 'when given boolean' [ true asQuote ]
  it dies 'when given block' [ [] asQuote ]
  it should 'leave quote when given quote' [
    'foo' dup asQuote assert=
  ]

  [ $: x x $: __quote__ this ] @: a

  it dies 'when given decimal in __quote__' [ 100 a asQuote ]
  it dies 'when given word in __quote__' [ #foo a asQuote ]
  it dies 'when given quoted word in __quote__' [ ##foo a asQuote ]
  it dies 'when given boolean in __quote__' [ true a asQuote ]
  it dies 'when given block in __quote__' [ [] a asQuote ]
  it should 'leave instance when given quote in __quote__' [
    'foo' a dup asQuote same? true assert=
  ]
]

describe 'asWord' [
  in lang

  it dies 'when given decimal' [ 100 asWord ]
  it dies 'when given quote' [ 'foo' asWord ]
  it dies 'when given quoted word' [ ##foo asWord ]
  it dies 'when given boolean' [ true asWord ]
  it dies 'when given block' [ [] asWord ]
  it should 'leave word when given word' [
    #foo dup asWord assert=
  ]

  [ $: x x $: __word__ this ] @: a

  it dies 'when given decimal in __word__' [ 100 a asWord ]
  it dies 'when given quote in __word__' [ 'foo' a asWord ]
  it dies 'when given quoted word in __word__' [ ##foo a asWord ]
  it dies 'when given boolean in __word__' [ true a asWord ]
  it dies 'when given block in __word__' [ [] a asWord ]
  it should 'leave instance when given word in __word__' [
    #foo a dup asWord same? true assert=
  ]
]

describe 'asQuotedWord' [
  in lang

  it dies 'when given decimal' [ 100 asQuotedWord ]
  it dies 'when given quote' [ 'foo' asQuotedWord ]
  it dies 'when given word' [ #foo asQuotedWord ]
  it dies 'when given boolean' [ true asQuotedWord ]
  it dies 'when given block' [ [] asQuotedWord ]
  it should 'leave quoted word when given quoted word' [
    ##foo dup asQuotedWord assert=
  ]

  [ $: x x $: __quotedWord__ this ] @: a

  it dies 'when given decimal in __quotedWord__' [ 100 a asQuotedWord ]
  it dies 'when given quote in __quotedWord__' [ 'foo' a asQuotedWord ]
  it dies 'when given word in __quotedWord__' [ #foo a asQuotedWord ]
  it dies 'when given boolean in __quotedWord__' [ true a asQuotedWord ]
  it dies 'when given block in __quotedWord__' [ [] a asQuotedWord ]
  it should 'leave instance when given quoted word in __quotedWord__' [
    ##foo a dup asQuotedWord same? true assert=
  ]
]


describe 'toQuotedWord' [
  in lang

  it should 'leave quoted word of word' [
    #foo typedesc 'word' assert=
    ##foo typedesc 'quoted word' assert=
    #foo toQuotedWord ##foo assert=
  ]

  it should 'further quote a quoted word' [
    ##foo toQuotedWord ###foo assert=
    ###foo toQuotedWord ####foo assert=
  ]
]


describe 'asBoolean' [
  in lang

  it dies 'when given decimal' [ 100 asBoolean ]
  it dies 'when given quote' [ 'foo' asBoolean ]
  it dies 'when given word' [ #foo asBoolean ]
  it dies 'when given quoted word' [ ##foo asBoolean ]
  it dies 'when given block' [ [] asBoolean ]
  it should 'leave boolean when given boolean' [
    true dup asBoolean assert=
  ]

  [ $: x x $: __boolean__ this ] @: a

  it dies 'when given decimal in __boolean__' [ 100 a asBoolean ]
  it dies 'when given quote in __boolean__' [ 'foo' a asBoolean ]
  it dies 'when given word in __boolean__' [ #foo a asBoolean ]
  it dies 'when given quoted word in __boolean__' [ ##foo a asBoolean ]
  it dies 'when given block in __boolean__' [ [] a asBoolean ]
  it should 'leave instance when given boolean in __boolean__' [
    true a dup asBoolean same? true assert=
  ]
]


describe 'asByteslice' [
  in lang

  it should 'accept byteslice only' [
    [ 100 asByteslice ] 'bad type: decimal, expected: a byteslice' assertDies
    [ 'foo' asByteslice ] 'bad type: quote, expected: a byteslice' assertDies
    [ #foo asByteslice ] 'bad type: word, expected: a byteslice' assertDies
    [ ##foo asByteslice ] 'bad type: quoted word, expected: a byteslice' assertDies
    [ [] asByteslice ] 'bad type: block, expected: a byteslice' assertDies
    [ true asByteslice] 'bad type: boolean, expected: a byteslice' assertDies
    'hello world' toByteslice dup asByteslice assert=
  ]


  it should 'it should accept block with __byteslice__' [
    [ $: x x $: __byteslice__ this ] @: a

    [ 100 a asByteslice ] 'bad type: decimal, expected: a byteslice' assertDies
    [ 'foo' a asByteslice ] 'bad type: quote, expected: a byteslice' assertDies
    [ #foo a asByteslice ] 'bad type: word, expected: a byteslice' assertDies
    [ ##foo a asByteslice ] 'bad type: quoted word, expected: a byteslice' assertDies
    [ [] a asByteslice ] 'bad type: block, expected: a byteslice' assertDies
    [ true a asByteslice ] 'bad type: boolean, expected: a byteslice' assertDies
    'hello world' toByteslice a dup asByteslice same? true assert=
  ]
]


describe 'asBlock' [
  in lang

  it dies 'when given decimal' [ 100 asBlock ]
  it dies 'when given quote' [ 'foo' asBlock ]
  it dies 'when given word' [ #foo asBlock ]
  it dies 'when given quoted word' [ ##foo asBlock ]
  it dies 'when given boolean' [ true asBlock ]
  it should 'leave same block when given block' [
    [] dup asBlock same? true assert=
  ]
]

describe 'toQuote' [
  in lang

  it should 'enquote boolean true' [ true toQuote 'true' assert= ]
  it should 'enquote boolean false' [ false toQuote 'false' assert= ]
  it should 'enquote builtin' [ #+ here toQuote '[native code for: \'+\']' assert= ]
  it should 'enquote decimal' [ 100 toQuote '100' assert= ]
  it should 'enquote -decimal' [ -100 toQuote '-100' assert= ]
  it should 'enquote +decimal' [ +100 toQuote '100' assert= ]
  it should 'enquote quote' [ 'hello world' toQuote 'hello world' assert= ]
  it should 'enquote word' [ #hello toQuote 'hello' assert= ]
  it should 'enquote quoted word' [ ##hello toQuote '#hello' assert= ]
]

describe 'toQuote block' [
  in lang

  it should 'enquote empty block' [
    orphan toQuote '[ ]' assert=
    [ ] toQuote '[ ]' assert=
  ]

  it should 'enquote small block' [
    [ 1 2 3 ] toQuote '[ 1 2 3 ]' assert=
    [ | 1 2 3 ] toQuote '[ | 1 2 3 ]' assert=
    [ 1 | 2 3 ] toQuote '[ 1 | 2 3 ]' assert=
    [ 'hello world' 1 2 3 ] toQuote '[ \'hello world\' 1 2 3 ]' assert=
  ]

  it should 'enquote nested blocks' [
    [ [ 1 2 3 ] [ x y z ] ] toQuote '[ [ 1 2 3 ] [ x y z ] ]' assert=
    [ [ 1 2 3 ] [ x [] z ] ] toQuote '[ [ 1 2 3 ] [ x [ ] z ] ]' assert=
  ]

  it should 'enquote dict blocks' [
    orphan $: dict
    dict #x 100 pushes
    dict #y 200 pushes
    dict #z [ 1 2 3 ] pushes
    dict #inc [ "( N -- N' ): does fancy stuff. Does ( a lot - of - Fancy stuff): see?" 1 + ] opens
    dict #foo #+ here pushes
    dict toQuote '[ Â· ${x :: 100} ${y :: 200} ${z :: a block} @{inc :: ( N -- N\' )} ${foo :: ( A B -- S )} ]' assert=
  ]

  it should 'enquote list+dict blocks' [
    [ 100 $: x 200 $: y ] obj $: foo
    foo toQuote '[ 100 $: x 200 $: y Â· x -> 100, y -> 200 ]'
  ]

  it should 'enquote reflections' [
    [ ] $: a
    a a shove
    a toQuote '[ â­® ]' assert=

    [ 1 2 3 ] $: b
    b b shove
    b toQuote '[ 1 2 3 â­® ]' assert=

    [ 1 | 2 3 ] $: c
    c c shove
    c toQuote '[ 1 â­® | 2 3 ]' assert=
  ]

  it should 'respect quote reprs' [
    [ 'fooBar' $: __quote__ ] obj $: x
    x toQuote 'fooBar' assert=
    x enclose toQuote '[ fooBar ]' assert=
  ]

  it should 'enquote reflection keys' [
    orphan $: x
    x x 100 pushes
    x x 200 pushes
    x toQuote '[ Â· ${â­® :: 200} ]' assert=
    orphan $: y
    y x y pushes
    x y x pushes
    x toQuote '[ Â· ${â­® :: 200} ${[ Â· ${â­® :: a block} ] :: a block} ]' assert=
    y toQuote '[ Â· ${[ Â· ${â­® :: 200} ${â­® :: a block} ] :: a block} ]' assert=
  ]

  "todo more tests"
]

describe 'effect' [
  in lang

  it should 'work for forms other than block & builtin' [
    100 effect '100' assert=
    true effect 'true' assert=
    'hello \n world' effect '\'hello \\n world\'' assert=
  ]

  it should 'shorten quotes longer than 32 characters' [
    'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Vestibulum lorem sed risus ultricies tristique nulla aliquet enim. Nunc vel risus commodo viverra maecenas accumsan lacus vel.'
      effect '\'Lorem ipsum dâ€¦an lacus vel.\'' assert=
  ]

  it should 'work for builtins' [
    #+ here effect '( A B -- S )' assert=
  ]

  it should 'work for blocks' [
    [] effect 'a block' assert=
    [ "Hello World" ] effect 'a block' assert=
    [ "( -- )"] effect 'a block' assert=
    [ "( -- ) fooBoo"] effect 'a block' assert=
    [ "( -- ): hello world"] effect '( -- )' assert=
    #map: here effect '( Lb map: B -- MLb )' assert=
  ]
]

describe 'builtin?' [
  in lang

  it should 'leave true for builtin' [
    #+ here builtin? true assert=
  ]

  it should 'leave false for everything else' [
    [ ] builtin? false assert=
    123 builtin? false assert=
    "..."
  ]
]

describe 'asBuiltin' [
  in lang

  it should 'leave builtins as is' [
    #+ here asBuiltin #+ here assert=
  ]

  it should 'die when not a builtin' [
    [ 123 asBuiltin ] 'bad type: decimal, expected: a builtin' assertDies
    [ '123' asBuiltin ] 'bad type: quote, expected: a builtin' assertDies
    [ [ ] asBuiltin ] 'bad type: block, expected: a builtin' assertDies
  ]
]

describe 'color?' [
  in lang

  it should 'leave true for colors' [
    0 0 0 rgb color? true assert=
  ]

  it should 'leave false for other forms' [
    123 color? false assert=
    '123' color? false assert=
    [ ] color? false assert= "...etc.."
  ]

  it should 'leave false for block implementing __color__' [
    [   0 0 0 rgb  $: __color__ this ] $: x
    [ [ 0 0 0 rgb] @: __color__ this ] $: y
    x color? false assert=
    y color? false assert=
  ]

  [ $: x x $: __color__ this ] @: a

  it should 'leave instance when given color in __color__' [
    0 0 0 rgb a dup asColor same? true assert=
  ]

  it should 'die when not given color in __color__' [
    [ 'foo' a asColor ] 'bad type: quote, expected: a color' assertDies
  ]
]

describe 'asColor' [
  in lang

  it should 'leave colors as is' [
    0 0 0 rgb asColor 0 0 0 rgb assert=
  ]

  it should 'die when not a color' [
    [ 123 asColor ] 'bad type: decimal, expected: a color' assertDies
    [ '123' asColor ] 'bad type: quote, expected: a color' assertDies
    [ [ ] asColor ] 'bad type: block, expected: a color' assertDies
  ]
]

describe 'stitch' [
  in lang

  it should 'stitch two empty quotes' [
    '' '' stitch '' assert=
  ]

  it should 'stitch char + empty quotes' [
    'f' '' stitch 'f' assert=
  ]

  it should 'stitch char/multichar + empty quotes' [
    '' 'f' stitch 'f' assert=
    'f' '' stitch 'f' assert=
    'hello' '' stitch 'hello' assert=
    '' 'hello' stitch 'hello' assert=
  ]

  it should 'stitch single character quotes' [
    'x' 'y' stitch 'xy' assert=
    'Ã¤' 'ğŸ¤–' stitch 'Ã¤ğŸ¤–' assert=
    'ğŸ‘½' 'ğŸ˜¡' stitch 'ğŸ‘½ğŸ˜¡' assert=
  ]

  it should 'stitch single-char + multi-char quote' [
    'x' 'yzzy' stitch 'xyzzy' assert=
    'xyzz' 'y' stitch 'xyzzy' assert=
    'ğŸ˜¡' 'ğŸ˜ˆã‚ã‚axğŸ’©ğŸ¤¡' stitch 'ğŸ˜¡ğŸ˜ˆã‚ã‚axğŸ’©ğŸ¤¡' assert=
    'ğŸ˜¡ğŸ˜ˆã‚ã‚axğŸ’©' 'ğŸ¤¡' stitch 'ğŸ˜¡ğŸ˜ˆã‚ã‚axğŸ’©ğŸ¤¡' assert=
  ]

  it should 'stitch multi-char + multi-char quote' [
    'xy' 'zzy' stitch 'xyzzy' assert=
    'ğŸ˜ˆã‚ã‚axğŸ’©' 'ğŸ‘½ğŸ˜¡fubar' stitch 'ğŸ˜ˆã‚ã‚axğŸ’©ğŸ‘½ğŸ˜¡fubar' assert=
  ]
]

describe 'count' [
  in lang

  it should 'leave 0 for empty block' [
    [ ] count 0 assert=
  ]

  it should 'leave 0 for empty quote' [
    '' count 0 assert=
  ]

  it should 'count the amount of elements in blocks' [
    [ 1 2 3 4 ] count 4 assert=
  ]

  it should 'count one grapheme' [
    'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§' count 1 assert=
  ]

  it should 'count one character' [
    'f' count 1 assert=
  ]

  it should 'count one unicode character' [
    'Ã¥' count 1 assert=
  ]

  it should 'count Unicode extended grapheme clusters correctly' [
    'ğŸğŸ‘¨â€ğŸ‘©â€ğŸ‘§' count 2 assert= "apple followed by family"
    'ğŸ˜¡ğŸ˜ˆã‚ã‚axğŸ’©ğŸ¤¡' count 8 assert=
  ]

  it should 'count the amount of characters (graphemes) in quotes' [
    'â’¶sÂ°Ã„manÑ‡ĞµĞ»Ğ¾Ğ²ĞµĞº' count 14 assert=
  ]

  it should 'die when invalid type' [
    [ 123 count ] 'bad type: decimal, expected: a block, byteslice, or quote' assertDies
  ]
]

describe 'chr' [
  in lang

  it should 'leave quote corresponding to codepoint' [
    65 chr 'A' assert=
    'ğŸ‘¨â€ğŸ‘§â€ğŸ‘¦' ord chr 'ğŸ‘¨' assert= "only the first codepoint"
  ]

  it should 'die when codepoint is invalid' [
    [ -1000 chr ] 'decimal is not a positive integer' assertDies
    [ 0.123 chr ] 'decimal is not a positive integer' assertDies
    [ 1234567 chr ] 'decimal out of range: expected any of: [0; 55295], [57344; 1114111]' assertDies
  ]
]

describe 'ord' [
  in lang

  it should 'leave codepoint corresponding to first grapheme in quote' [
    'A' ord 65 assert=
    'ğŸ‘¨â€ğŸ‘§â€ğŸ‘¦' ord 128104 assert=
    'Ã„' ord chr 'Ã„' assert=
  ]

  it should 'die when quote is invalid' [
    [ '' ord ] 'ord: quote must contain at least one character' assertDies
  ]
]

describe 'lpad' [
  in lang

  it should 'pad left when content is a grapheme, padder is a grapheme' [
    'x' 0 'y' lpad 'x' assert=
    'x' 1 'y' lpad 'x' assert=
    'x' 2 'y' lpad 'yx' assert=
    'x' 5 'y' lpad 'yyyyx' assert=

    stack count 0 assert=
  ]

  it should 'pad left when content is a grapheme, padder is a quote' [
    'x' 0 '' lpad 'x' assert=
    'x' 0 'foo' lpad 'x' assert=
    'x' 1 'foo' lpad 'x' assert=
    'x' 2 'foo' lpad 'fx' assert=
    'y' 5 'ba' lpad 'baaay' assert=
    'a' 5 'foozy' lpad 'fooza' assert=
    'a' 6 'foozy' lpad 'foozya' assert=
    'ğŸ‘¨â€ğŸ‘§â€ğŸ‘¦' 5 'foxtrot' lpad 'foxtğŸ‘¨â€ğŸ‘§â€ğŸ‘¦' assert=

    stack count 0 assert=
  ]

  it should 'pad left when content is a quote, padder is a grapheme' [
    '' 5 'x' lpad 'xxxxx' assert=
    'foo' 2 'a' lpad 'foo' assert=
    'foo' 5 'a' lpad 'aafoo' assert=
    'foo' 10 'a' lpad 'aaaaaaafoo' assert=

    stack count 0 assert=
  ]

  it should 'pad left when content is a quote, padder is a quote' [
    '' 5 '' lpad '' assert=
    'foo' 2 '' lpad 'foo' assert=
    'foo' 3 '' lpad 'foo' assert=
    'foo' 5 '' lpad 'foo' assert=
    '' 0 'x' lpad '' assert=
    '' 5 'x' lpad 'xxxxx' assert=
    'foobar' 2 'xyz' lpad 'foobar' assert=
    'foobar' 6 'xyz' lpad 'foobar' assert=
    'foobar' 7 'xyz' lpad 'xfoobar' assert=
    'foobar' 10 'xyz' lpad 'xyzzfoobar' assert=
    'foobar' 10 'abcdefghjk' lpad 'abcdfoobar' assert=
    'foobar' 10 'abcdefghjklmno' lpad 'abcdfoobar' assert=

    stack count 0 assert=
  ]

  it should 'pad quote left in general' [
    '' 0 '' lpad '' assert=
    '' 0 ' ' lpad '' assert=
    '' 10 ' ' lpad '          ' assert=
    'x' 10 'y' lpad 'yyyyyyyyyx' assert=
    'x' 10 ' =*' lpad ' =*******x' assert=
    'helloworld' 0 ' ' lpad 'helloworld' assert=
    'hello' 10 ' -' lpad ' ----hello' assert=
    'foobar' 10 ' ' lpad '    foobar' assert=
    'ğŸğŸ‘¨â€ğŸ‘©â€ğŸ‘§ğŸ˜¡ğŸ˜ˆã‚ã‚a' 10 'ğŸ’©' lpad 'ğŸ’©ğŸ’©ğŸ’©ğŸğŸ‘¨â€ğŸ‘©â€ğŸ‘§ğŸ˜¡ğŸ˜ˆã‚ã‚a' assert=
    'heğŸ‘¨â€ğŸ‘§â€ğŸ‘¦llo' 7 'ğŸ‘¨â€ğŸ‘§â€ğŸ‘¦' lpad 'ğŸ‘¨â€ğŸ‘§â€ğŸ‘¦heğŸ‘¨â€ğŸ‘§â€ğŸ‘¦llo' assert=
    'foobrazaur' 10 ' ' lpad 'foobrazaur' assert=
    'foobrazaurs are awesome' 10 ' ' lpad 'foobrazaurs are awesome' assert=
    'hello' 7 'foobar' lpad 'fohello' assert=

    stack count 0 assert=
  ]

  it should 'expect quote, positive integer decimal, quote' [
    [ 1 0 '' lpad ] 'bad type: decimal, expected: a quote' assertDies
    [ '' '' '' lpad ] 'bad type: quote, expected: a decimal' assertDies
    [ '' 0 1 lpad ] 'bad type: decimal, expected: a quote' assertDies
    [ '' -100 '' lpad ] 'decimal is not a positive integer' assertDies
    [ '' -100.3 '' lpad ] 'decimal is not a positive integer' assertDies
    [ '' 100.3 '' lpad ] 'decimal is not a positive integer' assertDies
  ]

  it should 'pad with block that implements __quote__' [
    [ $: __quote__ this ] @: spacer

    ' ' spacer $: ws
    '\t' spacer $: tab

    'hello' 10 ws lpad '     hello' assert=
    'hello' 10 tab lpad '\t\t\t\t\thello' assert=
  ]
]

describe 'rpad' [
  in lang

  it should 'pad right when content is a grapheme, padder is a grapheme' [
    'x' 0 'y' rpad 'x' assert=
    'x' 1 'y' rpad 'x' assert=
    'x' 2 'y' rpad 'xy' assert=
    'x' 5 'y' rpad 'xyyyy' assert=

    stack count 0 assert=
  ]

  it should 'pad right when content is a grapheme, padder is a quote' [
    'x' 0 '' rpad 'x' assert=
    'x' 0 'foo' rpad 'x' assert=
    'x' 1 'foo' rpad 'x' assert=
    'x' 2 'foo' rpad 'xf' assert=
    'a' 5 'ba' rpad 'abaaa' assert=
    'a' 5 'foozy' rpad 'afooz' assert=
    'a' 6 'foozy' rpad 'afoozy' assert=
    'ğŸ‘¨â€ğŸ‘§â€ğŸ‘¦' 5 'foxtrot' rpad 'ğŸ‘¨â€ğŸ‘§â€ğŸ‘¦foxt' assert=

    stack count 0 assert=
  ]

  it should 'pad right when content is a quote, padder is a grapheme' [
    '' 5 'x' rpad 'xxxxx' assert=
    'foo' 2 'a' rpad 'foo' assert=
    'foo' 5 'a' rpad 'fooaa' assert=
    'foo' 10 'a' rpad 'fooaaaaaaa' assert=

    stack count 0 assert=
  ]

  it should 'pad right when content is a quote, padder is a quote' [
    '' 5 '' rpad '' assert=
    'foo' 2 '' rpad 'foo' assert=
    'foo' 3 '' rpad 'foo' assert=
    'foo' 5 '' rpad 'foo' assert=
    '' 0 'x' rpad '' assert=
    '' 5 'x' rpad 'xxxxx' assert=
    'foobar' 2 'xyz' rpad 'foobar' assert=
    'foobar' 6 'xyz' rpad 'foobar' assert=
    'foobar' 7 'xyz' rpad 'foobarx' assert=
    'foobar' 10 'xyz' rpad 'foobarxyzz' assert=
    'foobar' 10 'abcdefghjk' rpad 'foobarabcd' assert=
    'foobar' 10 'abcdefghjklmno' rpad 'foobarabcd' assert=

    stack count 0 assert=
  ]

  it should 'pad quote right in general' [
    '' 0 '' rpad '' assert=
    '' 0 ' ' rpad '' assert=
    '' 10 ' ' rpad '          ' assert=
    'x' 10 'y' rpad 'xyyyyyyyyy' assert=
    'x' 10 ' =*' rpad 'x =*******' assert=
    'helloworld' 0 ' ' rpad 'helloworld' assert=
    'hello' 10 ' -' rpad 'hello ----' assert=
    'foobar' 10 ' ' rpad 'foobar    ' assert=
    'ğŸğŸ‘¨â€ğŸ‘©â€ğŸ‘§ğŸ˜¡ğŸ˜ˆã‚ã‚a' 10 'ğŸ’©' rpad 'ğŸğŸ‘¨â€ğŸ‘©â€ğŸ‘§ğŸ˜¡ğŸ˜ˆã‚ã‚ağŸ’©ğŸ’©ğŸ’©' assert=
    'heğŸ‘¨â€ğŸ‘§â€ğŸ‘¦llo' 7 'ğŸ‘¨â€ğŸ‘§â€ğŸ‘¦' rpad 'heğŸ‘¨â€ğŸ‘§â€ğŸ‘¦lloğŸ‘¨â€ğŸ‘§â€ğŸ‘¦' assert=
    'foobrazaur' 10 ' ' rpad 'foobrazaur' assert=
    'foobrazaurs are awesome' 10 ' ' rpad 'foobrazaurs are awesome' assert=
    'hello' 7 'foobar' rpad 'hellofo' assert=

    stack count 0 assert=
  ]

  it should 'expect quote, positive integer decimal, quote' [
    [ 1 0 '' rpad ] 'bad type: decimal, expected: a quote' assertDies
    [ '' '' '' rpad ] 'bad type: quote, expected: a decimal' assertDies
    [ '' 0 1 rpad ] 'bad type: decimal, expected: a quote' assertDies
    [ '' -100 '' rpad ] 'decimal is not a positive integer' assertDies
    [ '' -100.3 '' rpad ] 'decimal is not a positive integer' assertDies
    [ '' 100.3 '' rpad ] 'decimal is not a positive integer' assertDies
  ]

  it should 'pad with block that implements __quote__' [
    [ $: __quote__ this ] @: spacer

    ' ' spacer $: ws
    '\t' spacer $: tab

    'hello' 10 ws rpad 'hello     ' assert=
    'hello' 10 tab rpad 'hello\t\t\t\t\t' assert=
  ]
]

describe 'fit' [
  in lang

  it should 'expect quote, positive integer decimal, quote' [
    [ 1 0 '' fit ] 'bad type: decimal, expected: a quote' assertDies
    [ '' '' '' fit ] 'bad type: quote, expected: a decimal' assertDies
    [ '' 0 1 fit ] 'bad type: decimal, expected: a quote' assertDies
    [ '' -100 '' fit ] 'decimal is not a positive integer' assertDies
    [ '' -100.3 '' fit ] 'decimal is not a positive integer' assertDies
    [ '' 100.3 '' fit ] 'decimal is not a positive integer' assertDies
  ]

  it should 'fit when content is a grapheme, ellipsis is a grapheme' [
    'x' 0 'y' fit '' assert=
    'x' 1 'y' fit 'x' assert=
    'x' 5 'y' fit 'x' assert=

    stack count 0 assert=
  ]

  it should 'fit when content is a grapheme, ellipsis is a quote' [
    'x' 0 '' fit '' assert=
    'x' 0 'foo' fit '' assert=
    'x' 1 'foo' fit 'x' assert=
    'x' 2 'foo' fit 'x' assert=
    'a' 5 'ba' fit 'a' assert=
    'a' 5 'foozy' fit 'a' assert=
    'ğŸ‘¨â€ğŸ‘§â€ğŸ‘¦' 5 'foxtrot' fit 'ğŸ‘¨â€ğŸ‘§â€ğŸ‘¦' assert=

    stack count 0 assert=
  ]

  it should 'fit when content is a quote, ellipsis is a grapheme' [
    '' 5 'x' fit '' assert=
    'foo' 2 'a' fit 'fa' assert=
    'foo' 5 'a' fit 'foo' assert=
    'foo' 10 'a' fit 'foo' assert=
    'hello world' 10 'â€¦' fit 'hello worâ€¦' assert=
    'hello world' 10 'ğŸ‘¨â€ğŸ‘§â€ğŸ‘¦' fit 'hello worğŸ‘¨â€ğŸ‘§â€ğŸ‘¦' assert=

    stack count 0 assert=
  ]

  it should 'fit when content is a quote, ellipsis is a quote' [
    '' 5 '' fit '' assert=
    'foo' 2 '' fit 'fo' assert=
    'foo' 3 '' fit 'foo' assert=
    'foo' 5 '' fit 'foo' assert=
    '' 0 'x' fit '' assert=
    '' 5 'x' fit '' assert=
    'foobar' 2 'xyz' fit 'xy' assert=
    'foobar' 3 'xyz' fit 'xyz' assert=
    'foobar' 4 'xyz' fit 'fxyz' assert=
    'foobar' 5 'xyz' fit 'foxyz' assert=
    'foobar' 6 'xyz' fit 'foobar' assert=
    'foobar' 7 'xyz' fit 'foobar' assert=
    'foobar' 10 'xyz' fit 'foobar' assert=
    'foobar' 5 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ğŸ' fit 'fooğŸ‘¨â€ğŸ‘©â€ğŸ‘§ğŸ' assert=
    'Lorem ipsum dolor sit amet' 24 'â€¦ (hidden)' fit 'Lorem ipsum doâ€¦ (hidden)' assert=

    stack count 0 assert=
  ]

  it should 'fit with block that implements __quote__' [
    [ $: __quote__ this ] @: myEllipsis

    'â€¦' myEllipsis $: dots
    '-' myEllipsis $: dash

    'Hello! My name is John Doe, and I live in a grave.' $: q

    q 12 dots fit 'Hello! My nâ€¦' assert=
    q 12 dash fit 'Hello! My n-' assert=
  ]
]

describe 'fromLeft' [
  in lang

  it dies 'when block is empty' [
    [ ] 0 fromLeft
  ]

  it dies 'when quote is empty' [
    '' 0 fromLeft
  ]

  it dies 'when index is negative for block' [
    [ 1 2 3 ] -1 fromLeft
  ]

  it dies 'when index is negative for quote' [
    'hello world' -1 fromLeft
  ]

  it should 'leave block element when index is in bounds' [
    [ 1 2 3 ] 0 fromLeft 1 assert=
    [ 1 2 3 ] 1 fromLeft 2 assert=
    [ 1 2 3 ] 2 fromLeft 3 assert=
  ]

  it should 'leave quote grapheme when index is in bounds' [
    'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ğŸ' 0 fromLeft 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§' assert= "family followed by apple"
    'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ğŸ' 1 fromLeft   'ğŸ' assert=

    'â’¶sÂ°Ã„manÑ‡ĞµĞ»' 0 fromLeft 'â’¶' assert=
    'â’¶sÂ°Ã„manÑ‡ĞµĞ»' 1 fromLeft 's' assert=
    'â’¶sÂ°Ã„manÑ‡ĞµĞ»' 2 fromLeft 'Â°' assert=
    'â’¶sÂ°Ã„manÑ‡ĞµĞ»' 3 fromLeft 'Ã„' assert=
    'â’¶sÂ°Ã„manÑ‡ĞµĞ»' 6 fromLeft 'n' assert=
    'â’¶sÂ°Ã„manÑ‡ĞµĞ»' 9 fromLeft 'Ğ»' assert=
  ]

  it dies 'when block index is out of bounds' [
    [ 1 2 3 ] 4 fromLeft
  ]

  it dies 'when quote index is out of bounds' [
    'hÅ“llÃ¶' 5 fromLeft
  ]

  it should 'die when argument is not block/quote' [
    [ 123 0 fromLeft ] 'bad type: decimal, expected: a block, byteslice, or quote' assertDies
  ]
]


describe 'fromRight' [
  in lang

  it should 'leave nth from right in block/quote' [
    [ 1 2 3 ] 0 fromRight 3 assert=
    [ 1 2 3 ] 1 fromRight 2 assert=
    [ 1 2 3 ] 2 fromRight 1 assert=
    'hello world' 0 fromRight 'd' assert=

    [ 123 0 fromRight ] 'bad type: decimal, expected: a block, byteslice, or quote' assertDies
    [ 'he' 'llo' fromRight ] 'bad type: quote, expected: a decimal' assertDies
  ]

  it should 'index quotes correctly' [
    'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ğŸ' 0 fromRight   'ğŸ' assert= "family followed by apple"
    'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ğŸ' 1 fromRight 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§' assert=

    'â’¶sÂ°Ã„manÑ‡ĞµĞ»' 9 fromRight 'â’¶' assert=
    'â’¶sÂ°Ã„manÑ‡ĞµĞ»' 8 fromRight 's' assert=
    'â’¶sÂ°Ã„manÑ‡ĞµĞ»' 7 fromRight 'Â°' assert=
    'â’¶sÂ°Ã„manÑ‡ĞµĞ»' 6 fromRight 'Ã„' assert=
    'â’¶sÂ°Ã„manÑ‡ĞµĞ»' 3 fromRight 'n' assert=
    'â’¶sÂ°Ã„manÑ‡ĞµĞ»' 0 fromRight 'Ğ»' assert=
  ]

  it should 'die when index is invalid' [
    [ [ ] 0 fromRight ] 'index out of bounds' assertDies
    [ '' 0 fromRight ] 'grapheme index out of bounds' assertDies
    [ [ 1 2 3 ] 3 fromRight ] 'index out of bounds' assertDies
    [ [ 1 2 3 ] -1 fromRight ] 'decimal is not a positive integer' assertDies
  ]
]


describe 'fromLeft*' [
  in lang

  it should 'take n items from left in block/quote' [
    [ 1 2 3 ] 0 fromLeft* [ ] assert=
    [ 1 2 3 ] 1 fromLeft* [ 1 ] assert=
    [ 1 2 3 ] 2 fromLeft* [ 1 2 ] assert=
    [ 1 2 3 ] 3 fromLeft* [ 1 2 3 ] assert=
    [ 1 2 3 ] 4 fromLeft* [ 1 2 3 ] assert=

    [ ] 0 fromLeft* [ ] assert=
    [ ] 123 fromLeft* [ ] assert=
    '' 0 fromLeft* '' assert=
    '' 123 fromLeft* '' assert=

    'hello world' 0 fromLeft* '' assert=
    'hello world' 1 fromLeft* 'h' assert=
    'hello world' 2 fromLeft* 'he' assert=
    'hello world' 5 fromLeft* 'hello' assert=
    'hello world' 100 fromLeft* 'hello world' assert=

    [ 123 0 fromLeft* ] 'bad type: decimal, expected: a block, byteslice, or quote' assertDies
    [ 'he' 'llo' fromLeft* ] 'bad type: quote, expected: a decimal' assertDies
  ]

  it should 'index quotes correctly' [
    'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ğŸ' 1 fromLeft* 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§' assert= "family followed by apple"
    'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ğŸ' 2 fromLeft* 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ğŸ' assert=

    'â’¶sÂ°Ã„manÑ‡ĞµĞ»' 0 fromLeft* '' assert=
    'â’¶sÂ°Ã„manÑ‡ĞµĞ»' 1 fromLeft* 'â’¶' assert=
    'â’¶sÂ°Ã„manÑ‡ĞµĞ»' 2 fromLeft* 'â’¶s' assert=
    'â’¶sÂ°Ã„manÑ‡ĞµĞ»' 3 fromLeft* 'â’¶sÂ°' assert=
    'â’¶sÂ°Ã„manÑ‡ĞµĞ»' 4 fromLeft* 'â’¶sÂ°Ã„' assert=
    'â’¶sÂ°Ã„manÑ‡ĞµĞ»' 7 fromLeft* 'â’¶sÂ°Ã„man' assert=
    'â’¶sÂ°Ã„manÑ‡ĞµĞ»' 10 fromLeft* 'â’¶sÂ°Ã„manÑ‡ĞµĞ»' assert=
  ]

  it should 'die when index is invalid' [
    [ [ 1 2 3 ] -1 fromLeft* ] 'decimal is not a positive integer' assertDies
  ]
]


describe 'fromRight' [
  in lang

  it should 'leave nth from right in block/quote' [
    [ 1 2 3 ] 0 fromRight* [ ] assert=
    [ 1 2 3 ] 1 fromRight* [ 3 ] assert=
    [ 1 2 3 ] 2 fromRight* [ 2 3 ] assert=
    [ 1 2 3 ] 3 fromRight* [ 1 2 3 ] assert=
    [ 1 2 3 ] 4 fromRight* [ 1 2 3 ] assert=

    [ ] 0 fromRight* [ ] assert=
    [ ] 123 fromRight* [ ] assert=
    '' 0 fromRight* '' assert=
    '' 123 fromRight* '' assert=

    'hello world' 0 fromRight* '' assert=
    'hello world' 1 fromRight* 'd' assert=
    'hello world' 2 fromRight* 'ld' assert=
    'hello world' 5 fromRight* 'world' assert=
    'hello world' 100 fromRight* 'hello world' assert=

    [ 123 0 fromRight* ] 'bad type: decimal, expected: a block, byteslice, or quote' assertDies
    [ 'he' 'llo' fromRight* ] 'bad type: quote, expected: a decimal' assertDies
  ]

  it should 'index quotes correctly' [
    'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ğŸ' 1 fromRight*   'ğŸ' assert= "family followed by apple"
    'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ğŸ' 2 fromRight*'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ğŸ' assert=

    'â’¶sÂ°Ã„manÑ‡ĞµĞ»' 10 fromRight* 'â’¶sÂ°Ã„manÑ‡ĞµĞ»' assert=
    'â’¶sÂ°Ã„manÑ‡ĞµĞ»' 9 fromRight* 'sÂ°Ã„manÑ‡ĞµĞ»' assert=
    'â’¶sÂ°Ã„manÑ‡ĞµĞ»' 8 fromRight* 'Â°Ã„manÑ‡ĞµĞ»' assert=
    'â’¶sÂ°Ã„manÑ‡ĞµĞ»' 7 fromRight* 'Ã„manÑ‡ĞµĞ»' assert=
    'â’¶sÂ°Ã„manÑ‡ĞµĞ»' 4 fromRight* 'nÑ‡ĞµĞ»' assert=
    'â’¶sÂ°Ã„manÑ‡ĞµĞ»' 1 fromRight* 'Ğ»' assert=
  ]

  it should 'die when index is invalid' [
    [ [ 1 2 3 ] -1 fromRight* ] 'decimal is not a positive integer' assertDies
  ]
]


describe 'toWord' [
  in lang

  it should 'noop if already word' [
    #hello toWord #hello assert=
  ]

  it should 'convert quote to word' [
    'hello' toWord #hello assert=
  ]

  it should 'peel off all quoting' [
    ########hello toWord #hello assert=
  ]

  it should 'convert when quote has grapheme clusters' [
    'xğŸ‘»ğŸ‘ºğŸ¤–' toWord #xğŸ‘»ğŸ‘ºğŸ¤– assert=
  ]

  it should 'die when quote is invalid' [
    [ '' toWord ] 'toWord: quote argument is empty' assertDies
    [ ' ' toWord ] 'toWord: quote argument contains whitespace' assertDies
    [
    '


    ' toWord ] 'toWord: quote argument contains whitespace' assertDies
    [ 'hello world' toWord ] 'toWord: quote argument contains whitespace' assertDies
  ]

  it should 'die when of invalid type' [
    [ 123 toWord ] 'bad type: decimal, expected: a quote, quoted word, or word' assertDies
  ]
]

describe 'uppercase?' [
  in lang

  it should 'leave false for empty quote' [
    '' uppercase? false assert=
  ]

  it should 'leave false for whitespace quote' [
    ' ' uppercase? false assert=
    '     ' uppercase? false assert=
    '
    ' uppercase? false assert=
  ]

  it should 'work for single-letter quotes' [
    'H' uppercase?  true assert=
    'Ã' uppercase?  true assert=
    'c' uppercase? false assert=
    '.' uppercase? false assert=
  ]

  it should 'work for multi-letter quotes' [
    'HELLO' uppercase?  true assert=
      'HÃÃ‹' uppercase?  true assert=
    'HeLLO' uppercase? false assert=
    'HÃÃ‹Ã¥'  uppercase? false assert=
  ]
]

describe 'toUppercase' [
  in lang

  it dies 'when not given a quote #1' [
    0 toUppercase
  ]

  it dies 'when not given a quote #2' [
    #foo toUppercase
  ]

  it should 'leave empty quote unchanged' [
    '' toUppercase '' assert=
  ]

  it should 'leave whitespace/single-uppercase-character quote unchanged' [
    ' ' toUppercase ' ' assert=
    'C' toUppercase 'C' assert=
    'Ã„' toUppercase 'Ã„' assert=
    '.' toUppercase '.' assert=
    '0' toUppercase '0' assert=
    'Â°' toUppercase 'Â°' assert=
    'â‚¬' toUppercase 'â‚¬' assert=
  ]


  it should 'uppercase single lowercase character' [
    'c' toUppercase 'C' assert=
    'Ã¤' toUppercase 'Ã„' assert=
    'Ä' toUppercase 'Ä€' assert=
  ]

  it should 'uppercase multi-character quotes' [
    'HI' toUppercase 'HI' assert=
    'Hi' toUppercase 'HI' assert=
    'hI' toUppercase 'HI' assert=
    'á¸¦Ã¯' toUppercase 'á¸¦Ã' assert=
    'ÃƒuxiÂ£Ã¥Ã…' toUppercase 'ÃƒUXIÂ£Ã…Ã…' assert=
  ]
]

describe 'sliceQuoteAt' [
  in lang

  it dies 'when given non-quote #1' [
    0 1 sliceQuoteAt
  ]

  it dies 'when given non-quote #2' [
    #foobar 1 sliceQuoteAt
  ]

  it dies 'when given non-quote #3' [
    ##foobar 1 sliceQuoteAt
  ]

  it dies 'when given non-quote #4' [
    [ 1 2 3 ] 1 sliceQuoteAt
  ]

  it dies 'when given empty quote' [
    '' 0 sliceQuoteAt
  ]

  it dies 'when slicepoint is negative' [
    'foobar' -1 sliceQuoteAt
  ]

  it dies 'when slicepoint > quote count' [
    'foobar' 7 sliceQuoteAt
  ]

  it should 'handle slicepoint 0 = case' [
    [ 'foobar' 0 sliceQuoteAt ] vals [ '' 'foobar' ] assert=
  ]

  it should 'handle slicepoint quote count = case' [
    [ 'foobar' 6 sliceQuoteAt ] vals [ 'foobar' '' ] assert=
  ]

  it should 'properly slice in bounds' [
    [ 'foo|bar' 3 sliceQuoteAt ] vals [ 'foo' '|bar' ] assert=
  ]

  it should 'properly slice when Unicode characters present' [
    [ 'â’¶sÂ°Ã„manÑ‡ĞµĞ»' 4 sliceQuoteAt ] vals [ 'â’¶sÂ°Ã„' 'manÑ‡ĞµĞ»' ] assert=
  ]

  it should 'properly slice single grapheme cluster' [
    [ 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§' 0 sliceQuoteAt ] vals [ '' 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§' ] assert=
    [ 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§' 1 sliceQuoteAt ] vals [ 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§' '' ] assert=
  ]

  it should 'properly slice multiple grapheme clusters + characters' [
    [ 'Â©oobazğŸ‘¨â€ğŸ‘©â€ğŸ‘§ğŸfÃ¶obar' 7 sliceQuoteAt ] vals [ 'Â©oobazğŸ‘¨â€ğŸ‘©â€ğŸ‘§' 'ğŸfÃ¶obar' ] assert=
  ]
]

describe '|slice' [
  in lang

  it dies 'when given non-block #1' [
    #foobar |slice
  ]

  it dies 'when given non-block #2' [
    true |slice
  ]

  it dies 'when given non-block #4' [
    'foobar' |slice
  ]

  it dies 'when given non-block #5' [
    100 |slice
  ]

  it should 'slice when |at 0' [
    [ [ ] |slice ] vals [ [ ] [ ] ] assert=
    [ [ | 1 2 3 ] |slice ] vals [ [ ] [ 1 2 3 ] ] assert=
  ]

  it should 'slice when |at count' [
    [ [ 1 2 3 ] |slice ] vals [ [ 1 2 3 ] [ ] ] assert=
  ]

  it should 'slice when |at in first half' [
    [ [ 1 | 2 3 4 ] |slice ] vals [ [ 1 ] [ 2 3 4 ] ] assert=
  ]

  it should 'slice when |at in second half' [
    [ [ 1 2 3 | 4 ] |slice ] vals [ [ 1 2 3 ] [ 4 ] ] assert=
  ]
]


describe 'slurp' [
  in lang

  it should 'handle empty quote' [
    [ ] '' slurp [ ] assert=
  ]

  it should 'slurp words properly' [
    [ ] 'hello-world 2boo 2.foo x.yzzy a.b.c 0. .0' slurp [ hello-world 2boo 2 . foo x . yzzy a . b . c 0 . . 0 ] assert=
  ]

  it should 'slurp grapheme cluster words properly' [
    [ ] 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ ğŸ‘¨â€ğŸ‘¨â€ğŸ‘¦â€ğŸ‘¦ ğŸğŸğŸ ğŸ¦Š.Hi!.x <<ğŸ˜Bye!>>' slurp $: uniwords
    uniwords 0 fromLeft #ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ assert=
    uniwords 1 fromLeft #ğŸ‘¨â€ğŸ‘¨â€ğŸ‘¦â€ğŸ‘¦ assert=
    uniwords 2 fromLeft #ğŸğŸğŸ assert=
    uniwords 5 fromRight #ğŸ¦Š assert=
    uniwords 4 fromRight #. assert=
    uniwords 3 fromRight #Hi! assert=
    uniwords 2 fromRight #. assert=
    uniwords 1 fromRight #x assert=
    uniwords 0 fromRight #<<ğŸ˜Bye!>> assert=
  ]

  it should 'slurp quoted words' [
    [ ] '# #x #xğŸ‘»ğŸ‘ºğŸ¤– #x.y #x.#y.#z' slurp [ # #x #xğŸ‘»ğŸ‘ºğŸ¤– #x.y #x.#y.#z ] assert=
    [ ] '## #x #xğŸ‘»ğŸ‘ºğŸ¤– #x.y #x.#y.#z' slurp vals [ ## #x #xğŸ‘»ğŸ‘ºğŸ¤– #x.y #x.#y.#z ] vals assert=
  ]

  it should 'slurp decimals properly' [
    [ ] '123 -123 +123 1_23 1__23 -12_3 -_1 -1_ +_1 +1_ 0000 0.000 .123 123. _.123 123._ 0.1 0.23 0.23_4 0_.23_4 _0.234 0.23_ 0._23 0.123456789123456789123456789' slurp
      [
        123
        -123
        123
        123
        123
        -123
        #-_1
        #-1_
        #+_1
        #+1_
        0
        0
        #. 123
        123 #.
        #_ #. 123
        123 #. #_
        0.1
        0.23
        0.234
        #0_ #. 234
        #_0 #. 234
        0 #. #23_
        0 #. #_23
        0.123456789123456789123456789
      ] vals assert=
  ]

  it should 'slurp quotes correctly' [
    [ ] '\'ğŸ’hello ğŸ‘‹ \invalid \Escape \\\'world!!!\\\' \\\\n \\n \n\n ğŸ‘¨â€ğŸ‘¨â€ğŸ‘¦â€ğŸ‘¦!ğŸ¹\'' slurp val
    'ğŸ’hello ğŸ‘‹ \invalid \Escape \'world!!!\' \\n \n \n\n ğŸ‘¨â€ğŸ‘¨â€ğŸ‘¦â€ğŸ‘¦!ğŸ¹' assert=

    [ [ ] '\'hello world!!' slurp ] 'unterminated excerpt: no matching â¸¢\'â¸¥' assertDies
    [ [ ] 'hello world!!\'' slurp ] 'unterminated excerpt: no matching â¸¢\'â¸¥' assertDies
    [ [ ] '\'\\' slurp ] 'excerpt ended suddenly: expected escape sequence, grapheme, or â¸¢\'â¸¥' assertDies
  ]

  it should 'slurp comments correctly' [
    [ ] '[ "ğŸ’hello ğŸ‘‹ \invalid \Escape \"world!!!\" \\\\n \\n \n\n ğŸ‘¨â€ğŸ‘¨â€ğŸ‘¦â€ğŸ‘¦!ğŸ¹" ]' slurp top desc
      'ğŸ’hello ğŸ‘‹ \invalid \Escape "world!!!" \\n \\n \n\nğŸ‘¨â€ğŸ‘¨â€ğŸ‘¦â€ğŸ‘¦!ğŸ¹' assert=
  ]

  it should 'slurp block open/close brackets properly' [
    [ ] '[]' slurp [ [ ] ] assert=
    [ ] '[.]' slurp [ [ . ] ] assert=
    [ ] '[ ]' slurp [ [ ] ] assert=
    [ ] '[ğŸ’ ]' slurp [ [ ğŸ’ ] ] assert=
    [ ] '[ğŸ‘¨â€ğŸ‘¨â€ğŸ‘¦â€ğŸ‘¦]' slurp [ [ ğŸ‘¨â€ğŸ‘¨â€ğŸ‘¦â€ğŸ‘¦ ] ] assert=
    [ ] '[ğŸ‘¨â€ğŸ‘¨â€ğŸ‘¦ ğŸ‘‹]' slurp [ [ ğŸ‘¨â€ğŸ‘¨â€ğŸ‘¦ ğŸ‘‹ ] ] assert=
    [ ] '[ ğŸ‘¨â€ğŸ‘¨â€ğŸ‘¦ ğŸ‘‹]' slurp [ [ ğŸ‘¨â€ğŸ‘¨â€ğŸ‘¦ ğŸ‘‹ ] ] assert=
    [ ] '[ğŸ‘¨â€ğŸ‘¨â€ğŸ‘¦ ğŸ‘‹ ]' slurp [ [ ğŸ‘¨â€ğŸ‘¨â€ğŸ‘¦ ğŸ‘‹ ] ] assert=

    [ [ ] '[' slurp ] 'missing \']\'' assertDies
    [ [ ] ']' slurp ] 'mismatched \']\' in block' assertDies
  ]
]
