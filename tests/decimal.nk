"Note: a bunch of tests have been stolen from Roast (the Raku test suite),
 because I really lack imagination for writing this kind of stuff."

describe 'Decimal parsing' [
  it should 'parse simple decimals' [
    1 12 123 1234567812345678 12_34_56 1_000_000 000_000_001 5__000
  ]

  it dies 'given "_" in simple decimal' [ _ ] "definition not found"
  it dies 'when leading underscore in simple decimal' [ _100 ] "definition not found"
  it dies 'when trailing underscore in simple decimal' [ 100_ ] "definition not found"

  it should 'parse negative decimals' [
    -123 -1 -0 -1234567812345678 -1_000_000 -123_456 -100_5 -5__000
  ]

  it dies 'given "_" in negative decimal' [ -_ ] "definition not found"
  it dies 'when leading underscore in negative decimal' [ -_100 ] "definition not found"
  it dies 'when trailing underscore in negative decimal' [ -100_ ] "definition not found"

  it should 'parse explicit positive decimals' [
    +123 +1 +0 +1234567812345678
  ]

  it dies 'given "_" in positive decimal' [ +_ ] "definition not found"
  it dies 'when leading underscore in positive decimal' [ +_100 ] "definition not found"
  it dies 'when trailing underscore in positive decimal' [ +100_ ] "definition not found"

  it should 'parse floats' [
    1.0 1.0000000 1.000001 1.01234 1.12_345 100.1 10_0.0 0.0 0.000 0000.0_000
  ]

  it dies 'when nothing before "."' [ .100 ] "no top for block (for '.')"
  it dies 'when nothing after "."' [ 100. ] "cursor index out of bounds"
  it dies 'when underscore before "."' [ _.100 ] "definition not found: '_'"
  it dies 'when underscore after "."' [ 100._ ] "bad type: a decimal number, expected: a block"
  it dies 'when trailing underscore before "."' [ 100_.3 ] "definition not found"
  it dies 'when leading underscore after "."' [ 100._3 ] "bad type: a decimal number, expected: a block"

  it should 'parse negative floats' [
    -1.0 -1.0000000 -1.000001 -1.0_1234 -1.12345 -10_0.1 -100.0 -0.0 -0.000 -0000.000_0
  ]

  it dies 'when nothing before "." negative' [ -.100 ]
  it dies 'when nothing after "." negative' [ -100. ]
  it dies 'when underscore before "." negative' [ -_.100 ]
  it dies 'when underscore after "." negative' [ -100._ ]
  it dies 'when trailing underscore before "." negative' [ -100_.3 ]
  it dies 'when leading underscore after "." negative' [ -100._3 ]

  it should 'parse explicit positive floats' [
    +1.0 +1.0000_000 +1.000001 +1.01234 +1.12345 +1__0_0.1 +100.0 +0.0 +0.000 +0000.0000
  ]

  it dies 'when nothing before "." positive' [ +.100 ]
  it dies 'when nothing after "." positive' [ +100. ]
  it dies 'when underscore before "." positive' [ +_.100 ]
  it dies 'when underscore after "." positive' [ +100._ ]
  it dies 'when trailing underscore before "." positive' [ +100_.3 ]
  it dies 'when leading underscore after "." positive' [ +100._3 ]
]

describe 'Package math: inter-domain decimal math' [
  "--- Addition: primitive word + ------------------------"

  it should 'add two small decimals' [
    1 2 + 3 assert=
  ]

  it should 'subtract when either addend is negative' [
    100 -3 + 100 3 - assert=
    -100 3 + 3 100 - assert=
    and
  ]

  it should 'add when both addends are negative' [
    -100 -300 + -400 assert=
  ]

  itDies 'when a non-decimal is added to decimal' [
    1 '2' +
  ]

  it should 'try to convert type block arguments to decimals via *asDecimal' [
    [ $: *asDecimal this ] @: foos
    100 foos 200 foos + 300 assert=
  ]

  "--- Subtraction: primitive word - ---------------------"

  it should 'subtract two small decimals' [
    1 2 - -1 assert=
  ]

  it should 'add when subtrahend is negative' [
    1 -2 - 1 2 + assert=
  ]

  it should 'subtract when minuend is negative' [
    -1 3 - -4 assert=
  ]

  it should 'subtract when both terms are negative' [
    -100 -400 - 400 100 - assert=
  ]

  "--- Multiplication: primitive word * ------------------"

  it should 'multiply two small decimals' [
    100 2 * 200 assert=
  ]

  "--- Division: primitive word / ------------------------"

  it should 'divide when divident is negative' [
    -100 2 / -50 assert=
  ]

  itDies 'when divisor is zero' [
    100 0 /
  ]

  "--- Modulo: primitive word % --------------------------"

  it should 'compute modulo for two small decimals' [
    13 3 rem 1 assert=
  ]

  it should 'compute modulo with negative divident' [
    -13 4 rem 3 assert=
  ]

  it should 'compute modulo with negative divisor' [
    13 -4 rem -3 assert=
    -13 -4 rem -1 assert=
    and
  ]

  itDies 'when modulo divisor is zero' [
    13 0 rem
  ]
]

describe 'Package math: cross-domain decimal math' [

]

describe 'Package math: floating point (precise) math' [
  it should 'pass 0.1 + 0.2 = 0.3 test' [
    0.1 0.2 + 0.3 assert=
  ]

  it should 'compute modulo with fp divisor' [
    "TODO: RAISES FOR SOME REASON 5 0.25 rem 0 assert="
    false
  ]

  it should 'compute modulo with fp divident' [
    0.25 5 rem 0.5 assert=
  ]
]

describe '*asDecimal hook for implicit conversion of blocks to decimals' [
  itDies 'when block does not implement *asDecimal' [
    1 [ ] +
  ]

  it should 'support blocks which implement *asDecimal literally' [
    [ $: *asDecimal this ] @: wrap
    1 2 wrap + 3 assert=
  ]

  it should 'support blocks which implement *asDecimal computationally' [
    [ $: value [ value dup * ] @: *asDecimal this ] @: squareWrap
    1 2 squareWrap + 5 assert=
  ]

  itDies 'when block does not return a decimal in *asDecimal' [
    [ enquote $: *asDecimal this ] @: wrap
    1 2 wrap +
  ]

  it should 'support blocks whose *asDecimal leaves block which implements *asDecimal' [
    [ $: n [ n ] @: *asDecimal this ] @: foos
    [ $: *asDecimal this ] @: wrap
    100 foos wrap 0 + 100 assert=
  ]

  it should 'support blocks whose *asDecimal computes & leaves block which implements *asDecimal' [
    [ $: n [ n ] @: *asDecimal this ] @: foos
    [ $: n [ n foos ] @: *asDecimal this ] @: wrap
    100 foos 0 + 100 assert=
  ]

  it should 'die when same type left in *asDecimal' [
    "TODO: change this to itDiesWith (TODO) later. It does die here, but for
     a different reason."

    "
    [ $: n [ n foos ] @: *asDecimal this ] @: foos
    100 foos 200 foos + 300 foos assert=
    "

    false
  ]
]
