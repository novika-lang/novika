describe 'essential lookup' [
  in lang

  it should 'lookup in parent(s)' [
    'hi' $: bar

    [ 1 $: x ] obj $: a
    [ 2 $: y ] obj $: b
    [ 3 $: z 100 $: y ] obj $: c

    "c <- b <- a <- this"
    c b reparent drop "c <- b"
    b a reparent drop "b <- a"

    [ x y z bar ] c reparent @: foo "foo <- c <- b <- a <- this"
    [ foo ] vals [ 1 100 3 'hi' ] assert=
  ]

  it should 'allow for more complex scoping, access with \'.\'' [
    [ $: delta

      this parent $: super

      [ @: block
        [ 1 + block ] super.each
      ] @: each

      this
    ] @: eachIncrementor

    5 eachIncrementor $: inc

    [ ] $: results

    [ 1 2 3 ] [ 2 * results gulp ] inc.each

    results [ 4 6 8 ] assert=
  ]
]


describe 'block friends' [
  in lang

  it should 'befriend and unfriend' [
    [ 0 $: x this 'hello' $: bar ] open $: a
    [ 1 $: y this ] open $: b
    [ 3 $: z this ] open $: c
    [ 3 $: x this ] open $: d

    [ [ bar ' from foo' ] ~* $: bar this ] $: foo
    foo a befriend
    foo b befriend
    foo c befriend
    foo d befriend

    foo open $: fooI
    fooI.x 3 assert=
    fooI.y 1 assert=
    fooI.z 3 assert=
    fooI.bar 'hello from foo' assert=

    foo c unfriend

    foo open $: fooI
    fooI.x 3 assert=
    fooI.y 1 assert=
    [ fooI.z ] 'no value form for \'z\'' assertDies

    foo a unfriend
    [ foo open ] 'no value form for \'bar\'' assertDies
  ]

  it should 'support direct modification of friends' [
    [ 100 $: foo this ] open $: x
    [ 200 $: bar this ] open $: y

    x friends count 0 assert=
    y friends count 0 assert=

    x friends y shove
    x.foo 100 assert=
    x.bar 200 assert=

    x friends [ dup.bar 100 = => drop ] hydrate
    x.bar 200 assert=

    x friends [ dup.bar 200 = => drop ] hydrate
    x.foo 100 assert=
    [ x.bar ] 'no value form for \'bar\'' assertDies
    x friends count 0 assert=
  ]

  it should 'ignore immediate recursion' [
    [ [ ] dup dup befriend . x ] 'no value form for \'x\'' assertDies
  ]

  it should 'ignore deep recursion' [
    [ 100 $: a this ] open $: x
    [ 200 $: b this ] open $: y
    [ 300 $: c this ] open $: z

    y x befriend

    z x befriend
    z y befriend

    y.a 100 assert=
    y.b 200 assert=

    z.a 100 assert=
    z.b 200 assert=
    z.c 300 assert=
    [ z.d ] 'no value form for \'d\'' assertDies
  ]

  it should 'support mutual friendship' [
    [ 100 $: x this ] open $: a
    [ 200 $: y this ] open $: b

    a b befriend
    b a befriend

    a.x 100 assert=
    a.y 200 assert=
    b.x 100 assert=
    b.y 200 assert=

    a #x [ 'I\'ve ' 'changed!' ~ ] opens
    a.x 'I\'ve changed!' assert=
    b.x 'I\'ve changed!' assert=
  ]

  it should 'die when an invalid friend form is added' [
    [ this ] open $: boo
    boo friends 100 shove
    [ boo.explode! ] 'expected a block, got decimal for a friend' assertDies
  ]

  it should 'ask all friends first before going deeper' [
    [ 'Hey' $: foo ] obj $: fooizer
    [ 'Bye' $: bar ] obj $: barizer

    [ 100 $: x ] obj $: x
    x fooizer befriend

    [ 200 $: y ] obj $: y
    y barizer befriend

    orphan $: myBlock

    myBlock x befriend
    myBlock y befriend

    myBlock.x 100 assert=
    myBlock.y 200 assert=
    myBlock.foo 'Hey' assert=
    x.foo 'Hey' assert=
    [ y.foo ] 'no value form for \'foo\'' assertDies
    myBlock.bar 'Bye' assert=
    y.bar 'Bye' assert=
    [ x.bar ] 'no value form for \'bar\'' assertDies
  ]
]


describe 'Engine recursion handling' [
  in lang

  it should 'die when engine recursion limit is exceeded' [
    [ [ bI ] @: __decimal__ this ] @: a
    [ [ aI ] @: __decimal__ this ] @: b

    a $: aI
    b $: bI

    [ aI bI + ] 'bad engine depth: deep recursion in a __metaword__?' assertDies
  ]
]

describe 'Block metawords' [
  in lang

  it should 'support __shove__ and __cherry__' [
    [
      [ ] $: controlledStack

      [ "Triggered on shove into this block."

        "default implementation" desc
          '( F -- ): default __shove__ implementation' startsWith? true assert=

        controlledStack gulp
      ] @: __shove__

      [ "Triggered on cherry from this block."

        "default implementation" desc
          '( -- ): default __cherry__ implementation' startsWith? true assert=

        controlledStack cherry
      ] @: __cherry__

      [ [ '<controlled stack: ' controlledStack '>' ] ~* ] @: __quote__
    ] obj $: b

    b [ 1 2 drop 3 ] there
    b toQuote '<controlled stack: [ 1 3 ]>' assert=
  ]
]


describe 'Metawords capability inheritance' [
  in lang

  it should 'allow metawords to inherit capabilities' [
    __path__ 'res' disk:join 'decimalA.txt' disk:join $: pathToA
    __path__ 'res' disk:join 'decimalB.txt' disk:join $: pathToB

    [ '\r\n' '\n' replaceAll ] @: replaceTheFuckingWindowsThing

    pathToA disk:read replaceTheFuckingWindowsThing $: aContent
    pathToB disk:read replaceTheFuckingWindowsThing $: bContent

    aContent '123.456\n' assert=
    bContent '456.123\n' assert=

    [ $: qPath

      this $: self

      [
        qPath disk:read replaceTheFuckingWindowsThing $: qDecimal
        qDecimal parseDecimal
      ] @: __decimal__

      [
        nip self 1 + swap open "remove original form, shove self decimal + 1"
      ] @: __shove__

      [
        drop self 1 - "remove original cherry impl; give them self decimal - 1"
      ] @: __cherry__

      this
    ] @: myDecimalOnDisk

    pathToA myDecimalOnDisk $: a
    pathToB myDecimalOnDisk $: b

    a prototype (this -> myDecimalOnDisk prototype) same? true assert=
    b prototype (this -> myDecimalOnDisk prototype) same? true assert=

    a asDecimal a same? true assert=
    b asDecimal b same? true assert=

    a b + 579.579 assert=

    "shove"

    a [ 1 2 3 ] there 3 fromRight* [ 124.456 124.456 124.456 ] assert=

    b 4 shove
    b 5 shove
    b 6 shove
    b 3 fromRight* [ 457.123 457.123 457.123 ] assert=

    "cherry"

    a [ 1 drop ] there 0 fromRight 124.456 assert=
    a cherry 122.456 assert=
    b cherry 455.123 assert=
  ]

  it should 'allow FFI buildStruct/buildUnion words to inherit capabilities' [
    __path__ 'res' disk:join 'decimalA.txt' disk:join $: pathToA
    __path__ 'res' disk:join 'decimalB.txt' disk:join $: pathToB

    [ pathToA disk:read parseDecimal ] @: x
    [ pathToB disk:read parseDecimal ] @: y

    [ x f64
      y f64
    ] ffi:createLayout $: point

    this point ffi:buildStruct~ $: s

    s.x 123.456 assert=
    s.y 456.123 assert=
  ]
]
