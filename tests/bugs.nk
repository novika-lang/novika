describe 'Handle infinite block instantiation #22' [
  "Note: needs more tests, this is a particularly nasty one."

  it should 'instantiate block with reflections' [
    [ ] $: a
    a a <<
    a new >> same?
  ]

  it should 'instantiate block with deep reflections' [
    [ ] $: x
    [ [ [ [ [ x ] ] ] ] ] here $: y
    x y shove
    x new
  ]

  it should 'instantiate stack' [
    conts 0 fromRight dup new
  ]

  it should 'compare reflections' [
    [ ] $: a
    a a enclose <<
    a 0 fromLeft a = not
  ]

  it should 'compare deep reflections' [
    [ ] $: x
    [ [ [ [ [ [ [ x ] ] ] ] ] ] ] here $: y
    x y enclose shove
    y y = x 0 fromLeft y = not assert=
  ]
]

describe 'Conversion words should not be inherited #25' [
  [
    [ ] $: x

    'hello' $: *asQuote
    [ 100 1 + ] @: *asDecimal
    false $: *asBoolean
    [ ##fubar ] @: *asQuotedWord
    [ [ #baz $: *asWord this ] open ] @: *asWord

    this
  ] @: b

  it dies 'because child doesn\'t inherit *asQuote' [ b.x asQuote ]
  it dies 'because child doesn\'t inherit *asDecimal' [ b.x asDecimal ]
  it dies 'because child doesn\'t inherit *asBoolean' [ b.x asBoolean ]
  it dies 'because child doesn\'t inherit *asQuotedWord' [ b.x asQuotedWord ]
  it dies 'because child doesn\'t inherit *asWord' [ b.x asWord ]

  [ [ ] $: x 'hello' $: *asQuote this ] @: issueEg1
  [ [ ] $: x [ 100 1 + ] @: *asDecimal this ] @: issueEg2

  it should 'pass issue example #1' [ issueEg1 dup asQuote assert= ]
  it dies 'as expected in issue example #1' [ issueEg1.x asQuote ]

  it should 'pass issue example #2' [ issueEg2 1 + 102 assert= ]
  it dies 'as expected in issue example #2' [ issueEg2.x 1 +  ]
]

describe 'Infinite recursion when word undefined inside word trap #8' [
  it dies 'because definition for this-word-is-undefined not found in the enclosing block(s)' [
    [ this-word-is-undefined ] @: *trap
    this-word-is-undefined-and-will-trigger-the-trap
  ]

  it should 'climb traps' [
    [ 100 ] @: *trap
    [ ] [
      [ 200 trigger-upper-trap2 ] @: *trap
      [
        [ 300 trigger-upper-trap ] @: *trap
        trigger-my-own-trap
      ] open
    ] there [ trigger-my-own-trap 300 trigger-upper-trap 200 trigger-upper-trap2 100 ] assert=
  ]
]
