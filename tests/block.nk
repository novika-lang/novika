describe 'anyof:' [
  in lang

  it should 'support basic use with block literal as arg' [
    100 anyof: [ 1 2 3 ] false assert=
    #foo anyof: [ foo bar ] true assert=
  ]

  it should 'support use with word as arg' [
    [ 1 2 3 ] $: x
    1 anyof: x true assert=
    #foo anyof: x false assert=

    [ 1 $: n [ n 1 + n 2 + n 3 + ] vals ] @: duFu

    2 anyof: duFu true assert=
    3 anyof: duFu true assert=
    4 anyof: duFu true assert=
    5 anyof: duFu false assert=
  ]

  it should 'die when result is not a block' [
    'hello' $: x
    [ 1 2 3 ] @: y

    [ 1 anyof: 123 ] 'bad type: decimal, expected: a block' assertDies
    [ 1 anyof: x ] 'bad type: quote, expected: a block' assertDies
    [ 1 anyof: y ] 'bad type: decimal, expected: a block' assertDies
  ]
]

describe 'peek?' [
  in lang

  it should 'leave false when block is empty' [
    [ [  ] peek? ] vals [ false ] here assert=
  ]

  it should 'leave false when block cursor is at end' [
    [ [ 1 2 3 ] peek? ] vals [ false ] here assert=
  ]

  it should 'leave form, true when block cursor is at start' [
    [ [ | 1 2 3 ] peek? ] vals [ 1 true ] here assert=
  ]

  it should 'leave form, true when block cursor is in the middle' [
    [ [ 1 | 2 3 ] peek? ] vals [ 2 true ] here assert=
    [ [ 1 2 | 3 ] peek? ] vals [ 3 true ] here assert=
  ]
]


describe '|afterFirst?' [
  in lang

  it should 'leave whether the cursor is after the first form in block' [
    [ | ] |afterFirst? false assert=
    [ 1 | ] |afterFirst? true assert=
    [ 1 | 2 3 ] |afterFirst? true assert=
    [ 1 2 3 | ] |afterFirst? false assert=
  ]
]


describe '|afterLast?' [
  in lang

  it should 'leave whether the cursor is after the last form in block' [
    [ | ] |afterLast? true assert=
    [ 1 | ] |afterLast? true assert=
    [ | 1 2 3 ] |afterLast? false assert=
    [ 1 | 2 3 ] |afterLast? false assert=
    [ 1 2 3 | ] |afterLast? true assert=
  ]
]


describe '|-' [
  in lang

  it dies 'when cursor is at 0' [
    [ | 1 2 3 ] 1 |-
  ]

  it should 'not die when cursor at 0, but moving 0 times' [
    [ | 1 2 3 ] dup 0 |- |at 0 assert=
  ]

  it should 'not move cursor when 0 times' [
    [ 1 2 3 ] dup 0 |- |at 3 assert=
  ]

  it should 'move cursor' [
    [ 1 2 3 ] dup 2 |- |at 1 assert=
  ]

  it should 'move cursor for stack' [
    1 2 stack 1 |- 1 assert=
  ]
]

describe '|+' [
  in lang

  it dies 'when cursor is at end' [
    [ 1 2 3 ] 1 |+
  ]

  it should 'not die when cursor at end, but moving 0 times' [
    [ 1 2 3 ] dup 0 |+ |at 3 assert=
  ]

  it should 'not move cursor when 0 times' [
    [ 1 2 3 ] dup 0 |+ |at 3 assert=
  ]

  it should 'move cursor' [
    [ 1 | 2 3 ] dup 1 |+ |at 2 assert=
  ]

  it should 'move cursor for stack' [
    1 2 <| stack 1 |+ 2 assert=
  ]
]

describe '|:' [
  in lang

  it should 'act as an infix version of there' [
    [ [ ] |: 100 ] vals [ [ 100 ] ] assert=

    [ 1 2 ] $: b
    b |: + b same? true assert=
    b [ 3 ] assert=

    ([ 1 2 3 ] |: [ <| + |> ]) [ 3 3 ] assert=
  ]

  it should 'preserve ahead' [
    [
      [ 100 ] |: [ (ahead prototype) (outer prototype) same? true assert= ] drop
    ] $: outer

    outer open

    [ [ 100 ] |: [ ahead thru + ] 200 123 ] vals [ [ 300 ] 123 ] assert=
  ]
]

describe '|clamp' [
  in lang

  it should 'perform clamped |to' [
    [ [ 1 2 3 ] 'hello' |clamp ] 'bad type: quote, expected: a decimal' assertDies
    [ 'hello world' 2 |clamp ] 'bad type: quote, expected: a block' assertDies

    [ ] dup 0 |clamp [ ] assert=
    [ ] dup -123 |clamp [ ] assert=
    [ ] dup 123 |clamp [ ] assert=

    [ 1 2 3 ] dup -123 |clamp [ | 1 2 3 ] assert=
    [ 1 2 3 ] dup 0 |clamp [ | 1 2 3 ] assert=
    [ 1 2 3 ] dup 1 |clamp [ 1 | 2 3 ] assert=
    [ 1 2 3 ] dup 2 |clamp [ 1 2 | 3 ] assert=
    [ 1 2 3 ] dup 3 |clamp [ 1 2 3 ] assert=
    [ 1 2 3 ] dup 123 |clamp [ 1 2 3 ] assert=
  ]
]

describe '|hydrate' [
  in lang

  it should 'hydrate at cursor' [
    [ [ 1 2 3 ] 0 'hello' |hydrate ] 'bad type: quote, expected: a block' assertDies
    [ [ 1 2 3 ] 'hello' [ ] |hydrate ] 'bad type: quote, expected: a decimal' assertDies
    [ 'hello' 0 [ ] |hydrate ] 'bad type: quote, expected: a block' assertDies

    [ [ 1 2 3 ] -123 [ ] |hydrate ] 'cursor index out of bounds' assertDies
    [ [ 1 2 3 ] -123 [ ] |hydrate ] 'cursor index out of bounds' assertDies

    [ [ ] -123 [ ] |hydrate ] 'cursor index out of bounds' assertDies
    [ [ ]  123 [ ] |hydrate ] 'cursor index out of bounds' assertDies
    [ [ ]  123 [ ] |hydrate ] 'cursor index out of bounds' assertDies

    [ ] $: blk

    blk 0 [ 1 2 3 ] |hydrate
    blk [ | 1 2 3 ] assert=

    blk 2 [ drop ] |hydrate
    blk [ | 1 3 ] assert=

    blk 2 [ + ] |hydrate
    blk [ | 4 ] assert=

    blk 0 [ |> ] |hydrate
    blk [ | 4 ] assert=

    blk 1 |to
    blk 1 [ 5 6 ] |hydrate
    blk [ 4 | 5 6 ] assert=

    blk 2 [ 2drop ] |hydrate
    blk [ 6 ] assert=

    blk 1 [ drop ] |hydrate
    blk [ ] assert=
  ]
]

describe '|swap' [
  in lang

  it should 'swap before&after cursor in stack' [
    [ 1 2 3 ] [ <| |swap |> ] there [ 1 3 2 ] assert=
  ]
]

describe 'gulp' [
  in lang

  it should 'add at start' [
    [ ] $: block

    #foo block gulp

    "Novika makes moves cursor to the end automatically, and
     block cursor is taken into account when `=`ing."
    block [ foo ] assert=
  ]

  it should 'add at cursor' [
    [ 1 2 | 3 ] $: block

    #foo block gulp block [ 1 2 foo | 3 ] assert=
  ]

  it should 'add at end' [
    [ 1 2 3 ] $: block

    #foo block gulp block [ 1 2 3 foo ] assert=
  ]
]

describe 'spit' [
  in lang

  it dies 'at start' [
    [ | 1 2 3 ] spit
  ]

  it should 'drop at cursor' [
    [ 1 2 | 3 ] $: block

    block spit 2enclose 2 [ 1 | 3 ] 2enclose assert=
  ]

  it should 'add at end' [
    [ 1 2 3 ] $: block

    block spit 2enclose [ 3 [ 1 2 ] ] assert=
  ]
]

describe '<<' [
  in lang

  it should 'add at start' [
    [ ] 1 << [ 1 ] assert=
  ]

  it should 'add at cursor' [
    [ 1 | 2 3 ] #foo << [ 1 foo | 2 3 ] assert=
  ]

  it should 'add at end' [
    [ 1 2 3 ] 4 << [ 1 2 3 4 ] assert=
  ]
]

describe '>>' [
  in lang

  it dies 'at start' [
    [ ] >>
  ]

  it should 'drop at cursor' [
    [ 1 2 3 ] $: b
    b 1 |to
    b >> 1 assert=
    b [ | 2 3 ] assert=
  ]

  it should 'drop at end' [
    [ 1 2 3 ] $: b
    b >> 3 assert=
    b [ 1 2 ] assert=
  ]
]

describe 'enclose' [
  in lang

  it should 'wrap a form in block' [
    1 enclose [ 1 ] assert=
  ]
]

describe '2enclose' [
  in lang

  it should 'wrap a pair of forms in block' [
    1 2 2enclose [ 1 2 ] assert=
  ]
]


describe 'first' [
  in lang

  it should 'leave first element' [
    [ [ ] first ] 'index out of bounds' assertDies
    [ 0 ] first 0 assert=
    [ 1 2 3 ] first 1 assert=
  ]
]


describe 'first?' [
  in lang

  it should 'leave first element (opt) and true/false' [
    [ [ ] first? ] vals [ false ] vals assert=
    [ [ 0 ] first? ] vals [ 0 true ] vals assert=
    [ [ 1 2 3 ] first? ] vals [ 1 true ] vals assert=
  ]
]


describe 'last' [
  in lang

  it should 'leave last element' [
    [ [ ] last ] 'index out of bounds' assertDies
    [ 0 ] last 0 assert=
    [ 1 2 3 ] last 3 assert=
  ]
]


describe 'last?' [
  in lang

  it should 'leave last element (opt) and true/false' [
    [ [ ] last? ] vals [ false ] vals assert=
    [ [ 0 ] last? ] vals [ 0 true ] vals assert=
    [ [ 1 2 3 ] last? ] vals [ 3 true ] vals assert=
  ]
]


describe 'startsWith?' [
  in lang

  it should 'check if block/quote starts with something' [
    '' '' startsWith? true assert=
    '' 'h' startsWith? false assert=
    'h' '' startsWith? true assert=

    'hello world' 'h' startsWith? true assert=
    'hello world' 'hello' startsWith? true assert=
    'hello world' 'world' startsWith? false assert=

    [ 1 2 3 ] 1 startsWith? true assert=
    [ 1 2 3 ] [ 1 2 ] startsWith? false assert=
    [ [ 1 2 ] 3 ] [ 1 2 ] startsWith? true assert=
    [ 1 2 3 ] 3 startsWith? false assert=

    [ 123 456 startsWith? ] '`startsWith?`: expected quote or block' assertDies
  ]
]


describe 'endsWith?' [
  in lang

  it should 'check if block/quote ends with something' [
    '' 123 endsWith? false assert=
    '' '' endsWith? true assert=
    '' 'h' endsWith? false assert=
    'h' '' endsWith? true assert=
    'hello' 'foo' endsWith? false assert=
    'hello' 'hello' endsWith? true assert=
    'hello' 'world' endsWith? false assert=
    'hello world' 'd' endsWith? true assert=
    'hello world' 'world' endsWith? true assert=
    'hello world' 'hello' endsWith? false assert=

    [ ] 0 endsWith? false assert=
    [ 0 ] 0 endsWith? true assert=
    [ 0 1 2 ] [ 1 2 ] endsWith? false assert=
    [ 0 [ 1 2 ] ] [ 1 2 ] endsWith? true assert=

    [ 123 456 endsWith? ] '`endsWith?`: expected quote or block' assertDies
  ]
]


describe 'surroundedBy?' [
  in lang

  it should 'check if block/quote starts and ends with something' [
    '' 123 456 surroundedBy? false assert=
    '' '' 456 surroundedBy? false assert=
    '' '' '' surroundedBy? true assert=
    'hello' '' '' surroundedBy? true assert=
    '[hello]' 'hello' '' surroundedBy? false assert=
    '[hello]' '' 'hello' surroundedBy? false assert=
    '[hello]' 'hello' 'hello' surroundedBy? false assert=
    '[hello]' '[' '' surroundedBy? true assert=
    '[hello]' '' ']' surroundedBy? true assert=
    '[hello]' '[' ']' surroundedBy? true assert=
    '[hello]' '[' ')' surroundedBy? false assert=
    '[hello]' '(' ']' surroundedBy? false assert=
    'hellohelloworld' 'hello' 'world' surroundedBy? true assert=
    '👨‍👧‍👦moonshine😼' '👨‍👧‍👦' '😼' surroundedBy? true assert=

    [ 1 2 3 ] 1 3 surroundedBy? true assert=

    [ 123 'x' 'y' surroundedBy? ] '`startsWith?`: expected quote or block' assertDies "nah"
  ]
]


describe '·>' [
  in lang

  it should 'function the same as \'befriend\'' [
    [ 100 $: x ] obj $: a
    [ 200 $: y ] obj $: b
    a ·> b ·> a drop

    a.x 100 assert=
    a.y 200 assert=

    b.x 100 assert=
    b.y 200 assert=

    a extendWith: [ 'Hello World' =: x ]

    a.x 'Hello World' assert=
    a.y 200 assert=

    b.x 'Hello World' assert=
    b.y 200 assert=
  ]
]


describe 'child' [
  in lang

  it should 'create empty child block' [
    [ 1 2 ] $: a a child $: b

    b empty? true assert=
    b parent a same? true assert=
  ]
]

describe '->' [
  in lang

  it should 'fetch the entry' [
    [ 200 $: x
      100 $: y

      [ x y + ] @: sum

      this
    ] open $: block

    block -> x 200 assert=
    block -> y 100 assert=
    block -> sum [ x y + ] assert=
    block -> sum open 300 assert=
  ]

  it should 'preserve lookup hierarchy' [
    100 $: x
    200 $: y

    [ 300 $: x [ x y + ] @: sum this ] open $: block

    block -> x 300 assert=
    block -> y 200 assert=
    block -> sum open 500 assert=
  ]

  it should 'allow (nested) block of names' [
    [ 100 $: x
      200 $: y ] obj $: point

    point -> [ ] [ ] assert=
    point -> [ x ] [ 100 ] assert=
    [ point -> [ z ] ] 'no value form for \'z\'' assertDies

    point -> [ x y ] [ 100 200 ] assert=
    point -> [ [ [ x ] ] [ y ] ] [ [ [ 100 ] ] [ 200 ] ] assert=
    [ point -> [ 100 x ] ] 'no value form for \'100\'' assertDies
  ]

  it dies 'when entry does not exist' [
    [ ] -> foo
  ]
]

describe 'entry:open' [
  in lang

  it should 'fetch /& open entry' [
    [ 200 $: x 100 $: y [ x y + ] @: sum this ] open $: block

    block this #x entry:open 200 assert=
    block this #y entry:open 100 assert=
    block this #sum entry:open 300 assert=
  ]

  it should 'preserve ahead' [
    [ $: bool [ ahead thru bool => [ 1 + ] ] @: bar: this ] @: block

    true block this #bar: entry:open 100 101 assert=
    false block this #bar: entry:open 100 100 assert=
  ]

  it dies 'when entry does not exist' [
    [ ] this #foo entry:open
  ]

  it should 'expect a readable store' [
    [ 1 . foobar ] 'bad type: decimal, expected: a readable store' assertDies
  ]
]

describe '.' [
  in lang

  "These are pretty much the same as 'entry:open' but without
   the `this`es:"

  it should 'fetch /& open entry' [
    [ 200 $: x 100 $: y [ x y + ] @: sum this ] open $: block

    block . x 200 assert=
    block . y 100 assert=
    block . sum 300 assert=
  ]

  it should 'preserve ahead' [
    [ $: bool [ ahead thru bool => [ 1 + ] ] @: bar: this ] @: block

    true block . bar: 100 101 assert=
    false block . bar: 100 100 assert=
  ]

  it dies 'when entry does not exist' [
    [ ] . foo
  ]
]

describe 'fetch:' [
  in lang

  it should 'ignore non-block forms' [
    'This is not a block!' #x fetch: [ 1 + ]

    stack empty? true assert=
  ]

  it should 'do nothing when entry does not exist' [
    [ ] #x fetch: [ 1 + ]

    stack empty? true assert=
  ]

  it should 'fetch when entry exists' [
    [ 100 $: x 200 $: y this ] open $: block

    #nil $: xVal
    #nil $: yVal

    block #x fetch: [ =: xVal ]
    block #y fetch: [ =: yVal ]

    xVal 100 assert=
    yVal 200 assert=
  ]

  it should 'not evaluate openers' [
    [ 100 $: x 200 $: y [ x y + ] @: sum this ] open $: block

    #nil $: sumVal

    block #sum fetch: [ =: sumVal ]

    sumVal [ x y + ] assert=
    sumVal open 300 assert=
  ]
]

describe 'extendWith' [
  in lang

  it should 'open the body block' [
    [ 100 $: x ] obj $: b
    [ b extendWith: [ 'opened' die ] ] 'opened' assertDies

    stack count 0 assert=
  ]

  it should 'merge dictionaries of source and body blocks' [
    [ 100 $: x ] obj $: b

    b.x 100 assert=
    [ b.y ] 'no value form for \'y\'' assertDies

    [ b extendWith: [ 200 $: y ] ] vals $: s
    (s count) 1 assert=
    (s top) b same? true assert=

    b.x 100 assert=
    b.y 200 assert=

    stack count 0 assert=
  ]

  it should 'allow to submit into source block' [
    [ 100 $: x ] obj $: b
    b.x 100 assert=

    b extendWith: [ 200 =: x ] b same? true assert=
    b.x 200 assert=

    stack count 0 assert=
  ]

  it should 'allow to overwrite entry type' [
    [ [ 1 2 + ] $: x ] obj $: b
    b.x [ 1 2 + ] assert=

    b extendWith: [ [ 3 4 + ] @: x ] b same? true assert=
    b.x 7 assert=

    stack count 0 assert=
  ]

  it should 'keep body block parent/friends the same' [
    [ 100 $: x ] obj $: a
    [ 200 $: y ] obj $: b

    123 $: z

    [ x $: a
      y $: b
      z $: c ] $: bodyBlock

    bodyBlock ·> a drop
    bodyBlock ·> b drop

    [ 'a' $: a
      'b' $: b
      'c' $: c
      'd' $: d ] obj extendWith: bodyBlock $: foo

    foo.a 100 assert=
    foo.b 200 assert=
    foo.c 123 assert=
    foo.d 'd' assert=

    stack count 0 assert=
  ]

  it should 'extend with body block prototype\'s entries' [
    [ ] extendWith: [ 100 $: x
                      200 $: y ] $: bb

    bb.x 100 assert=
    bb.y 200 assert=

    [ 'foo' $: c ] obj extendWith: bb $: foo1
    foo1.x 100 assert=
    foo1.y 200 assert=
    foo1.c 'foo' assert=

    [ x y + $: c ] bb resub

    [ 'foo' $: c ] obj extendWith: bb $: foo2
    foo2.x 100 assert=
    foo2.y 200 assert=
    foo2.c 300 assert=

    stack count 0 assert=
  ]

  it should 'run example from docs' [
    [ 100 $: x ] obj $: a
    [ 200 $: y ] obj $: b

    a ·> b ·> a drop

    [ a.x a.y ] vals [ 100 200 ] assert=
    [ b.x b.y ] vals [ 100 200 ] assert=

    a extendWith: [ [ y y * ] @: x ] drop
    b extendWith: [ 4 =: y ] drop

    [ a.x a.y ] vals [ 16 4 ] assert=
    [ b.x b.y ] vals [ 16 4 ] assert=

    b extendWith: [ 100 $: y ] drop

    [ a.x a.y ] vals [ 10000 100 ] assert=
    [ b.x b.y ] vals [ 10000 100 ] assert=

    stack count 0 assert=
  ]
]


describe 'extend:' [
  in lang

  it should 'work like \'extendWith:\' but keep the stack clean' [
    [ 100 $: x ] obj $: a
    [ 200 $: y ] obj $: b

    a ·> b ·> a drop

    [ a.x a.y ] vals [ 100 200 ] assert=
    [ b.x b.y ] vals [ 100 200 ] assert=

    a extend: [ [ y y * ] @: x ]
    b extend: [ 4 =: y ]

    [ a.x a.y ] vals [ 16 4 ] assert=
    [ b.x b.y ] vals [ 16 4 ] assert=

    b extend: [ 100 $: y ]

    [ a.x a.y ] vals [ 10000 100 ] assert=
    [ b.x b.y ] vals [ 10000 100 ] assert=
  ]
]


describe '|slideRight' [
  in lang

  it should 'do nothing if empty list block' [
    [ ] [ 1 + ] |slideRight [ ] assert=
  ]

  it should 'modify the original block' [
    [ | 1 2 3 ] $: a
    a [ 1 + ] |slideRight a same? true assert=
    a [ 2 3 4 ] assert=
  ]

  it should 'start at cursor' [
    [ 1 | 2 3 ] [ 1 + ] |slideRight [ 1 3 4 ] assert=
  ]

  it should 'handle insertion before' [
    [ 1 | 2 3 ] [ #boo swap 1 + ] |slideRight
    [ 1 boo 3 boo 4 ] assert=
  ]

  it should 'handle insertion after' [
    [ 1 | 2 3 ] [ 1 + #boo ] |slideRight
    [ 1 3 boo 4 boo ] assert=
  ]

  it should 'handle deletion' [
    [ | 1 2 3 ] [ drop ] |slideRight [ ] assert=
  ]

  it should 'work with multiple items' [
    [ 1 | 2 3 ] [ + ] |slideRight [ 6 ] assert=
  ]

  it should 'support cursor movement' [
    [ | 1 2 3 ] [ <| 'Hi!' |> ] |slideRight
    [ 'Hi!' 1 'Hi!' 2 'Hi!' 3 ] assert=
  ]

  it should 'support reusing results from old iterations' [
    "Add sum of previous elements to the current element."
    [ 3 | 4 5 6 ] [ over + ] |slideRight [ 3 7 12 18 ] assert=
  ]

  it should 'support next' [
    [ | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ] $: numbers

    numbers |-> [
      dup 15 /?  => [ drop 'FizzBuzz' next ]
      dup  5 /?  => [ drop 'Buzz' next ]
      dup  3 /?  => [ drop 'Fizz' next ]
      toQuote
    ]

    [ '1' '2' 'Fizz' '4' 'Buzz' 'Fizz' '7' '8' 'Fizz' 'Buzz' '11' 'Fizz'
      '13' '14' 'FizzBuzz' '16' '17' 'Fizz' '19' 'Buzz' 'Fizz' '22' '23'
      'Fizz'  'Buzz' ]

    assert=
  ]

  it should 'support break' [
    [ | 1 2 3 4 5 6 7 8 ] $: numbers

    numbers |-> [
      dup 5 > => [ break ]
      100 +
    ]

    "As you can see, break leaves the cursor AFTER the item
     that failed to match."
    [ 101 102 103 104 105 6 | 7 8 ] assert=
  ]

  it dies 'upon underflow' [
    [ | 1 2 3 ] [ swap ] |slideRight
  ]
]

describe '|~>' [
  in lang

  it should 'work like |slideRight but remember cursor position' [
    [ ] |~> [ ] [ ] assert=
    [ ] |~> [ 1 + ] [ ] assert=
    [ 1 2 3 ] |~> [ ] [ 1 2 3 ] assert=
    [ 1 | 2 3 ] |~> [ 1 + ] [ 1 | 3 4 ] assert=

    [ 1 2 | 3 ] $: blk
    [ blk |~> drop ] vals [ blk ] vals assert=
    blk [ 1 2 ] assert=
    blk |~> [ 4 ] [ 1 2 ] assert=
    blk 1 |to
    blk |~> [ drop 3 4 ] [ 1 | 3 4 ] assert=
    blk |~> [ 1 + ] [ 1 | 4 5 ] assert=
  ]

  it should 'support next and break' [
    [ 0 1 2 3 | 4 5 6 7 8 9 10 ] $: xs

    xs |~> [
      "Yeah yeah I know this is some random bullshit"
      [ even? next
            9 break
          [ ] [ 2 * |> 1 + <| ]
      ] choose
    ]

    xs [ 0 1 2 3 | 4 10 14 8 8 9 10 ] assert=
  ]
]

describe '||~>' [
  in lang

  it should 'work like |~> but set cursor to 0 first' [
    [ ] ||~> [ ] [ ] assert=
    [ ] ||~> [ 1 + ] [ ] assert=
    [ 1 2 3 ] ||~> [ ] [ 1 2 3 ] assert=
    [ 1 | 2 3 ] ||~> [ 1 + ] [ 2 | 3 4 ] assert=

    [ 1 2 | 3 ] $: blk
    blk ||~> drop
    blk [ ] assert=
    blk ||~> [ 4 ] [ ] assert=
    blk [ 1 2 3 ] shove*
    blk 2 |to
    blk ||~> [ drop 3 4 ] [ 3 4 | 3 4 3 4 ] assert=
    blk ||~> [ 1 + ] [ 4 5 | 4 5 4 5 ] assert=
  ]

  it should 'support next and break' [
    [ 0 1 2 3 | 4 5 6 7 8 9 10 ] $: xs

    xs ||~> [
      "Yeah yeah I know this is some random bullshit too"
      [ even? next
            7 break
          [ ] [ 2 * |> 1 + <| ]
      ] choose
    ]

    xs [ 0 2 6 4 | 4 10 7 7 8 9 10 ] assert=
  ]
]

describe '|slideLeft' [
  in lang

  it should 'do nothing if empty list block' [
    [ ] [ 1 + ] |slideLeft [ ] assert=
  ]

  it should 'modify the original block' [
    [ 1 2 3 ] $: a
    a [ 1 + ] |slideLeft a same? true assert=
    a [ | 2 3 4 ] assert=
  ]

  it should 'start at cursor' [
    [ 1 2 | 3 ] [ 1 + ] |slideLeft [ | 2 3 3 ] assert=
  ]

  it should 'handle insertion before' [
    [ 1 2 | 3 ] [ #boo #foo rot 1 + ] |slideLeft
    [ | boo foo 2 boo foo 3 3 ] assert=
  ]

  it should 'handle insertion after' [
    [ 1 2 | 3 ] [ 1 + #boo ] |slideLeft
    [ | 2 boo 3 boo 3 ] assert=
  ]

  it should 'handle deletion' [
    [ 1 2 3 ] [ drop ] |slideLeft [ ] assert=
  ]

  it should 'work with multiple items & support break' [
    [ 1 2 3 ] [ stack |at 1 = => [ break ] + ] |slideLeft [ 6 ] assert=
  ]

  it should 'support cursor movement' [
    [ 1 2 3 ] [ <| 'Hi!' |> ] |slideLeft
    [ | 'Hi!' 1 'Hi!' 2 'Hi!' 3 ] assert=
  ]

  it should 'support next' [
    [ 1 2 3 4 5 ] <-| [
      dup 3 > => [ next ]
      1 +
    ] [ | 2 3 4 4 5 ] assert=
  ]

  it should 'support break' [
    [ 1 2 3 4 5 ] <-| [
      dup 3 < => [ break ]
      1 +
    ] [ 1 2 | 4 5 6 ] assert=
  ]

  it dies 'upon underflow' [
    [ 1 2 3 ] [ swap ] |slideLeft
  ]
]

describe 'eachWithIndex' [
  in lang

  it should 'do nothing if empty list block' [
    [ ] eachWithIndex: [ 1 + ]

    stack empty? true assert=
  ]

  it should 'iterate over whole block with cursor at end' [
    [ ] $: items [ ] $: indices

    [ 2 3 4 ] eachWithIndex: [ items gulp indices gulp ]

    [ 2 3 4 ] items   assert=
    [ 0 1 2 ] indices assert=
  ]

  it should 'iterate over whole block with cursor at start' [
    [ ] $: items [ ] $: indices

    [ | 2 3 4 ] eachWithIndex: [ items gulp indices gulp ]

    [ 2 3 4 ] items   assert=
    [ 0 1 2 ] indices assert=
  ]

  it should 'iterate over whole block with cursor anywhere else' [
    [ ] $: items [ ] $: indices

    [ 2 | 3 4 ] eachWithIndex: [ items gulp indices gulp ]

    [ 2 3 4 ] items   assert=
    [ 0 1 2 ] indices assert=
  ]

  it should 'leave cursor intact' [
    [ 2 | 3 4 ] $: a
    a eachWithIndex: [ ]
    a |at 1 assert=
  ]

  it should 'not modify block &/ with leftovers' [
    [ 2 3 4 ] $: a
    a eachWithIndex: [ 1 + 100 ]
    a [ 2 3 4 ] assert=
  ]

  it should 'support next and break' [
    [ ] $: items

    [ 2 7 8 7 1 9 3 4 5 6 ] eachWithIndex: [ $: item $: index
      item even? => [ next ]
      item 3 /?  => [ break ]
      items index item 2enclose shove
    ]

    items [ [ 1 7 ] [ 3 7 ] [ 4 1 ] ] assert=
  ]
]

describe 'each' [
  in lang

  it should 'do nothing if empty list block' [
    [ ] each: [ 1 + ]

    stack empty? true assert=
  ]

  it should 'iterate over whole block with cursor at end' [
    [ ] $: items

    [ 2 3 4 ] each: [ items gulp ]
    [ 2 3 4 ] items assert=
  ]

  it should 'iterate over whole block with cursor at start' [
    [ ] $: items

    [ | 2 3 4 ] each: [ items gulp ]
    [ 2 3 4 ] items assert=
  ]

  it should 'iterate over whole block with cursor anywhere else' [
    [ ] $: items

    [ 2 | 3 4 ] each: [ items gulp ]
    [ 2 3 4 ] items assert=
  ]

  it should 'leave cursor intact' [
    [ 2 | 3 4 ] $: a
    a each: [ ]
    a |at 1 assert=
  ]

  it should 'not modify block &/ with leftovers' [
    [ 2 3 4 ] $: a
    a each: [ 1 + 100 ]
    a [ 2 3 4 ] assert=
  ]

  it should 'support next and break' [
    [ ] $: items

    [ 2 7 8 7 1 9 3 4 5 6 ] each: [ $: item
      item even? => [ next ]
      item 3 /?  => [ break ]
      items item shove
    ]

    items [ 7 7 1 ] assert=
  ]
]

describe 'pairs' [
  in lang

  it should 'do nothing if list block is empty' [
    [ ] pairs: [ + ]

    stack empty? true assert=
  ]

  it dies 'when count is odd' [
    [ 1 2 3 ] pairs: [ + ]
  ]

  it should 'call action block with each pair as stack' [
    [ ] $: stacks

    [ 1 2 3 4 ] pairs: [ stack shallowCopy stacks gulp ]

    stacks [
      [ 1 2 ]
      [ 3 4 ]
    ] assert=
  ]

  it should 'leave cursor intact' [
    [ ] $: stacks

    [ 1 2 | 3 4 ] $: a
    a pairs: [ stack shallowCopy stacks gulp ]
    a |at 2 assert=
    stacks [ [ 1 2 ] [ 3 4 ] ] assert=
  ]

  it should 'not modify block when pair populated stack is modified' [
    [ 1 2 3 4 ] $: a
    a pairs: [ 1 + ]
    a [ 1 2 3 4 ] assert=
  ]

  it should 'support next and break' [
    [ 1 2 3 4 5 6 7 7 3 4 ] $: a

    [ ] $: visited

    a pairs: [ $: 2i $: 1i
      1i 2i * odd? => [ break ]
      1i 2i + 4 >  => [ visited 0 shove next ]
      visited 1i 2i 2enclose shove
    ]

    visited [ [ 1 2 ] 0 0 ] assert=
  ]
]


describe 'mapPairs' [
  in lang

  it should 'leave empty list as is' [
    [ ] mapPairs: [ ] [ ] assert=

    stack empty? true assert= "stack hygiene"
  ]

  it should 'leave list as is if block is empty' [
    [ 1 2 3 4 5 6 7 8 9 10 ] mapPairs: [ ] [ 1 2 3 4 5 6 7 8 9 10 ] assert=

    stack empty? true assert= "stack hygiene"
  ]

  it should 'map over pairs' [
    (1 to: 10 mapPairs: +) product 65835 assert=

    stack empty? true assert= "stack hygiene"
  ]

  it should 'die if no of items is odd' [
    [ [ 1 ] mapPairs: [ ] ] 'for mapPairs to work, there should be an even count of items in block' assertDies
    [ [ 1 2 3 ] mapPairs: [ ] ] 'for mapPairs to work, there should be an even count of items in block' assertDies
  ]

  it should 'use result block as the stack' [
    [ ] $: stacks

    1 to: 10 mapPairs: [ stack shallowCopy stacks gulp ]

    stacks [
      [ 1 2 ]
      [ 1 2 3 4 ]
      [ 1 2 3 4 5 6 ]
      [ 1 2 3 4 5 6 7 8 ]
      [ 1 2 3 4 5 6 7 8 9 10 ]
    ] assert=
  ]

  it should 'support next and break' [
    [ 1 1 2 3 3 1 2 2 2 1 2 100 2 1 3 4 ] mapPairs: [
      "only allow EVEN followed by ODD"
      dup 100 >= => [ 2drop break ]
      2dup bi*: even? odd? and not => [ 2drop next ]

      +
    ] [ 5 3 ] assert=

    stack empty? true assert= "stack hygiene"
  ]
]


describe 'consPairs' [
  in lang

  it should 'do nothing if list block is empty' [
    [ ] consPairs: [ + ]

    stack empty? true assert=
  ]

  it should 'do nothing if one item in list block' [
    [ 1 ] consPairs: [ + ]

    stack empty? true assert=
  ]

  it should 'leave cursor intact' [
    [ ] $: stacks
    [ 1 2 | 3 4 ] $: a
    a consPairs: [ stack shallowCopy stacks gulp ]
    a |at 2 assert=
    stacks [ [ 1 2 ] [ 2 3 ] [ 3 4 ] ] assert=
  ]

  it should 'support even number of items' [
    [ ] $: items
    [ 1 2 3 4 ] consPairs: [ + items gulp ]
    items [ 3 5 7 ] assert=
  ]

  it should 'support odd number of items' [
    [ ] $: items
    [ 1 2 3 ] consPairs: [ + items gulp ]
    items [ 3 5 ] assert=
  ]

  it should 'support next and break' [
      [ ] $: items
    false $: went

    [ 1 2 3 4 5 6 ] consPairs: [
      2dup * 10 > => [ break ]
      + items gulp
      next
      true =: went
    ]

    items [ 3 5 ] assert=
    went false assert=
  ]
]


describe 'mapConsPairs' [
  in lang

  it should 'leave empty list as is' [
    [ ] mapConsPairs: [ ] [ ] assert=

    stack empty? true assert= "stack hygiene"
  ]

  it should 'leave list as is if block is empty' [
    [ 1 2 3 4 5 6 7 8 9 10 ] mapConsPairs: [ ] [ 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 ] assert=

    stack empty? true assert= "stack hygiene"
  ]

  it should 'do nothing with 1 item in the block' [
    [ 1 ] mapConsPairs: [ 'xyzzy' die ] [ ] assert=

    stack empty? true assert= "stack hygiene"
  ]

  it should 'map over pairs' [
    (1 to: 10 mapConsPairs: +) product 654729075 assert=

    stack empty? true assert= "stack hygiene"
  ]

  it should 'use result block as the stack' [
    [ ] $: stacks

    1 to: 10 mapConsPairs: [ stack shallowCopy stacks gulp ]

    stacks [
      [ 1 2 ]
      [ 1 2 2 3 ]
      [ 1 2 2 3 3 4 ]
      [ 1 2 2 3 3 4 4 5 ]
      [ 1 2 2 3 3 4 4 5 5 6 ]
      [ 1 2 2 3 3 4 4 5 5 6 6 7 ]
      [ 1 2 2 3 3 4 4 5 5 6 6 7 7 8 ]
      [ 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 ]
      [ 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 ]
    ] assert=
  ]

  it should 'support next and break' [
    1 to: 10 mapConsPairs: [
      2dup bi*: even? odd? and not => [ 2drop next ]

      * dup 42 = => [ drop break ]
    ] [ 6 20 ] assert=

    stack empty? true assert= "stack hygiene"
  ]
]


describe 'map' [
  in lang

  it should 'do nothing if list block is empty' [
    [ ] map: [ 1 + ] [ ] assert=
  ]

  it should 'not change original block' [
    [ 1 2 3 ] $: a
    a map: [ 1 + ] [ 2 3 4 ] assert=
    a [ 1 2 3 ] assert=
  ]

  it should 'leave cursor intact' [
    [ 1 | 2 3 ] $: a
    a map: [ 1 + ] [ 2 3 4 ] assert=
    a |at 1 assert=
  ]

  it should 'support break and next where next means don`t keep if stack empty' [
    [ 1 101 2 3 200 4 1000 5 1001 2 3 ] $: a
    a map: [ $: n
      n 1000 > => [ break ]
      n 100 > => [ next ]
      n 1 +
    ] [ 2 3 4 5 6 ] assert=
  ]
]

describe 'only' [
  in lang

  it should 'do nothing if list block is empty' [
    [ ] [ 100 > ] only [ ] assert=
  ]

  it should 'keep if action block is empty' [
    [ 1 2 3 ] [ ] only [ 1 2 3 ] assert=
  ]

  it should 'select values for which action block leaves truthy' [
    [ 1 100 2 300 4 600 10 ] only: [ 100 > ] [ 300 600 ] assert=
  ]

  it should 'reject values for which action block leaves false' [
    [ 1 100 2 300 4 600 10 ] only: [ false ] [ ] assert=
  ]

  it should 'not modify original block' [
    [ 1 2 3 ] $: a
    a only: [ 1 > ] $: b
    b [ 2 3 ] assert=
    a [ 1 2 3 ] assert=
  ]

  it should 'leave cursor intact' [
    [ 1 | 2 3 ] $: a
    a only: [ 1 > ] [ 2 3 ] assert=
    a |at 1 assert=
  ]

  it should 'support next & break where next means don`t keep if stack empty' [
    [ 1 101 2 3 200 4 1000 5 1001 2 3 ] $: a
    a only: [ $: n
      n 1000 > => [ break ]
      n 100 > => [ next ]
      n 1 + 4 <=
    ] [ 1 2 3 ] assert=
  ]
]

describe 'reduce' [
  in lang

  it should 'leave memo if list block is empty' [
    [ ] [ + ] 0 reduce 0 assert=
  ]

  it should 'call block for one value' [
    false $: status
    [ 1 ] [ true =: status + ] 0 reduce 1 assert=
    status true assert=
  ]

  it should 'call block and reduce multiple values' [
    [ 1 2 3 4 5 ] [ * ] 1 reduce 120 assert=
    [ 'Hellope, ' 'Europe!' ' ' 'Huh?' ] [ stitch ] '' reduce 'Hellope, Europe! Huh?' assert=
  ]

  it should 'reduce stack' [
    [ 1 2 3 4 5 ] $: stackBlock

    stackBlock [ stack [ * ] 1 reduce ] hydrate
    stackBlock [ 120 ] assert=
  ]

  it should 'reduce stack with cursor at some other position' [
    [ 1 2 3 4 | 5 ] $: stackBlock

    stackBlock [ stack [ * ] 1 reduce ] hydrate
    stackBlock [ 24 | 5 ] assert=
  ]

  it should 'support next' [
    [ 1 2 3 4 5 ] [ dup odd? => [ drop "memo left here" next ] + ] 0 reduce 6 assert=
  ]

  it should 'support break' [
    [ 1 1 7 3 2 3 4 5 ] [ dup even? => [ break ] + ] 0 reduce 12 assert=
  ]

  it should 'support next on stack with cursor at some other position' [
    [ 1 2 3 4 5 | 6 7 8 9 ] $: stackBlock

    stackBlock [ stack [ dup odd? => [ drop "memo left here" next ] + ] 0 reduce ] hydrate
    stackBlock [ 6 | 6 7 8 9 ] assert=
  ]


  it should 'support break on stack with cursor at some other position' [
    [ 1 1 7 3 2 3 4 5 | 734 92 6 2 764 ] $: stackBlock

    stackBlock [ stack [ dup even? => [ break ] + ] 0 reduce ] there
    [ 12 | 734 92 6 2 764 ] assert=
  ]
]

describe 'amount' [
  in lang

  it should 'leave zero for empty block' [
    [ ] # [ even? ] 0 assert=
  ]

  it should 'provide proper stack to action block' [
    [ ] $: stacks
    [ 1 2 3 4 ] # [ stack shallowCopy stacks gulp ] 4 assert=
    stacks [ [ 1 ] [ 2 ] [ 3 ] [ 4 ] ] assert=
  ]

  it should 'count all with empty action block' [
    [ 1 2 3 ] # [ ] 3 assert=
  ]

  it should 'support single item list' [
    [ 1 ] # [ even? ] 0 assert=
    [ 4 ] # [ even? ] 1 assert=
  ]

  it should 'support multi item list' [
    [ 1 2 3 4 ] # [ even? ] 2 assert=
  ]

  it should 'support break and next' [
    [ 1 2 3 4 5 3 foo 5 6 7 8 ] # [ $: n
      n #foo = => [ break ]
      n even?  => [ false next ]
      n 1 + 3 >
    ] 3 assert=
  ]
]

describe 'all?' [
  in lang

  it should 'leave true for empty list' [
    [ ] [ ] all? true assert=
  ]

  it should 'leave true for empty action block' [
    [ 1 2 3 ] [ ] all? true assert=
  ]

  it should 'leave proper result' [
    [ 1 2 3 4 ] [ even? ] all? false assert=
    [ 2 4 6 8 ] [ even? ] all? true assert=
    [ 101 2 3 4 ] [ 100 < ] all? false assert=
  ]

  it should 'have the infix version all:' [
    [ 1 2 3 4 ] all: even? false assert=
    [ 1 2 3 4 ] all: [ 100 < ] true assert=
  ]

  it should 'die when using break/next' [
    [ [ 1 2 3 4 ] [ next ] all? ] 'definition for next not found in the enclosing block(s)' assertDies
    [ [ 1 2 3 4 ] [ break ] all? ] 'definition for break not found in the enclosing block(s)' assertDies
  ]
]

describe 'any?' [
  in lang

  it should 'leave false for empty list' [
    [ ] [ ] any? false assert=
  ]

  it should 'leave true for empty action block' [
    [ 1 2 3 ] [ ] any? true assert=
  ]

  it should 'leave proper result' [
    [ 1 2 3 4 ] [ even? ] any? true assert=
    [ 2 4 6 8 ] [ odd? ] any? false assert=
    [ 101 2 3 4 ] [ 100 < ] any? true assert=
  ]

  it dies 'when using next' [
    [ 1 2 3 4 ] [ next ] any?
  ]

  it dies 'when using break' [
    [ 1 2 3 4 ] [ break ] any?
  ]
]

describe 'zip' [
  in lang

  it should 'zip two empty blocks into an empty block' [
    [ ] [ ] zip [ ] assert=
  ]

  it should 'zip with equal amount of items' [
    [ 1 ] [ 2 ] zip [ [ 1 2 ] ] assert=
    [ 1 2 ] [ 3 4 ]  zip [ [ 1 3 ] [ 2 4 ] ] assert=
    [ 1 2 3 ] [ 3 4 5 ] zip  [ [ 1 3 ] [ 2 4 ] [ 3 5 ] ] assert=
  ]


  it dies 'when zipping with unequal amount of items (holes)' [
    [ 1 2 ] [ 3 ] zip
  ]
]


describe 'zip:' [
  in lang

  it should 'work as an infix for `zip`' [
    [ [ ] zip: [ ] ] vals [ [ ] ] assert=
    [ [ ] zip: [ ] 1 2 3 ] vals [ [ ] 1 2 3 ] assert=
    [ 1 2 ] zip: [ 3 4 ] [ [ 1 3 ] [ 2 4 ] ] assert=
    [ 1 2 ] zip: [ x y ] [ [ 1 x ] [ 2 y ] ] assert=
    [ x y ] zip: [ a b ] [ [ x a ] [ y b ] ] assert=
  ]

  it should 'work as an infix for `zipWithDefault`' [
    [ a b ] zip: [ 'Hi!' ] withDefault: 0 [ [ a 'Hi!' ] [ b 0 ] ] assert=
    [ [ ] zip: [ ] withDefault: ] 'thru out of bounds' assertDies
    [ [ ] zip: [ ] withDefault: 100 ] vals [ [ ] ] assert=
    [ [ ] zip: [ ] withDefault: 100 1 2 3 ] vals [ [ ] 1 2 3 ] assert=
  ]
]


describe 'zipWithDefault' [
  in lang

  it should 'work for empty blocks' [
    [ ] [ ] #hole zipWithDefault [ ] assert=
  ]

  it should 'work when there are no holes' [
    [ 1 2 ] [ 3 4 ] #hole zipWithDefault [ [ 1 3 ] [ 2 4 ] ] assert=
  ]

  it should 'work when there are holes on the right' [
    [ 1 2 ] [ 3 ] #hole zipWithDefault [ [ 1 3 ] [ 2 hole ] ] assert=
  ]

  it should 'work when there are holes on the right' [
    [ 1 ] [ 3 4 ] #hole zipWithDefault [ [ 1 3 ] [ hole 4 ] ] assert=
  ]

  it should 'work with either list empty' [
    [ ] [ 1 2 ] #hole zipWithDefault [ [ hole 1 ] [ hole 2 ] ] assert=
    [ 1 2 ] [ ] #hole zipWithDefault [ [ 1 hole ] [ 2 hole ] ] assert=
  ]
]

describe 'conjure/here' [
  in lang

  it should 'accept decimal, bool, etc.' [
    0 here 0 assert=
    true here true assert=
    'hello' here 'hello' assert=
  ]

  it should 'leave definitions of words' [
    [ 1 2 3 4 ] $: a
    a $: b
    #b here a same? true assert=
  ]

  it should 'peel off a # from quoted words' [
    ###foo here ##foo assert=
    ##foo here #foo assert=
  ]

  it should 'recurse into blocks' [
    0 $: a
    1 $: b
    2 $: c
    3 $: d

    [ [ [ [ a 'foo' ] b 1 ] c 'bar' d ] #baz ] here
    [ [ [ [ 0 'foo' ] 1 1 ] 2 'bar' 3 ]  baz ]
    assert=
  ]

  it should 'instantiate blocks it encounters' [
    100 $: a
    200 $: b
    [ "Foo" [ "Some documentation..." 1 a | b ] [ 2 ] [ 3 ] ] $: foos

    foos 0 fromLeft extend: [ 'foo' $: quux ]
    foos 0 fromRight extend: [ 'bar' $: fuux ]

    foos here $: hereResult

    hereResult map: toTape [ [ 1 100 | 200 ] [ 2 ] [ 3 ] ] assert=

    hereResult parent foos same? true assert=

    hereResult desc 'Foo' assert=
    hereResult 0 fromLeft desc 'Some documentation...' assert=

    hereResult 0 fromLeft . quux 'foo' assert=
    hereResult 0 fromRight . fuux 'bar' assert=

    (hereResult 0 fromLeft parent) (foos 0 fromLeft) same? true assert=
    (hereResult 1 fromLeft parent) (foos 1 fromLeft) same? true assert=
    (hereResult 2 fromLeft parent) (foos 2 fromLeft) same? true assert=
  ]

  it dies 'on undefined words' [
    foo here
  ]

  it should 'trigger word trap when word is undefined' [
    [ toQuote 1 sliceQuoteAt nip ] @: __trap__
    foobar here 'oobar' assert=
  ]

  it should 'copy (and therefore preserve) openers' [
    [ 1 + ] @: 1+
    [ 2 + ] @: 2+

    100 1+ 101 assert=
    100 2+ 102 assert=

    "here creates copy"
    [ 1+ 2+ ] here open "Resolve in current block"
    [ @{ incBy1 incBy2 } this ] "Redefine under different names in another block"
    open $: preserved

    "-> does not create copy"
    [ (this -> 1+) (this -> 2+) ] open
    [ @{ incBy1 incBy2 } this ]
    open $: unpreserved

    preserved -> [ incBy1 incBy2 ] [ 1+ 2+ ] here assert=
    unpreserved -> [ incBy1 incBy2 ] [ 1+ 2+ ] here assert=

    (preserved -> incBy1) (this -> 1+) same? false assert=
    (preserved -> incBy2) (this -> 2+) same? false assert=

    (unpreserved -> incBy1) (this -> 1+) same? true assert=
    (unpreserved -> incBy2) (this -> 2+) same? true assert=

    "modify block"
    (this -> 1+) [ <| drop 100 |> ] there

    100 1+ 200 assert=
    100 preserved.incBy1 101 assert=
    100 unpreserved.incBy1 200 assert=
  ]
]

describe 'minmax' [
  in lang

  it dies 'when block is empty' [
    [ ] minmax
  ]

  it dies 'when items are not decimals' [
    [ foo ] minmax
  ]

  it should 'leave same result when block is count 1' [
    [ 100 ] minmax stack shallowCopy [ 100 100 ] assert=
  ]

  it should 'leave proper result for > 1 items in block' [
    [ 100 200 5 300 405 ] minmax stack shallowCopy [ 5 405 ] assert=
  ]

  it should 'handle blocks which implement __decimal__' [
    [ -101 $: __decimal__ this ] open $: a
    [ 500 $: __decimal__ this ] open $: b

    "There is no good way to do this right now unfortunately..."
    [ -100 100 ] [ <| a |> b ] there

    minmax

    "Note how minmax still returns a, b, not their numeric values.
     I don't know whether this is what's expected."
    stack shallowCopy a b 2enclose assert=
  ]
]

describe 'min' [
  in lang

  it should 'leave min part of minmax' [
    [ 100 5 -100 2 3 -29 4 500 ] min -100 assert=
  ]
]

describe 'max' [
  in lang

  it should 'leave max part of minmax' [
    [ 100 5 -100 2 3 -29 4 500 ] max 500 assert=
  ]
]

describe 'sum' [
  in lang

  it should 'leave 0 when block is empty' [
    [ ] sum 0 assert=
  ]

  it should 'leave number when block has one number' [
    [ 100 ] sum 100 assert=
  ]

  it should 'leave sum otherwise' [
    [ 100 200 300 ] sum 600 assert=
  ]

  it should 'support blocks implementing __decimal__' [
    [ $: n [ n 1 + ] @: __decimal__ this ] @: foos

    100 foos "101"
    200 foos "201"
    2enclose

    300 foos "301"
    <<

    sum 603 assert=
  ]
]


describe 'product' [
  in lang

  it should 'leave 1 when block is empty' [
    [ ] product 1 assert=
  ]

  it should 'leave number when block has one form' [
    [ 234 ] product 234 assert=
  ]

  it should 'leave product of numbers' [
    [ 5 4 3 2 ] product 120 assert=
  ]

  it should 'support blocks implementing __decimal__' [
    [ $: n [ n 1 + ] @: __decimal__ this ] @: foos

    100 foos "101"
    200 foos "201"
    2enclose

    300 foos "301"
    <<

    product 6110601 assert=
  ]
]


describe 'minmaxBy' [
  in lang

  it dies 'when list block is empty' [
    [ ] [ ] minmaxBy
  ]

  it should 'leave integer minmax when transform is empty' [
    [ 1 2 3 ] [ ] minmaxBy stack shallowCopy [ 1 3 ] assert=
  ]

  it dies 'when transform is empty but values are non-numeric' [
    [ 'foo' 'barb' 'baz' ] [ ]  minmaxBy
  ]

  it should 'convert to numeric but leave original types' [
    [ 'AA' 'A' 'AAAAB' 'BAAAAAAB' 'Y' ] [ count ] minmaxBy

    stack shallowCopy [ 'A' 'BAAAAAAB' ] assert=
  ]

  it should 'support blocks implementing __decimal__ as Transform results' [
    [ $: s [ s count ] @: __decimal__ this ] @: toAwesomeBlock

    [ 'AA' 'A' 'AAAB' 'foo' 'barbeee' ] [ toAwesomeBlock ] minmaxBy

    stack shallowCopy [ 'A' 'barbeee' ] assert=
  ]

  it dies 'on next' [
    [ 1 2 3 ] [ break ] minmaxBy
  ]

  it dies 'on break' [
    [ 1 2 3 ] [ next ] minmaxBy
  ]
]

describe 'minBy' [
  in lang

  it should 'leave min from minmaxBy' [
    [ 'foo' 100 'x' 'buzzer' ] [ dup quote? => [ count ] ] minBy 'x' assert=
  ]
]

describe 'maxBy' [
  in lang

  it should 'leave max from minmaxBy' [
    [ 'foo' 100 'x' 'buzzer' ] [ dup quote? => [ count ] ] maxBy 100 assert=
  ]
]

describe 'sumBy' [
  in lang

  [ $: s [ s count ] @: __decimal__ this ] @: toAwesomeBlock

  it should 'leave zero when list block is empty' [
    [ ] [ ] sumBy 0 assert=
  ]

  it should 'leave one numeric if one numeric in list block' [
    [ 1 ] [ ] sumBy 1 assert=
    'foo' toAwesomeBlock enclose [ ] sumBy 3 assert=
  ]

  it should 'sum numerically if transform block is empty' [
    [ 1 2 3 ] [ ] sumBy 6 assert=
  ]

  it dies 'when transform block is empty but list block is non-numeric' [
    [ 1 'foo' #barbee 3 ] [ ] sumBy
  ]

  it should 'convert to numeric and leave numeric sum & have proper stack signature' [
    [ ] $: stacks

    [ 'foo' 'bar' 3 4 'x' ] [ stack shallowCopy stacks gulp dup quote? => [ count ] ] sumBy

    14 assert=

    stacks [
      [ 'foo' ]
      [ 'bar' ]
      [ 3 ]
      [ 4 ]
      [ 'x' ]
    ] assert=
  ]

  it should 'support blocks implementing __decimal__ as results/summands' [
    'foobee' toAwesomeBlock $: myBestBlock

    [ 'foo' 3 myBestBlock 4 'bar' 5 ] here [ dup quote? => [ toAwesomeBlock ] ] sumBy

    24 assert=
  ]

  it dies 'on break' [
    [ 1 2 3 ] [ break ] sumBy
  ]

  it dies 'on next' [
    [ 1 2 3 ] [ next ] sumBy
  ]
]


describe 'productBy' [
  in lang

  [ $: s [ s count ] @: __decimal__ this ] @: toAwesomeBlock

  it should 'leave 1 when list block is empty' [
    [ ] [ ] productBy 1 assert=
  ]

  it should 'leave one numeric if one numeric in list block' [
    [ 1 ] [ ] productBy 1 assert=
    'foo' toAwesomeBlock enclose [ ] productBy 3 assert=
  ]

  it should 'multiply numerically if transform block is empty' [
    [ 5 4 3 2 1 ] [ ] productBy 120 assert=
  ]

  it should 'die when transform block is empty but list block is non-numeric' [
    [ [ 1 'foo' #barbee 3 ] [ ] sumBy ] 'bad type: quote, expected: a decimal' assertDies
  ]

  it should 'convert to numeric and leave numeric sum & have proper stack signature' [
    [ ] $: stacks

    [ 'foo' 'bar' 3 4 'x' ] [ stack shallowCopy stacks gulp dup quote? => [ count ] ] productBy

    108 assert=

    stacks [
      [ 'foo' ]
      [ 'bar' ]
      [ 3 ]
      [ 4 ]
      [ 'x' ]
    ] assert=
  ]

  it should 'support blocks implementing __decimal__ as results/multiplicands' [
    'foobee' toAwesomeBlock $: myBestBlock

    [ 'foo' 3 myBestBlock 4 'bar' 5 ] here [ dup quote? => [ toAwesomeBlock ] ] productBy

    3240 assert=
  ]

  it should 'die when next/break is used' [
    [ [ 1 2 3 ] [ next ] productBy ] 'definition for next not found in the enclosing block(s)' assertDies
    [ [ 1 2 3 ] [ break ] productBy ] 'definition for break not found in the enclosing block(s)' assertDies
  ]
]


describe 'collect' [
  in lang

  it dies 'when amount is negative' [
    -1 collect: [ ]
  ]

  it should 'not call block & leave empty block when N = 0' [
    false $: called
    0 collect: [ true =: called ]
    called false assert=
  ]

  it should 'collect results of running block N items & have correct stack signature' [
    [ ] $: stacks

    4 collect: [ stack shallowCopy stacks gulp ] [ 0 1 2 3 ] assert=

    stacks [
      [ 0 ]
      [ 1 ]
      [ 2 ]
      [ 3 ]
    ] assert=
  ]

  it should 'execute block and leave block results' [
    100 $: n
    4 collect: [ n + dup =: n ] [ 100 101 103 106 ] assert=
  ]

  it should 'support next & break' [
    10 collect: [ $: n
      n even? => [ next ]
      n 5 > n odd? and => [ break ]
      n
    ] [ 1 3 5 ] assert=
  ]
]


describe 'compiledCollect' [
  in lang

  it should 'collect N times passing index' [
    10 compiledCollect: [ drop ] [ ] assert=
    10 compiledCollect: [ ] [ 0 1 2 3 4 5 6 7 8 9 ] assert=
    10 compiledCollect: [ 1 + ] [ 1 2 3 4 5 6 7 8 9 10 ] assert=
    10 compiledCollect: [ dup even? => drop ] [ 1 3 5 7 9 ] assert=

    5 compiledCollect: [
      stack shallowCopy
    ] [
      [ 0 ]
      [ 1 ]
      [ 2 ]
      [ 3 ]
      [ 4 ]
    ] assert=

    [ ] $: stacks

    5 compiledCollect: [
      stack shallowCopy stacks gulp
    ] drop

    stacks [
      [ 0 ]
      [ 1 ]
      [ 2 ]
      [ 3 ]
      [ 4 ]
    ] assert=
  ]
]


describe 'groupBy' [
  in lang

  it should 'leave empty block intact' [
    [ ] $: b
    b groupBy: [ ] $: gbyr
    gbyr empty? true assert=
    gbyr b same? false assert=
  ]

  it should 'support empty group' [
    [ 1 2 3 ] groupBy: [ ] $: gpd

    gpd [ [ 1 ] [ 2 ] [ 3 ] ] assert=
    gpd map: [.id] [ 1 2 3 ] assert=
  ]

  it should 'group by grouper form' [
    [ 1 2 3 ] groupBy: [ 1 > ] $: g1
    g1 [ [ 1 ] [ 2 3 ] ] assert=
    g1 map: [.id] [ false true ] here assert=

    [ 1 2 3 ] groupBy: [ 1 <= ] $: g2
    g2 [ [ 1 ] [ 2 3 ] ] assert=
    g2 map: [.id] [ true false ] here assert=

    [ 1 2 3 ] groupBy: [ 1 <= 'foo' 'bar' sel ] $: g3
    g3 map: [ dup .id 2enclose ]
      [ [ [ 1 ] 'foo' ] [ [ 2 3 ] 'bar' ] ] assert=
  ]
]


describe 'range' [
  in lang

  it should 'leave 1-number range when B = E' [
    0 to: 0 [ 0 ] assert=
  ]

  it should 'leave 1-number range when B < 0 = E < 0' [
    -100 to: -100 [ -100 ] assert=
  ]

  it should 'support [+B; +E]' [
    1 to: 10 [ 1 2 3 4 5 6 7 8 9 10 ] assert=
    10 to: 1 [ 10 9 8 7 6 5 4 3 2 1 ] assert=
  ]

  it should 'support [-B; +E]' [
    -5 to: 1 [ -5 -4 -3 -2 -1 0 1 ] assert=
  ]

  it should 'support [+B; -E]' [
    1 to: -5 [ 1 0 -1 -2 -3 -4 -5 ] assert=
  ]

  it should 'support [-B; -E]' [
    -5 to: -10 [ -5 -6 -7 -8 -9 -10 ] assert=
    -10 to: -5 [ -10 -9 -8 -7 -6 -5 ] assert=
  ]
]

describe 'from:' [
  in lang

  it should 'take a [B; E] slice of block' [
    [ [ ] from: 0 to: 0 ] vals [ [ ] ] assert=
    [ [ 1 2 3 4 ] from: 0 to: 3 ] vals [ [ 1 2 3 4 ] ] assert=
    [ 1 2 3 4 ] from: 1 to: 2 [ 2 3 ] assert=
    [ 1 2 3 4 ] from: 0 to: 200 [ 1 2 3 4 ] assert=
    [ 1 2 3 4 ] from: 100 to: 200 [ ] assert=
    [ 1 2 3 4 ] from: 1 to: 2 orphan? true assert=
  ]
]

describe 'join' [
  in lang

  it should 'leave empty quote on empty block' [
    [ ] join '' assert=
  ]

  it should 'join one quote' [
    [ 'foo' ] join 'foo' assert=
  ]

  it should 'join multiple quotes' [
    [ 'A' 'B' 'C' ] join 'ABC' assert=
  ]

  it should 'join stack' [
    [ 'A' 'B' 'C' ] $: stackBlock

    stackBlock [ stack join ] hydrate
    stackBlock [ 'ABC' ] assert=
  ]

  it should 'join stack at some other position' [
    [ 'A' 'B' 'C' | 'D' 'E' 'F' ] $: stackBlock
    stackBlock [ stack join  ] hydrate
    stackBlock [ 'ABC' | 'D' 'E' 'F' ] assert=
  ]

  it should 'enquote non-quotes' [
    [ [ 1 2 3 ] 'foo' 100 bar #baz ##boo ] join '[ 1 2 3 ]foo100bar#baz##boo' assert=
  ]
]

describe 'sepBy' [
  in lang

  it should 'sep empty block' [ [ ] ', ' sepBy '' assert= ]
  it should 'sep one-item block' [ [ 1 ] ', ' sepBy '1' assert= ]
  it should 'sep multi-item block' [
    [ 1 2 3 ] ', ' sepBy '1, 2, 3' assert=
  ]
  it should 'properly perform toQuote on items' [
    [ foo #foo true '3' ] ', ' sepBy 'foo, #foo, #true, 3' assert=
  ]
  it should 'sep empty stack' [
    stack ', ' sepBy '' assert=
  ]
  it should 'sep stack' [
    1 2 3 stack ', ' sepBy '1, 2, 3' assert=
  ]
]

describe 'concat!' [
  in lang

  it should 'concat two empty blocks' [
    [ ] $: a
    [ ] $: b
    a b concat! dup a same? true assert=
    a [ ] assert=
    b [ ] assert=
  ]

  it should 'concat with empty A block' [
    [ ] [ 1 2 3 ] concat! [ 1 2 3 ] assert=
  ]

  it should 'concat with empty B block' [
    [ 1 2 3 ] [ ] concat! [ 1 2 3 ] assert=
  ]

  it should 'concat if both non-empty' [
    [ 1 2 3 ] $: a
    a [ 4 5 6 ] concat! [ 1 2 3 4 5 6 ] assert=
  ]

  it should 'move the cursor in A block, but not B block' [
    [ 1 | 2 3 ] $: a
    [ 4 5 | 6 ] $: b
    a b concat!
    a [ 1 4 5 | 2 3 ] assert=
    b |at 2 assert=
  ]
]

describe 'concat' [
  in lang

  it should 'not modify A nor B block' [
    [ 1 2 3 ] $: a
    [ 4 5 6 ] $: b
    a b concat [ 1 2 3 4 5 6 ] assert=
    a [ 1 2 3 ] assert=
    b [ 4 5 6 ] assert=
  ]

  "TODO? Otherwise this is the same as concat! at least in core. Don't know
   if it's good or bad or worth it to copy tests like that, considering the
   language may change any minute."
]

describe 'toTape' [
  in lang

  it should 'leave tape block for block' [
    [ 1 2 3 ] $: a
    a #x 0 pushes

    a toQuote '[ 1 2 3 · ${x :: 0} ]' assert=

    a toTape $: aTape
    aTape [ 1 2 3 ] assert=
    aTape orphan? true assert=
    aTape ls [ ] assert=
  ]
]


describe '|afterOrToEnd?/|afterOrDie/|afterOrToEnd' [
  in lang

  it should 'put cursor |afterOrToEnd matching form' [
    [ 1 | 2 3 4 5 6 7 ] $: a
    [ a [ 6 = ] |afterOrToEnd? ] vals [ [ 2 3 4 5 ] true ] here assert=
    a |at 6 assert=

    a 1 |to
    [ a 6 |afterOrToEnd? ] vals [ [ 2 3 4 5 ] true ] here assert=
    a |at 6 assert=

    a 1 |to
    [ a [ 8 = ] |afterOrToEnd? ] vals [ [ 2 3 4 5 6 7 ] false ] here assert=
    a |at 7 assert=

    a 1 |to
    [ a 8 |afterOrToEnd? ] vals [ [ 2 3 4 5 6 7 ] false ] here assert=
    a |at 7 assert=
  ]

  it should 'die when using |afterOrDie, with proper details' [
    [ 1 | 2 3 4 5 6 7 ] $: a
    [ a [ 6 = ] |afterOrDie ] vals [ [ 2 3 4 5 ] ] assert=
    a |at 6 assert=

    [ 1 | 2 3 4 5 6 7 ] $: a
    [ a [ 8 = ] |afterOrDie ] 'expected ⸢[ 8 = ]⸥ to match, but reached end of block' assertDies
    [ a 8 |afterOrDie ] 'expected ⸢8⸥ to match, but reached end of block' assertDies
  ]
]


describe '|beforeOrToEnd/|beforeOrToEnd?/|beforeOrDie' [
  in lang

  it should 'put cursor before matching item' [
    [ 1 | 2 3 4 5 6 7 ] $: a
    [ a [ 6 = ] |beforeOrToEnd? ] vals [ [ 2 3 4 5 ] true ] here assert=
    a |at 5 assert=
  ]

  it should 'not move if reached the end' [
    [ 1 | 2 3 4 5 6 7 ] $: a
    [ a 8 |beforeOrToEnd? ] vals [ [ 2 3 4 5 6 7 ] false ] here assert=
    a |at 7 assert=
  ]

  it should 'allow some parsing' [
    [ ahead |beforeOrToEnd: [ decimal? not ] bi: sum count / ] @: avgOf
    avgOf 1 2 3 $: avg
    avg 2 assert=
  ]

  it should 'die when using |beforeOrDie, with proper details' [
    [ 1 | 2 3 4 5 6 7 ] $: a
    [ a [ 6 = ] |beforeOrDie ] vals [ [ 2 3 4 5 ] ] assert=
    a |at 5 assert=

    [ 1 | 2 3 4 5 6 7 ] $: a
    [ a [ 8 = ] |beforeOrDie ] 'expected ⸢[ 8 = ]⸥ to match, but reached end of block' assertDies
    [ a 8 |beforeOrDie ] 'expected ⸢8⸥ to match, but reached end of block' assertDies
  ]
]


describe 'tally' [
  in lang

  it should 'do nothing when block is empty' [
    false $: did
    [ ] [ true =: did ] tally [ ] assert=
    did false assert=
  ]

  it should 'count and open with occurence pairs' [
    [ 1 2 2 3 3 2 1 ] [ ] tally [
      1 "=>" 2
      2 "=>" 3
      3 "=>" 2
    ] assert=
  ]

  it should 'leave stack block' [
    [ 1 2 2 3 3 2 1 ] [ even? ] tally [
      1 "=> 2" true
      2 "=> 3" false
      3 "=> 2" true
    ] vals assert=
  ]

  it should 'allow to drop form/count in block' [
    [ 1 2 2 3 3 2 1 ] [ drop ] tally [ 1 2 3 ] assert=
    [ 1 2 2 3 3 2 1 ] [ nip ] tally [ 2 3 2 ] assert=
    [ 1 2 2 3 3 2 1 ] [ 2drop ] tally [ ] assert=
  ]

  it should 'count blocks correctly' [
    [ [ 1 2 ] [ 3 4 ] [ 3 4 ] [ 1 2 ] [ 5 6 ] ] $: b

    b [ ] tally [
      [ 1 2 ] 2
      [ 3 4 ] 2
      [ 5 6 ] 1
    ] assert=
  ]

  it should 'count nested blocks correctly' [
    [ [ 1 2 ] [ 3 [ 4 5 ] ] [ 3 [ 4 5 ] ] [ 3 [ 4 6 ] ] [ 1 2 ] [ 4 5 ] [ 4 6 ] ] $: b

    b [ ] tally [
      [ 1 2 ] 2
      [ 3 [ 4 5 ] ] 2
      [ 3 [ 4 6 ] ] 1
      [ 4 5 ] 1
      [ 4 6 ] 1
    ] assert=
  ]

  it should 'count with reflections' [
    [ ] $: b
    3 times: [ b b shove ]
    b 1 shove
    b [ b ] here shove
    b [ ] tally [
      b 3
      1 1
      [ b ] 1
    ] here assert=
  ]
]


describe 'tally:' [
  in lang

  it should 'function in the same way as \'tally\'' [
    false $: did

    [ ] tally: [ true =: did ] [ ] assert=
    did false assert=

    [ 1 2 2 3 3 2 1 ] tally: even?
      [
        1 "=> 2" true
        2 "=> 3" false
        3 "=> 2" true
      ] vals assert=

    [ 1 2 2 3 3 2 1 ] tally: [ drop ] [ 1 2 3 ] assert=
    [ 1 2 2 3 3 2 1 ] tally: [ nip ] [ 2 3 2 ] assert=
    [ 1 2 2 3 3 2 1 ] tally: [ 2drop ] [ ] assert=

    [ 1 2 2 3 3 2 1 ] tally: drop [ 1 2 3 ] assert=
    [ 1 2 2 3 3 2 1 ] tally: nip [ 2 3 2 ] assert=
    [ 1 2 2 3 3 2 1 ] tally: 2drop [ ] assert=
  ]
]


"TODO: sorts below need more tests, but probably after they're implemented
 in Novika (basically, we're relying on Crystal's own test suite here)."

describe 'sortUsing!' [
  in lang

  it should 'sort block inplace' [
    [ 3 1 2 4 0 -3 ] [ - ] sortUsing! [ -3 0 1 2 3 4 ] assert=
  ]
]


describe 'sort!' [
  in lang

  it should 'sort block of decimals' [
    [ 3 1 2 4 0 -3 ] sort! [ -3 0 1 2 3 4 ] assert=
    [ [ 3 'foo' 1 2 3 ] sort! ] 'bad type: quote, expected: a decimal' assertDies
  ]
]


describe 'sortBy!' [
  in lang

  it should 'sort block via mapper block' [
    [ 'hi' 'worldish' 'hi' 'foobar' ] [ count ] sortBy! [ 'hi' 'hi' 'foobar' 'worldish' ] assert=

    [
      [ 'hi' 'worldish' 'hi' 'foobar' ] [ #poop ] sortBy! [ 'hi' 'hi' 'foobar' 'worldish' ] assert=
    ] 'bad type: word, expected: a decimal' assertDies
  ]
]


describe '|around' [
  in lang

  [
    this ahead reparent drop "hacky hack for assert="

    $: aroundResult
    $: origBlock

    "Sanity check: not same as input"
    aroundResult origBlock same? false assert=

    "Has ONLY the start and end fields:"
    aroundResult ls [ start end ] assert=

    "Are orphans:"
    aroundResult orphan? true assert=
  ] @: sanityCheck

  it should 'die when N = 0 and/or block is empty' [
    [ [ ] 0 |around ] '|around: cannot choose pivot when given empty list' assertDies
    [ [ 1 2 3 4 ] 0 |around ] '|around: cannot choose pivot when amount is 0' assertDies
    [ [ ] 2 |around ] '|around: cannot choose pivot when given empty list' assertDies
  ]

  it should 'work when <= N and keep cursor' [
    [ 1 2 3 4 ] $: b1
    [ 1 2 | 3 4 ] $: b2

    [ b1 1 |around ] vals count 1 assert=

    b1 10 |around $: result1
    b2 4 |around $: result2

    b1 result1 sanityCheck
    b2 result2 sanityCheck

    result1.start 0 assert=
    result1.end 4 assert=

    result2.start 0 assert=
    result2.end 4 assert=

    "Have same tape content:"
    result1 toTape b1 assert=
    result2 toTape b2 assert=
  ]

  it should 'handle even N' [
    [ 1 | 2 3 4 5 6 ] $: b1
    [ 1 2 3 4 5 | 6 ] $: b2

    b1 4 |around $: lhalfTest
    b2 4 |around $: rhalfTest

    "Sanity check again because this is a different branch:"
    b1 lhalfTest sanityCheck
    b2 rhalfTest sanityCheck

    lhalfTest toTape [ 1 | 2 3 4 ] assert=
    rhalfTest toTape [ 3 4 5 | 6 ] assert=
  ]

  it should 'handle odd N' [
    [ 1 2 | 3 4 5 ] $: b
    b 3 |around $: result
    b result sanityCheck
    result toTape [ 1 2 | 3 ] assert=
  ]

  it should 'handle cursor at the end' [
    [ 1 2 3 4 | ] $: b
    b 3 |around $: result
    b result sanityCheck
    result toTape [ 2 3 4 | ] assert=
  ]

  "TODO: this is one of the most complex words yet, needs more tests."
]


describe '|ring' [
  in lang

  it should 'die with N<=0 and/or empty block' [
    [ [ ] 1 |ring ] '|ring: block cannot contain >= 1 rings' assertDies
    [ [ 1 2 3 ] 0 |ring ] '|ring: only >= 1 rings exist' assertDies
    [ [ 1 2 3 ] -100 |ring ] '|ring: only >= 1 rings exist' assertDies
  ]

  it should 'work at block end' [
    [ 1 2 3 ] 1 |ring $: r1
    r1 toTape [ 3 ] assert=
    r1.firstAt 2 assert=
    r1.lastAt 2 assert=
    r1 orphan? true assert=
    r1 toQuote '[ 3 · ${firstAt :: 2} ${lastAt :: 2} ]' assert=

    [ 1 2 3 ] 2 |ring toQuote '[ 2 3 · ${firstAt :: 1} ${lastAt :: 2} ]' assert=
    [ 1 2 3 ] 3 |ring toQuote '[ 1 2 3 · ${firstAt :: 0} ${lastAt :: 2} ]' assert=
    [ 1 2 3 ] 4 |ring toQuote '[ 1 2 3 · ${firstAt :: 0} ${lastAt :: 2} ]' assert=
  ]

  it should 'work at block start' [
    [ | 1 2 3 ] $: 0block

    0block 1 |ring toQuote '[ | 1 · ${firstAt :: 0} ${lastAt :: 0} ]' assert=
    0block 2 |ring toQuote '[ | 1 2 · ${firstAt :: 0} ${lastAt :: 1} ]' assert=
    0block 3 |ring toQuote '[ | 1 2 3 · ${firstAt :: 0} ${lastAt :: 2} ]' assert=
    0block 4 |ring toQuote '[ | 1 2 3 · ${firstAt :: 0} ${lastAt :: 2} ]' assert=
  ]

  it should 'work at block mid sides=' [
    [ 1 2 3 | 4 5 6 ] $: b
    b 1 |ring toQuote '[ 3 | 4 · ${firstAt :: 2} ${lastAt :: 3} ]' assert=
    b 2 |ring toQuote '[ 2 3 | 4 5 · ${firstAt :: 1} ${lastAt :: 4} ]' assert=
    b 3 |ring toQuote '[ 1 2 3 | 4 5 6 · ${firstAt :: 0} ${lastAt :: 5} ]' assert=
    b 4 |ring toQuote '[ 1 2 3 | 4 5 6 · ${firstAt :: 0} ${lastAt :: 5} ]' assert=
  ]

  it should 'work at block mid sides!=' [
    [ 1 2 3 4 | 5 6 ] $: b
    b 1 |ring toQuote '[ 4 | 5 · ${firstAt :: 3} ${lastAt :: 4} ]' assert=
    b 2 |ring toQuote '[ 3 4 | 5 6 · ${firstAt :: 2} ${lastAt :: 5} ]' assert=
    b 3 |ring toQuote '[ 2 3 4 | 5 6 · ${firstAt :: 1} ${lastAt :: 5} ]' assert=
    b 4 |ring toQuote '[ 1 2 3 4 | 5 6 · ${firstAt :: 0} ${lastAt :: 5} ]' assert=
    b 5 |ring toQuote '[ 1 2 3 4 | 5 6 · ${firstAt :: 0} ${lastAt :: 5} ]' assert=
  ]
]


describe 'sample' [
  in lang

  it should 'leave 1 sample form from a block' [
    [ 1 'hello world' [ 2 3 ] false this ] vals $: b

    100 collect: [ b sample ] all: [ b anyof? ] true assert=
  ]
]


describe 'sample:' [
  in lang

  it should 'leave N sample forms from a block' [
    [ 1 'hello world' [ 2 3 ] false this ] vals $: b

    b sample: 100 $: samples

    0 $: total

    samples [ ] tally pairs: [ ${ item count }
      total count + =: total
      item b anyof? true assert=
    ]

    total 100 assert=
  ]
]


describe 'flat aka flat:deep' [
  in lang

  it should 'leave empty child block if input is empty' [
    [ ] $: inp
    inp flat $: outp
    outp [ ] assert=
    outp parent inp assert=
  ]

  it should 'leave same content block when no nesting' [
    [ 1 2 3 4 5 6 ] $: inp
    inp flat $: outp

    outp [ 1 2 3 4 5 6 ] assert=
    outp parent inp assert=
  ]

  it should 'flatten depth 1 blocks' [
    [ 0 [ 1 2 3 ] 'hello world' [ 4 5 6 ] 7 8 9 ] $: inp
    inp flat $: outp

    outp [ 0 1 2 3 'hello world' 4 5 6 7 8 9 ] assert=
    outp parent inp assert=
  ]

  it should 'flatten depth n blocks' [
    [ [ [ [ [ [1] ] ] [2] ] [3] 4 ] 5 [ [6] ] ] $: b
    b flat [ 1 2 3 4 5 6 ] assert=
  ]

  it should 'not open input block or subblocks but open result correctly' [
    [ ] $: foo

    [ [ 1 + foo gulp ] [ 2 + foo gulp] foo foo gulp ] $: program
    program flat $: flatProgram

    flatProgram [ (1 + foo gulp)
                  (2 + foo gulp)
                  (foo foo gulp) ] assert=

    [ 100 200 flatProgram open ] vals [ ] assert=
    [ 201 102 foo ] here foo assert=
  ]

  it should 'allow to lookup in/submit to parent' [
    [ [ 100 ] $: x ] obj $: foo

    foo flat $: flattened
    flattened [ 100 $: x ] assert=
    flattened.x [ 100 ] assert=

    flattened 2 [ 2drop 200 #=: ] |hydrate
    flattened [ 200 =: x ] assert=
    flattened do

    flattened.x 200 assert=
    foo.x 200 assert=
  ]

  it should 'ignore self-references at depth 1' [
    [ ] $: foo
    foo foo gulp
    foo flat [ ] assert=

    [ 1 2 3 4 5 ] $: bar
    bar 3 [ bar ] |hydrate
    bar flat [ 1 2 3 4 5 ] assert=
  ]

  it should 'ignore self-references at depth n' [
    [ [ 1 ] [ 2 ] [ [ 3 'hello' ] ] [ [ [4] ] ] [ [ 5 ] ] ] $: foo
    foo 3 fromLeft
        0 fromLeft
        0 fromLeft
        foo gulp

    foo 1 fromLeft 0 [ foo ] |hydrate

    foo flat [ 1 2 3 'hello' 4 5 ] assert=
  ]

  it should 'not pollute the stack' [
    [ [ ] flat ] vals [ [ ] ] assert=
    [ [ 1 2 3 4 ] flat ] vals [ [ 1 2 3 4 ] ] assert=
    [ [ 1 [ 2 3 ] 4 ] flat ] vals [ [ 1 2 3 4 ] ] assert=
    [ [ 1 [ 2 [[[3]]] ] 4 ] flat ] vals [ [ 1 2 3 4 ] ] assert=
    [ [ 1 [ 2 [[[3]]] ] 4 ] dup << flat ] vals [ [ 1 2 3 4 ] ] assert=
    [ [ 1 [ 2 [[[3]]] ] | 4 ] dup << flat ] vals [ [ 1 2 3 4 ] ] assert=
  ]
]


describe 'gsub[:]/gsubOn:' [
  in lang

  it should 'leave empty block as is' [
    [ ] $: b
    b #`foo gsub: 100
    b empty? true assert=

    stack empty? true assert= "stack hygiene"
  ]

  it should 'leave block without matches as is' [
    [ 1 2 3 ] $: b
    b #`foo gsub: 100
    b [ 1 2 3 ] assert=

    stack empty? true assert= "stack hygiene"
  ]

  it should 'do simple flat replace' [
    [ 1 `foo 2 `bar 3 ] $: b

    b #`foo gsub: 100
    b #`bar gsub: 200

    b [ 1 100 2 200 3 ] assert=

    stack empty? true assert= "stack hygiene"
  ]

  it should 'do flat replace regardless of cursor but keep it' [
    [ 1 `foo 2 | `bar 3 ] $: b

    b #`foo gsub: 100
    b #`bar gsub: 200

    b [ 1 100 2 | 200 3 ] assert=

    stack empty? true assert= "stack hygiene"
  ]

  it should 'do simple deep replace' [
    [ [ 1 2 ] [ 3 `foo ] [ 4 `bar ] [ 5 `baz ] ] $: b

    b #`foo gsub: 100
    b #`bar gsub: 200
    b #`baz gsub: #frobnicate

    b [
      [ 1 2 ]
      [ 3 100 ]
      [ 4 200 ]
      [ 5 frobnicate ]
    ] assert=

    stack empty? true assert= "stack hygiene"
  ]

  it should 'do multi flat replace' [
    [ 1 `foo 2 `bar 3 ] $: b
    b #`foo gsub: [ 'hello' 'world' ]
    b #`bar gsub: [ 'bye' #frob ]

    b [ 1 'hello' 'world' 2 'bye' frob 3 ] assert=

    stack empty? true assert= "stack hygiene"
  ]

  it should 'keep track of the cursor with multi flat replace' [
    [ 1 `foo | 2 `bar 3 ] $: b

    b #`foo gsub: [ 'hello' 'world' ]
    b [ 1 'hello' 'world' | 2 `bar 3 ] assert=

    b #`bar gsub: [ 'bye' #frob ]
    b [ 1 'hello' 'world' | 2 'bye' frob 3 ] assert=

    stack empty? true assert= "stack hygiene"
  ]

  it should 'do patch replace' [
    [ ] $: acc

    [ this swap gsubOn: #`ntimes

      `ntimes times: [
        acc gulp
      ]
    ] @: foo

    10 foo

    acc [ 0 1 2 3 4 5 6 7 8 9 ] assert=

    stack empty? true assert= "stack hygiene"
  ]

  it should 'handle self-reference' [
    [ `a [ `a 1 2 3 ] [ 4 5 6 `a ] ] $: b
    b b shove
    b #`a gsub: 100

    b [ 100 [ 100 1 2 3 ] [ 4 5 6 100 ] ] b << assert=

    stack empty? true assert= "stack hygiene"
  ]

  it should 'handle self-referential replacement' [
    [ `a [ `a 1 2 3 ] [ 4 5 6 `a ] ] $: b
    b b shove
    b #`a gsub: b
    b [ b [ b 1 2 3 ] [ 4 5 6 b ] b ] here assert=

    stack empty? true assert= "stack hygiene"
  ]

  it should 'handle computation during replacement' [
    [ 1 `a 2 `b ] $: b
    b #`a gsub: [ dup 1 + ] "add one to before `a for `a"
    b #`b gsub: [ dup 2 * ] "double before `b for `b"
    b [ 1 2 2 4 ] assert=

    stack empty? true assert= "stack hygiene"
  ]

  it should 'handle multiple insertion with drops & computation' [
    [ ] $: records
    [ records gulp ] @: record

    [ 1 `a 2 `b ] $: b
    b #`a gsub: [ 1 + 'X = ' swap ~ #record ]
    b #`b gsub: [ 2 * 'Y = ' swap ~ #record ]
    b [ 'X = 2' record
        'Y = 4' record ] assert=
    b do

    records [ 'X = 2' 'Y = 4' ] assert=

    stack empty? true assert= "stack hygiene"
  ]

  it should 'handle multiple insertion with replacement containing pattern' [
    [ [ `a `b ] [ `a `b ] ] $: b

    [ bi: [ #`a gsub: [ [ `a `b ] ] ]
          [ #`b gsub: [ [ `b `a ] ] ]
    ] @: doIt

    b doIt
    b [ [ [ `a [`b `a] ] [`b `a] ] [ [ `a [`b `a] ] [`b `a] ] ] assert=

    b doIt
    b [ [ [ [`a [`b `a]] [[`b `a] [`a [`b `a]]] ] [[`b `a] [`a [`b `a]]] ] [ [ [`a [`b `a]] [[`b `a] [`a [`b `a]]] ] [[`b `a] [`a [`b `a]]] ] ] assert=

    b #`a gsub: 0
    b #`b gsub: 1

    b [ [ [ [0 [1 0]] [[1 0] [0 [1 0]]] ] [[1 0] [0 [1 0]]] ] [ [ [0 [1 0]] [[1 0] [0 [1 0]]] ] [[1 0] [0 [1 0]]] ] ] assert=
    b flat [ 0 1 0 1 0  0 1 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 1 0 ] assert=

    stack empty? true assert= "stack hygiene"
  ]

  it should 'open pattern when it\'s a block' [
    [ 1 2 3 ] $: block
    [ ] $: stacks

    block [ (stack shallowCopy) stacks gulp false ] gsub: 100
    block [ 1 2 3 ] assert=

    [ [ 1 2 3 | ]
      [ 1 2 | 3 ]
      [ 1 | 2 3 ]
    ] vals stacks assert=

    block [ true ] gsub: 100
    block [ 100 100 100 ] assert=

    stack empty? true assert= "stack hygiene"
  ]

  it should 'run the examples from docs' [
    [ `a `b + ] $: temp

    temp #`a 100 gsub
    temp #`b 200 gsub
    temp [ 100 200 + ] assert=
    temp open 300 assert=

    [ ] $: screen

    [ screen gulp ] @: echo

    [ 100 `cmd
      200 `cmd ] $: block

    block #`cmd gsub: #echo
    block [ 100 echo 200 echo ] assert=
    block open

    [ 100 `cmdA
      200 `cmdB ] $: block

    block [ 2 * #echo ] gsubOn: #`cmdA
    block [ 4 * #echo ] gsubOn: #`cmdB

    block [ 200 echo 800 echo ] assert=
    block open

    [ 100 200 200 800 ] screen assert=

    stack empty? true assert= "stack hygiene"
  ]

  it should 'allow to pass entry as pattern to infix' [
    [ `a `b + ] $: temp

    #`a $: var
    temp 100 gsubOn: var

    #`b =: var
    temp 200 gsubOn: [ 1 2 3 var ]

    temp [ 100 200 + ] assert=

    [ 1 [ 2 3 ] 4 ] $: temp
    temp 100 gsubOn: [[ dup [ 2 3 ] = ]] "FIXME: ugly"
    temp [ 1 100 4 ] assert=

    stack empty? true assert= "stack hygiene"
  ]

  it should 'allow to implement preempt resolution for optimization' [
    [ "I am a chewbacca, I eat people"
      ahead $: caller
      #nil $: form

      dup [form] gsubOn: [[
        "If current form resolves to a builtin, overwrite with
         the builtin."
        caller over entry:fetch? br: [ dup builtin? dup <| br: [ nip dup =: form ] drop |> ] false
      ]]
    ] @: chewbacca

    30 times: [
      drop

      [ 1 2 3 ] chewbacca [ 1 2 3 ] assert=
      [ a b c ] chewbacca [ a b c ] assert=
      [ true a ] chewbacca [ true a ] assert=
      [ 1 2 + ] chewbacca [ 1 2 ] #+ here << assert=
      [ x y + z > br: a b ] chewbacca [ #x #y (#+ here) #z #> #br: #a #b ] vals assert=
      [ x y + z > br: [a] [b] ] chewbacca [ #x #y (#+ here) #z #> #br: [a] [b] ] vals assert=
      [ [ x y + ] z > br: [a] [b] ] chewbacca [ [ x y ] (#+ here) << #z #> #br: [a] [b] ] vals assert=
      (this -> chewbacca) desc 'I am a chewbacca, I eat people' assert=

      "Now to the interesting part, self-optimization. We do it repeatedly
       to make sure nothing breaks."
      (this -> chewbacca) chewbacca drop
    ]
  ]
]
