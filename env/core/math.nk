"Epsilon value for `approx=` and derived, e.g. `assertApprox=`.
 Change this if you want more precision."
0.001 $: EPSILON

[ """( A B -- Min Max ): sorts two decimals, A and B, in
   ascending (min to max) order. In case A = B, order is
   unchanged.

  ```
  1 2 2asc leaves: [ 1 2 ]
  2 1 2asc leaves: [ 1 2 ]
  ```
  """
  2dup > => [ swap ]
] @: 2asc


[ """( A B -- Max Min ): sorts two decimals, A and B, in
   descending (max to min) order. In case A = B, order is
   unchanged.

  ```
  1 2 2desc leaves: [ 2 1 ]
  2 1 2desc leaves: [ 2 1 ]
  ```
  """
  2dup < => [ swap ]
] @: 2desc


[ """( A B -- M ): leaves Minimum of two decimals, A and B.

  ```
  3 10 2min leaves: 3
  ```
  """
  2asc drop
] @: 2min


[ """( A B -- M ): leaves Maximum of two decimals, A and B.

  ```
  3 10 2max leaves: 10
  ```
  """
  2desc drop
] @: 2max


[ "( L H -- N ): generates random Number between Low and
   High, *including* both Low and High."
  "Formula: rand * (max - min) + min"
  over - + rand * trunc
] @: randFromTo


[ """( N clamp: L H -- N/L/H ): clamps Number between Low and
   High: if Number is less than Low, leaves low; if Number
   is greater than High, leaves High.

  ```
  1 clamp: 5 10 leaves: 5
  5 clamp: 5 10 leaves: 5
  7 clamp: 5 10 leaves: 7
  10 clamp: 5 10 leaves: 10
  100 clamp: 5 10 leaves: 10
  ```
  """
  ahead thruVal asDecimal $: min
  ahead thruVal asDecimal $: max

  dup min < => [ drop min ]
  dup max > => [ drop max ]
] @: clamp:


[ """( N -- -N ): flips the sign of N.

  ```
  -1 flipSign leaves: 1
  0 flipSign leaves: 0
  1 flipSign leaves: -1
  ```
  """
  -1 *
] @: flipSign


[ """( N -- Av ): leaves the Absolute value of N.

  ```
  0 abs leaves: 0
  100 abs leaves: 100
  -100 abs leaves: 100
  ```
  """
  dup negative? => flipSign
] @: abs


[ """( D -- R ): leaves Reciprocal of Decimal (`1/D`). Leaves
   0 if Decimal is 0. Note: as in `12 % 12 *`, this may not
   always leave `1` because of math imprecisions.

  ```
  0 % leaves: 0
  20 % leaves: 0.05
  100 % 100 * leaves: 1
  ```
  """
  dup zero? not => [ 1 swap / ]
] @: %


[ """( D R1b R1e R2b R2e -- D' ): leaves Decimal in range
   [R1b; R1e] mapped to the range [R2b; R2e].

  Note: Decimal is clamped into the range [R1b; R1e].
  Note: implementation taken from https://www.arduino.cc/reference/en/language/functions/math/map/

  ```
  100  0 100  1.5 255  rangesMap leaves: 255
    0  0 100  1.5 255  rangesMap leaves: 1.5

  \"Reverse range:\"

  10  0 100  100 0  rangesMap leaves: 90
  ```
  """
  $: toMax
  $: toMin
  $: fromMax
  $: fromMin

  clamp: fromMin fromMax $: x

  x fromMin - toMax toMin - * fromMax fromMin - / toMin +
] @: rangesMap


[ """( D mapFromRange: R1b R1e toRange: R2b R2e -- D' ): infix
   version of `rangesMap`.

  ```
  100 mapFromRange: 0 100 toRange: 1.5 255 leaves: [ 255 ]
    0 mapFromRange: 0 100 toRange: 1.5 255 leaves: [ 1.5 ]
  ```
  """
  ahead $: caller

  caller thruVal
  caller thruVal
  caller thruWord: toRange:
  caller thruVal
  caller thruVal
  rangesMap
] @: mapFromRange:


[ """( P Rb Re -- D ): leaves Decimal in range [Range begin; Range end]
   corresponding to the given Percentage (in [0; 1]).

  See `rangesMap` for more details.

  ```
  \"...etc..\"
  -100  0 100  mapToRange leaves: 0
     0  0 100  mapToRange leaves: 0
   0.1  0 100  mapToRange leaves: 10
     1  0 100  mapToRange leaves: 100
     2  0 100  mapToRange leaves: 100
  \"...etc..\"
  ```
  """
  $: rangeEnd
  $: rangeBegin

  mapFromRange: 0 1 toRange: rangeBegin rangeEnd
] @: mapToRange


[ "( P mapToRange: Rb Re -- D ): infix version of `mapToRange`."
  ahead thruVal
  ahead thruVal
  mapToRange
] @: mapToRange:


[ """( Hp %->: Rb Re -- D ): leaves Decimal, which is Human
   percentage (0-100) mapped to [Range begin; Range end]
   range. Human percentage is clamped to 0-100.

  ```
  \"What is 30% of John's salary, $10 000? \"
  30 %->: 0   10_000  leaves: 3000
  60 %->: 64  255     leaves: 178.6
  ```
  """
  ahead thruVal $: low
  ahead thruVal $: high

  mapFromRange: 0 100 toRange: low high
] @: %->:


[ """( D ->%: Rb Re -- Hp ): leaves Human percentage for
   Decimal in the given range [Range begin; Range end].
   Inverse of `%->:`.

  ```
  100 ->%: 0 256 leaves: 39.0625

  \"Can be checked like so:\"
  39.0625 %->: 0 256 leaves: 100
  ```
  """
  ahead thruVal $: low
  ahead thruVal $: high

  mapFromRange: low high toRange: 0 100
] @: ->%:


[ "( A B -- B ): leaves Boolean for whether A and B are
   approximately equal (their difference is less than or
   equal to `EPSILON`)."
  - abs EPSILON <=
] @: approx=
