[ """( [ ... | F ... ]B -- F true / false ): leaves Form and/
   or a boolean for whether Form exists in Block.

  ```
  [ 1 2 3 ] 1 |to "[ 1 | 2 3 ]" peek? leaves: [ 2 true ]
  [ 1 2 3 ] "[ 1 2 3 | ]" peek? leaves: [ false ]
  ```
  """
  dup |at over count = => [ drop false ^ ]
  dup |at fromLeft true
] @: peek?


[ """( B N -- ): decrements block cursor position: moves
   cursor back N times in Block.

  ```
  "Note: `toQuote` is simply the most compact way to
   present the result. It doesn't do anything to the
   cursor."
  [ 1 2 3 ] "[ 1 2 3 | " dup 2 |- toQuote leaves: '[ 1 | 2 3 ]'
  ```
  """

  "Hydrating here may seem redundant at first, but remember
   cases like:

      stack 1 |-

   Thanks to the custom stack created by `2enclose`, we avoid
   the problems of changing the stack at right times, since
   words `stack` and `1` affect the cursor too."

  2enclose [ over |at swap - |to ] hydrate
] @: |-


[ """( B N -- ): increments block cursor position: moves
   cursor forward N times in Block.

  ```
  [ 1 2 3 ] $: block
  block 1 |to
  block toQuote leaves: '[ 1 | 2 3 ]'
  block 1 |+
  block toQuote leaves: '[ 1 2 | 3 ]'
  block 1 |+
  block toQuote leaves: '[ 1 2 3 ]'
  ```
  """
  2enclose [ over |at + |to ] hydrate
] @: |+


[ """( S |: F -- S ): infix version of `there`.

  Like `there`, preserves `ahead`. Leaves the opener
  block dirty due to this.

  ```
  ([ 1 2 3 ] |: 100) leaves: [ 1 2 3 100 ]
  ([ 1 2 3 ] |: +) leaves: [ [ 1 5 ] ]
  ([ 1 2 3 ] |: swap) leaves: [ [ 1 3 2 ] ]

  [ 100 ] |: [ ahead thru + ] 200 123 leaves: [ 300 123 ]
  ```
  """
  dup
  ahead thruBlock
  ahead #hydrate inject
] @: |:


[ """( B N -- ): moves the cursor in Block to N. If N
   is negative, the cursor is moved to 0. If N is greater
   than the amount of forms in Block, the cursor is moved
   to the end of Block.

  ```
  [ 1 2 3 ] $: x
  x 1 |clamp
  x toQuote leaves: '[ 1 | 2 3 ]'
  x 1000 |clamp
  x toQuote leaves: '[ 1 2 3 ]'
  x -1000 |clamp
  x toQuote leaves: '[ | 1 2 3 ]'
  ```
  """
  asDecimal $: cursor
  asBlock   $: block

  block (cursor clamp: 0 [ block count ]) |to
] @: |clamp


[ """( Lb N B -- ): moves the cursor in List block to N,
   then hydrates List block with Block. After Block had
   executed *successfully*, moves the cursor in List
   block back to where it was before `|hydrate` (clamped
   to either end, if necessary).

  ```
  [ 1 2 3 ] $: x

  x 1 |to
  x toQuote leaves: '[ 1 | 2 3 ]'

  x 2 [ + ] |hydrate
  x toQuote leaves: '[ 3 | 3 ]'

  x 2 [ 2drop ] |hydrate
  x toQuote leaves: '[ ]'
  ```
  """
  asBlock   $: body
  asDecimal $: cursor
  asBlock   $: block

  block |at $: tmp
  block cursor |to
  block body hydrate
  block tmp |clamp
] @: |hydrate


[ """( -- ): swaps the item before and after cursor in the
   active stack.

  ```
  [ 1 2 3 ] $: block
  block 1 |-
  block toQuote leaves: '[ 1 2 | 3 ]'
  block [ |swap ] there
  block toQuote leaves: '[ 1 3 | 2 ]'
  ```
  """
  |> swap <|
] @: |swap


[ """( F B -- ): `shove`s Form into Block, drops both.

  ```
  3 [ 1 2 ] keep: gulp leaves: [ [ 1 2 3 ] ]
  ```
  """
  swap shove
] @: gulp


[ """( [ ... F | ... ]B -- F [ ... | ... ]B ] ): `cherry`s
   Form from Block onto the active stack, placing it before
   the Block. Inverse of `gulp`.

  ```
  [ 1 2 3 ] spit leaves: [ 3 [ 1 2 ] ]
  ```
  """
  dup cherry swap
] @: spit


[ """( [ ... | ... ]B F -- [ ... F | ... ]B ): `shove`s Form
   into Block, leaves only Block.

  ```
  [ 1 2 ] 3 << leaves: [ [ 1 2 3 ] ]
  ```
  """
  over gulp
] @: <<


[ """( [ ... F | ... ]B -- [ ... | ... ]B F ): `cherry`s
   Form from Block, leaves both. Inverse of `<<`.

  ```
  [ 1 2 3 ] >> leaves: [ [ 1 2 ] 3 ]
  ```
  """
  dup cherry
] @: >>


[ """( F -- [ F ]B ): encloses Form in a new, orphan Block.

  ```
  'Hi!' enclose leaves: [ [ 'Hi!' ] ]
  ```
  """
  orphan swap <<
] @: enclose


[ """( X Y -- [ X Y ]B ): encloses X and Y, a pair of forms,
   in a new, orphan Block.

  ```
  'Hello' 'World' 2enclose leaves: [ [ 'Hello' 'World' ] ]
  ```
  """
  swap

  orphan swap <<
         swap <<
] @: 2enclose


[ """( B -- F ): leaves first Form in Block. Dies if Block
   is empty.

  ```
  [ 0 ] first leaves: 0
  [ 1 2 3 ] first leaves: 1
  ```
  """
  0 fromLeft
] @: first


[ """( B -- F true / false ): leaves first Form in Block
   followed by true if Block is non-empty. Leaves false
   if Block is empty.

  ```
  [ ] first? leaves: [ false ]
  [ 1 2 3 ] first? leaves: [ 1 true ]
  ```
  """
  dup empty? br: [ drop false ] [ first true ]
] @: first?


[ """( B -- F ): leaves last Form in Block. Dies if Block
   is empty.

  ```
  [ 0 ] last leaves: 0
  [ 1 2 3 ] last leaves: 3
  ```
  """
  0 fromRight
] @: last


[ """( B -- F true / false ): leaves last Form in Block
   followed by true if Block is non-empty. Leaves false
   if Block is empty.

  ```
  [ ] last? leaves: [ false ]
  [ 1 2 3 ] last? leaves: [ 3 true ]
  ```
  """
  dup empty? br: [ drop false ] [ last true ]
] @: last?


[ """( B/Q F/Fq -- Sb ): leaves Status boolean for whether
   Block ends with Form (as per `=`), or Quote ends with
   Fragment quote.

  Always leaves true if Form or Fragment quote is empty.

  ```
  'hello world' 'h' startsWith? leaves: true
  'hello world' 'hello' startsWith? leaves: true
  'hello world' 'world' startsWith? leaves: false

  [ 1 2 3 ] 1 startsWith? leaves: true
  [ 1 2 3 ] 3 startsWith? leaves: false
  ```
  """
  $: frag
  $: form

  form quote? => [
    frag quote? br:
      [
        form count frag count < => [ false ^ ]
        form count frag count = => [ form frag = ^ ]
        form frag count sliceQuoteAt drop frag =
      ]
      false
    ^
  ]

  form block? => [
    form empty? br: false [ form 0 fromLeft frag = ] ^
  ]

  '`startsWith?`: expected quote or block' die
] @: startsWith?


[ """( B/Q F/Fq -- Sb ): leaves Status boolean for
   whether Block ends with Form (as per `=`), or if Quote
   ends with Fragment quote.

  Always leaves true if Form or Fragment quote is empty.

  ```
  'hello world' 'd' endsWith? leaves: true
  'hello world' 'world' endsWith? leaves: true
  'hello world' 'hello' endsWith? leaves: false

  [ 1 2 3 ] 3 endsWith? leaves: true
  [ 1 2 3 ] 1 endsWith? leaves: false
  ```
  """
  $: frag
  $: form

  form quote? => [
    frag quote? br:
      [
        form count frag count < => [ false ^ ]
        form count frag count = => [ form frag = ^ ]
        form form count frag count - sliceQuoteAt nip frag =
      ]
      false
    ^
  ]

  form block? => [
    form empty? br: false [ form 0 fromRight frag = ] ^
  ]

  '`endsWith?`: expected quote or block' die
] @: endsWith?


[ """( B/Q Bf/Bq Ef/Eq -- true/false ): leaves whether Block/Quote
   starts with Begin form/Begin quote, and ends with End form/
   End quote.

  ```
  [ 1 2 3 ] 1 3 surroundedBy? leaves: true
  '[[hello world]]' '[[' ']]' surroundedBy? leaves: true
  ```
  """
  <| nup startsWith? |swap endsWith? |> and
] @: surroundedBy?


[ "( P C -- C ): same as `reparent`, but in different order."
  swap reparent
] @: adopt


[ "( B -- Cb ): leaves an empty Child block for Block. Very
   much like `new`, but doesn't copy the tape and therefore may
   be faster in certain circumstances."
  orphan adopt
] @: child


[ dup block? not => [ entry:fetch ^ ]

  swap $: container

  map: [ container swap _arrowFetchImpl ]
] @: _arrowFetchImpl


[ """( Db -> N -- F ): Resolves Name, a word, using the
   given Dictionary block (block with a dictionary and/or
   relatives, therefore, simply any block). Does not
   distinguish between entry types (i.e., it doesn't matter
   whether Name resolves to an opener or a pusher entry):
   its value Form is always *pushed* onto the active stack.

  ```
  [ 100 $: x 200 $: y [ x y + ] @: sum ] obj $: point

  point -> x leaves: 100
  point -> y leaves: 200
  point -> sum leaves: [ [ x y + ] ] "Beware!"

  "Note that we still can open it and get the result:"
  open leaves: 300
  ```

  It is possible to access multiple entries when Name is a
  block, *preserving block structure*:

  ```
  [ 100 $: x 200 $: y ] obj -> [ x y ] leaves: [ [ 100 200 ] ]
  [ 100 $: x 200 $: y ] obj -> [ [ [ x ] ] y ] leaves: [ [ [ [ 100 ] ] 200 ] ]
  ```
  """
  ahead thru _arrowFetchImpl
] @: ->


[ """( Db . N -- ... ): resolves Name in Dictionary block and
   *opens* it. Infix version of `entry:open`.

  `.` is the only word that gets special treatment in
  Novika, in that it does not need to be surrounded with
  whitespace when other words must be.

  ```
  [ 100 $: x 200 $: y [ x y + ] @: sum ] obj $: point

  point.x leaves: 100
  point.y leaves: 200
  point.sum leaves: 300
  ```

  Preserves (carries through) `ahead`, but makes the caller
  block's instance dirty (which should not cause any trouble
  from the user's perspective).

  ```
  [ $: double?

    [ ahead thru double? => [ 2 * ] ] @: bar:

    this
  ] @: foo

  true foo.bar: 100 leaves: [ 200 ]
  false foo.bar: 100 leaves: [ 100 ]
  ```
  """
  ahead dup thru entry:open
] @: .


[ """( Db N fetch: B -- ): resolves Name using Dictionary
   block, and opens Block with the resolved entry's value
   form *on top of the caller stack.* If Name could not be
   resolved using the dictionary block, or if the dictionary
   block  is something other than block, does nothing.
   Itself, leaves nothing (unless Block is empty: in that
   case, leaves the value form if resolved successfully).

  ```
  'This is not a block!' #x fetch: [ 1 + ] leaves: [ ]
  [ 100 $: x ] obj #x fetch: [ 1 + ] leaves: [ 101 ]
  [ 100 $: x ] obj #undefinedThing fetch: [ 1 + ] leaves: [ ]
  ```
  """
  ahead thruBlock @: block

  [ over block? ] [ 2dup entry:exists? ] and
    [ entry:fetch block ] "Has the entry, fetch and open Block."
    [ 2drop             ] "Doesnt have, drop T N."
  br
] @: fetch:


[ """( Lb B -- Lb ): slides cursor in List block from left
   to right, in steps of one. Opens Block with List block as
   the stack *after* each step. Leaves List block. `break`
   and `next` are available.

  ```
  [ 1 2 3 ] dup 1 |to [ + ] |slideRight leaves: [ [ 6 ] ]
  ```

  In the table below, sliding step is marked with '*', and
  block iteration is postfixed by a '+'.

  ```text
   +------+-------+-------------+
   | #    | form  |    list     |
   +======+=======+=============+
   | 0    |       | [ 1 2 3 ]   |
   | 1    | 1 |to | [ 1 | 2 3 ] |
   | *    |       | [ 1 2 | 3 ] |
   | 3+   |    +  | [ 3 | 3 ]   |
   | *    |       | [ 3 3 ]     |
   | 5+   |    +  | [ 6 ]       |
   +------+-------+-------------+
  ```
  """
  $: body $: list

  body
  [ list dup |at over count < ]
  [ list dup |at 1 + |to
    list swap hydrate ]
  createDetachedLoop open

  list
] @: |slideRight


[ "( Lb |-> B -- Lb ): infix version of `|slideRight`."
  ahead thruBlock |slideRight
] @: |->


[ """( Lb |~> B -- Lb ): similar to `|->`, but remembers the
   cursor position in List block and restores it after all
   items were visited by Block (clamping to either end,
   if necessary).

  ```
  [ 1 2 3 ] $: x

  x 1 |to
  x toQuote leaves: '[ 1 | 2 3 ]'

  x |~> [ 1 + ]
  x toQuote leaves: '[ 1 | 3 4 ]'
  ```
  """
  ahead thruBlock over |at <| |slideRight dup |> |clamp
] @: |~>


[ """( Lb ||-> B -- Lb ): same as `|->`, but moves the cursor
   to the start of List block first, then executes Block and
   so on. See `|->` and especially `|slideRight` for more
   information on what all of this means.

  ```
  [ 1 2 3 ] ||-> [ 2 * ] leaves: [ [ 2 4 6 ] ]
  ```
  """
  dup 0 |to ahead thruBlock |slideRight
] @: ||->


[ """( Lb |~> B -- Lb ): similar to `||->`, but remembers
   the cursor position in List block and restores it after
   all items were visited by Block (clamping to either end,
   if necessary).

  ```
  [ 1 2 3 ] $: x

  x 1 |to
  x toQuote leaves: '[ 1 | 2 3 ]'

  x ||~> [ 1 + ]
  x toQuote leaves: '[ 2 | 3 4 ]'
  ```
  """
  ahead thruBlock over |at <| over 0 |to |slideRight dup |> |clamp
] @: ||~>


[ "( Lb B -- Lb ): similar to `|->`, but slides the cursor
   from right to left. Consult `|slideRight`. `break` and
   `next` are available."
  $: body $: list

  body
  [ list |at 0 > ]
  [ list count $: tmp
    list swap hydrate
    list count tmp >= => [
      "If the amount of items in the list has not changed,
       or increased, slide leftwards by delta + 1, meaning
       by the amount of items added, plus once leftwards to
       maintain the movement left."
      list count tmp - 1 + $: delta
      list dup |at delta - |to
    ]
  ] createDetachedLoop open

  list
] @: |slideLeft


[ "( Lb <-| B -- Lb ): infix version of `|slideLeft`."
  ahead thruBlock |slideLeft
] @: <-|


[ """( Lb B -- ): opens Block with each item of List block on
   top of a new stack, and its index below (that is, `Index
   Item`). List block is unchanged. `break` and `next` are
   available.

  ```
  [ 1 2 3 ] [ 2echo ] eachWithIndex
  "STDOUT: 0 1⏎"
  "STDOUT: 1 2⏎"
  "STDOUT: 2 3⏎"
  ```
  """
  $: body $: list 0 $: index

  body [ index list count < ] [
    index list index fromLeft 2enclose swap hydrate
    index 1 + =: index
  ] createDetachedLoop open
] @: eachWithIndex


[ """( Lb B -- ): opens Block with each item of List block on
   top of a new stack. List block is unchanged. `break` and
   `next` are available.

  ```
  [ 1 2 3 ] [ echo ] each
  "STDOUT: 1⏎"
  "STDOUT: 2⏎"
  "STDOUT: 3⏎"
  ```
  """
  $: body $: list 0 $: index

  body [ index list count < ] [
    list index fromLeft enclose swap hydrate
    index 1 + =: index
  ] createDetachedLoop open
] @: each


[ """( Lb each: B -- ): infix version of `each`.

  ```
  [ 1 2 3 ] each: [ echo ]
  "STDOUT: 1⏎"
  "STDOUT: 2⏎"
  "STDOUT: 3⏎"
  ```
  """
  ahead thruBlock each
] @: each:


[ """( Lb eachWithIndex: B -- ): infix version of `eachWithIndex`.

  ```
  [ 1 2 3 ] eachWithIndex: [ 2echo ]
  "STDOUT: 0 1⏎"
  "STDOUT: 1 2⏎"
  "STDOUT: 2 3⏎"
  ```
  """
  ahead thruBlock eachWithIndex
] @: eachWithIndex:


[ """( Lb B -- ): opens Block with pairs of items from
   List block on top of an empty stack. `break` and `next`
   are available. Does nothing if List block is empty. Dies
   if List block has an odd number of forms.

  ```
  [ 1 2 3 4 ] [ + echo ] pairs
  "STDOUT: 3⏎ (i.e., 1 + 2)"
  "STDOUT: 7⏎ (i.e., 3 + 4)"
  ```
  """
  $: block

  dup empty? => [ drop ^ ]
  dup count odd? => [ 'for pairs to work, there should be an even count of items in block' die ]

  $: list 0 $: index

  block [ index list count < ]
  [
    list index     fromLeft
    list index 1 + fromLeft
    2enclose swap hydrate
    index 2 + =: index
  ] createDetachedLoop open
] @: pairs


[ """( Lb pairs: B -- ): infix version of `pairs`.

  ```
  [ 1 2 3 4 ] pairs: [ + echo ]
  "STDOUT: 3⏎"
  "STDOUT: 7⏎"
  ```
  """
  ahead thruBlock pairs
] @: pairs:


[ """( Lb B -- Rb ): leaves Result block obtained by collecting
   results of Block opened with previous Result block as the stack,
   plus a pair of items from List block, for each pair of items
   in List block. Dies if List block has an odd number of forms.
   `break` and `next` are available.

  ```
  "Sum pairs of numbers 1, 2; 3, 4; 5, 6 etc.:"
  1 to: 10 mapPairs: + leaves: [ [ 3 7 11 15 19 ] ]
  ```
  """
  $: block

  [ ] $: result

  dup empty? => [ drop result ^ ]
  dup count odd? => [ 'for mapPairs to work, there should be an even count of items in block' die ]

  $: list 0 $: index

  block [ index list count < ]
  [
    result
      (list index     fromLeft) <<
      (list index 1 + fromLeft) <<
    swap hydrate

    index 2 + =: index
  ] createDetachedLoop open

  result
] @: mapPairs


[ """( Lb mapPairs: B -- Rb ): infix version of `mapPairs`.

  ```
  "Sum pairs of numbers 1, 2; 3, 4; 5, 6 etc.:"
  1 to: 10 mapPairs: + leaves: [ [ 3 7 11 15 19 ] ]
  ```
  """
  ahead thruBlock mapPairs
] @: mapPairs:


[ """( Lb B -- ): opens Block with consequtive pairs of items
   from List block on top of an empty stack. `break` and `next`
   are available.

  ```
  [ ] [ + echo ] consPairs
  [ 1 ] [ + echo ] consPairs
  "Both do nothing!"

  [ 1 2 ] [ + echo ] consPairs
  "STDOUT: 3⏎ (i.e, 1 + 2)"

  [ 1 2 3 ] [ + echo ] consPairs
  "STDOUT: 3⏎ (i.e., 1 + 2)"
  "STDOUT: 5⏎ (i.e., 2 + 3)"
  ```
  """
  $: block

  dup empty? => [ drop ^ ]

  $: list 0 $: index

  block [ index list count 1 - < ]
  [
    list index     fromLeft
    list index 1 + fromLeft
    2enclose swap hydrate
    index 1 + =: index
  ] createDetachedLoop open
] @: consPairs


[ """( Lb B -- ): infix version of `consPairs`.

  ```
  [ 1 2 3 ] consPairs: [ + echo ]
  "STDOUT: 3⏎"
  "STDOUT: 5⏎"
  ```
  """
  ahead thruBlock consPairs
] @: consPairs:


[ """( Lb B -- Rb ): leaves Result block obtained by collecting
   results of Block opened with previous Result block as the stack,
   plus a **consecutive** pair of items from List block, for each
   consecutive pair of items in List block. `break` and `next`
   are available.

  ```
  "Sum pairs of numbers 1, 2; 2, 3; 3, 4 etc.:"
  1 to: 10 mapConsPairs: + leaves: [ [ 3 5 7 9 11 13 15 17 19 ] ]
  ```
  """
  $: block

  [ ] $: result

  dup empty? => [ drop result ^ ]

  $: list 0 $: index

  block [ index list count 1 - < ]
  [
    result
      (list index     fromLeft) <<
      (list index 1 + fromLeft) <<
    swap hydrate

    index 1 + =: index
  ] createDetachedLoop open

  result
] @: mapConsPairs


[ """( Lb mapConsPairs: B -- Rb ): infix version of `mapConsPairs`.

  ```
  "Sum pairs of numbers 1, 2; 2, 3; 3, 4 etc.:"
  1 to: 10 mapConsPairs: + leaves: [ [ 3 5 7 9 11 13 15 17 19 ] ]
  ```
  """
  ahead thruBlock mapConsPairs
] @: mapConsPairs:


[ """( Lb B -- Mlb ): opens Block with each item of List block
   on top of an empty stack. Replaces item in List block with
   Block's stack top after opening it. Leaves the resulting
   Modified list block. `break` and `next` are available.

  ```
  [ 1 2 3 ] [ 1 + ] map leaves: [ [ 2 3 4 ] ] "(a different block!)"

  [ 1 2 3 ] $: a
  a [ 1 + ] map leaves: [ [ 2 3 4 ] ] "(a different block!)"
  a leaves: [ [ 1 2 3 ] ]
  ```
  """
  $: block $: list [ ] $: result

  list empty? => [ result ^ ]

  0 $: index

  block [ index list count < ]
  [
    list index fromLeft enclose swap there dup empty?
      [ "No result: probably the user wants it out." drop ]
      [ cherry result gulp ]
    br
    index 1 + =: index
  ] createDetachedLoop open

  result
] @: map


[ """( Lb map: B -- MLb ): infix version of `map`.

  ```
  [ 1 2 3 ] map: [ 1 + ] leaves: [ 2 3 4 ]
  ```
  """
  ahead thruBlock map
] @: map:


[ """( Lb B -- Rb ): opens Block with each item of List block
   on top of an empty stack. Removes that item in Result block
   if Block's stack top is false after it was opened. `break`
   and `next` are available.

  ```
  [ ] [ 100 > ] only
    leaves: [ [ ] ] "(a different block!)"

  [ 1 2 3 ] [ ] only
    leaves: [ [ 1 2 3 ] ] "(a different block!)"

  [ 1 100 2 300 4 600 10 ] [ 100 > ] only
    leaves: [ [ 300 600 ] ]
  ```
  """
  $: block $: list [ ] $: result

  list empty? => [ result ^ ]

  0 $: index

  block [ index list count < ]
  [
    list index fromLeft dup enclose rot there dup empty?
      [ "No result: probably the user wants it out." drop ]
      [ cherry => [ result gulp ] ]
    br
    index 1 + =: index
  ] createDetachedLoop open

  result
] @: only


[ "( Lb B -- Rb ): inverse of `only`."
  @: block [ block not ] only
] @: without


[ """( Lb only: B -- Rb ): infix version of `only`.

  ```
  [ 1 100 2 300 4 600 10 ] only: [ 100 > ]
    leaves: [ [ 300 600 ] ]
  ```
  """
  ahead thruBlock only
] @: only:


[ """( Lb without: B -- MLb ): infix version of `without`.

  ```
  [ 1 100 2 300 4 600 10 ] without: [ 100 > ]
    leaves: [ [ 1 100 2 4 10 ] ]
  ```
  """
  ahead thruBlock without
] @: without:


[ """( Lb B M -- M ): reduces List block using Block. Block
   is opened with Memo, current item on top of an empty stack.
   Memo is updated to Block's value after Block is opened.
   `break` and `next` are available.

  ```
  [ ] [ + ] 0 reduce
    leaves:  0

  [ 1 ] [ + ] 0 reduce
    leaves: 1 "(i.e., 0 + 1)"

  [ 1 2 3 ] [ + ] 0 reduce
    leaves: 6

  [ 'Hellope, ' 'Europe!' ' ' 'Huh?' ] [ stitch ] '' reduce
    leaves: 'Hellope, Europe! Huh?'
  ```

  Supports stack reduction:

  ```
  '1' '2' '3' stack [ stitch ] '' reduce
    leaves: '123'
  ```
  """
  $: memo $: block $: list

  "List is empty: just leave the memo."
  list empty?    => [ memo ^ ]

  "List is the stack. This is a special-case, for we must drop
   instead of peeking."
  list stack same? =>
    [
      [ "For extra safety, we're running under 'do', which will
          protect us from modifying our own stack (which `stack`
          is) and causing all sorts of weirdness."
        list |slice
          $: afterCursor
          $: beforeCursor

        beforeCursor block memo reduce enclose afterCursor concat!
          $: result

        result list resub list 1 |to
     ] do
     ^
    ]

  0 $: index

  block [ index list count < ]
  [
    memo list index fromLeft 2enclose swap there cherry =: memo
    index 1 + =: index
  ] createDetachedLoop open

  memo
] @: reduce


[ """( Lb B -- A ): leaves the Amount of items for which Block,
   when opened with an item from List block on top of an
   empty stack, leaves a truthy form. `break` and `next` are
   available.

  ```
  [ 1 2 3 ] [ 2 > ] amount leaves: 1
  [ 1 2 3 ] [ 100 > ] amount leaves: 0
  [ 1 5000 2 4400 1 100 102 ] [ 100 <= ] amount
    leaves: 4 "(i.e., 1, 2, 1, 100)"
  """
  $: block $: list

  list empty? => [ 0 ^ ]

  0 $: amt
  0 $: index

  "Go thru each item and check if block opens to true there,
   if it does, increment the count."
  block [ index list count < ]
  [
    list index fromLeft enclose swap there cherry => [ amt 1 + =: amt ]
    index 1 + =: index
  ] createDetachedLoop open

  amt
] @: amount


[ """( Lb B -- A ): infix version of `amount`.

  ```
  [ 1 2 3 ] # [ 2 > ] leaves: 1
  ```
  """
  ahead thruBlock amount
] @: #


[ """( Lb B -- true/false ): whether Block leaves true for all
   items in List block, when opened with each item on top of
   an empty stack.

  ```
  [ ] [ 100 < ] all? leaves: true "BEWARE!"
  [ 1 2 3 ] [ 100 < ] all? leaves: true
  [ 101 2 3 4 ] [ 100 < ] all?
    leaves: false "(i.e., because of 101)"
  ```
  """
  @: block true $: status

  "Go thru each item and check if block opens to true there;
   if it doesn't, quit the loop with status = false."
  each: [ block not => [ false =: status break ] ]

  status
] @: all?


[ """( Lb all: B -- true/false ):  infix version of `all?`

  ```
  [ ] all: even? leaves: true "BEWARE!"
  [ 1 2 3 ] all: even? leaves: false
  ```
  """
  ahead thruBlock all?
] @: all:


[ """( Lb B -- true/false ): whether Block leaves true for any
   item in List block, when opened with each item on top of an
   empty stack.

  ```
  [ ] [ 100 < ] any? leaves: false "BEWARE!"
  [ 1 2 3 ] [ 3 = ] any? leaves: true
  [ 101 3 2000 ] [ 100 < ] any? leaves: true
  [ 1002 350 2000 ] [ 100 < ] any? leaves: false
  ```
  """
  @: block false $: status

  "Go thru each item and check if block opens to true there;
   if it does, quit the loop with status = true."
  each: [ block => [ true =: status break ] ]

  status
] @: any?


[ """( F anyof: B -- true/false ): infix version of `anyof?`.

  ```
  100 anyof: [ 1 2 3 ] leaves: false
  #foo anyof: [ foo bar ] leaves: true

  [ 1 2 3 ] $: x
  1 anyof: x leaves: true
  #foo anyof: x leaves: false
  ```
  """
  ahead thruLitBlock anyof?
] @: anyof:


[ """( A B -- Z ): leaves Zipped A, B. Dies if there is a
   different amount of items in A and B.

  ```
  [ ] [ ] zip leaves: [ [ ] ]
  [ 1 2 ] [ 3 4 ] zip leaves: [ [ [ 1 3 ] [ 2 4 ] ] ]
  ```
  """
  $: b $: a

  (a count) (b count) = not =>
    [ 'counts must be equal with zip, otherwise use zipWithDefault' die ]

  (a count) collect: [ dup
    a swap fromLeft swap
    b swap fromLeft 2enclose
  ]
] @: zip


[ """( A B D -- Zb ): leaves Zipped A, B with holes
   filled by the given Default form.

  ```
  [ ] [ ] #hole zipWithDefault leaves: [ [ ] ]

  [ 1 2 ] [ 3 4 ] #hole zipWithDefault
    leaves: [ [ [ 1 3 ] [ 2 4 ] ] ]

  [ 1 2 ] [ 3 ] #hole zipWithDefault
    leaves: [ [ [ 1 3 ] [ 2 hole ] ] ]

  [ 1 ] [ 3 4 ] #hole zipWithDefault
    leaves: [ [ [ 1 3 ] [ hole 4 ] ] ]
  """
  $: default

  #_    $: longer
  #_    $: smaller
  0     $: missing
  false $: swapped

  over count "A count"
  over count "B count"
  2dup < "A < B"
    [ swap -  =: missing
      true    =: swapped
      "B"     =: longer
      "A" shallowCopy =: smaller ]
    [ -       =: missing
      "B" shallowCopy =: smaller
      "A"     =: longer ]
  br

  missing times: [ smaller default shove ]

  longer smaller swapped => [ swap ] zip
] @: zipWithDefault


[ """( A zip: B -- Z | A zip: B withDefault: D -- Z ): combined
   infix for `zip` and `zipWithDefault`.

  ```
  [ 1 2 ] zip: [ 3 4 ] leaves: [ [ [ 1 3 ] [ 2 4 ] ] ]
  [ 1 2 ] zip: [ x y ] leaves: [ [ [ 1 x ] [ 2 y ] ] ]
  [ a b ] zip: [ 'Hi!' ] withDefault: 0 leaves: [ [ [ a 'Hi!' ] [ b 0 ] ] ]
  ```
  """
  ahead $: caller
  ahead thruLitBlock

  ${ a b }

  "Fallback to `zip` when there isn't any word following
   the B form."
  caller peek? not => [ a b zip ^ ]

  [ "( A zip: B withDefault: D )"
    #withDefault: [ drop
      caller 1 |+
      caller thruVal $: default
      a b default zipWithDefault
    ]

    "Fallback to `zip` when there is some other form ahead."
    [ ] [ drop a b zip ]
  ] choose
] @: zip:


[ """( S D -- I ): given a Source block and a Destination
   block, leaves an Instance of Destination block with all
   words (see `word?`) replaced with entry values from
   dictionary of Source (they are **not** opened), and all
   quoted words unquoted (see `quotedWord?`). Recurses on
   sub-blocks.

  ```
  1 $: x
  2 $: y
  #+ $: plus

  this [ x y plus #dup plus [ ##foo #echo ] #open ] conjure
    leaves: [ [ 1 2 + dup + [ #foo echo ] #open ] ]

  open leaves: 6
  "STDOUT: foo⏎"
  ```
  """
  swap $: source

  "If it's a word, replace it with word's value in source, if
   it's a quoted word, unquote it, if it's a block, then recurse
   on its elements, else, leave it."
  dup word?       => [ source swap entry:fetch      ^ ]
  dup block?      => [ map: [ source swap conjure ] ^ ]
  dup quotedWord? => [ open ^ ]
] @: conjure


[ """( B -- I ): `conjure` with Source block set to caller.

  ```
  1 $: x
  2 $: y
  #+ $: plus

  [ x y plus #dup plus [ ##foo #echo ] #open ] here
    leaves: [ [ 1 2 + dup + [ #foo echo ] #open ] ]

  open leaves: 6 "STDOUT: foo⏎"
  ```
  """
  ahead swap conjure
] @: here


[ """( Lb -- Min Max ): leaves decimal minimum, maximum in
   List block. Use `minmaxBy` if List block doesn't (or doesn't
   always) contain solely decimals. If an empty block is given,
   dies, so make sure to handle that yourself.

  ```
  [ 1 2 3 ] minmax leaves: [ 1 3 ]
  ```
  """

  "NOTE: this is separate from minmaxBy for performance reasons only;
   otherwise, having `[ ] minmaxBy` would be sufficient here."

  dup empty? => [ 'Cannot minmax an empty block' die ]

  dup first
    dup $: min
        $: max

  each: [
    dup min < => [ =: min ^ ]
    dup max > => [ =: max ^  ]
  ]

  min max
] @: minmax


[ """( Lb -- Min ): leaves decimal minimum in List block.
   See `minmax`.

  ```
  [ 1 2 3 ] min leaves: 1
  ```
  """
  minmax drop
] @: min


[ """( Lb -- Max ): leaves decimal maximum in List block.
   See `minmax`.

  ```
  [ 1 2 3 ] max leaves: 3
  ```
  """
  minmax nip
] @: max


[ """( Lb -- Sum ): leaves decimal sum of List block elements.
   For more control (or if not always decimal), use `sumBy`.

  ```
  [ ] sum leaves: 0
  [ 1 ] sum leaves: 1
  [ 1 2 3 ] sum leaves: 6
  ```
  """
  [ + ] 0 reduce
] @: sum


[ """( Lb -- Product ): leaves decimal product of List block
   elements. For more control (or if not always decimal), take
   a look at `productBy`.

  ```
  [ ] product leaves: 1
  [ 3 ] product leaves: 3
  [ 5 4 3 2 ] product leaves: 120
  ```
  """
  [ * ] 1 reduce
] @: product


[ """( Lb Tb -- Min Max ): leaves the minimum and maximum
   values in List block. Decimal values are obtained via the
   Transformation block, which is opened with each element
   of List block on top of an empty stack. If List block is
   empty, dies, so make sure to handle that yourself.

  ```
  [ 1 2 3 ] [ ] minmaxBy leaves: [ 1 3 ]
  [ 'A short quote' 'A loooonger quote' 'Veeeeeeeeeeery long quote' ] [ count ] minmaxBy
    leaves: [ 'A short quote' 'Veeeeeeeeeeery long quote' ]
  """
  dup empty? => [ drop minmax ^ ] $: transformer
  dup empty? => [ 'Cannot minmax an empty block' die ]

  dup first "Get the first item in the List block."
    dup $: min "Original minimum."
    dup $: max "Original maximum."
    enclose transformer there cherry
      dup $: dMin "Transformed minimum."
          $: dMax "Transformed maximum."

  each: [
    dup enclose transformer there cherry
    dup dMin < => [ =: dMin =: min ^ ]
    dup dMax > => [ =: dMax =: max ^ ]
  ]

  min max
] @: minmaxBy


[ """( Lb Tb -- Min ): leaves the minimum value in List
   block. Each element of List block is transformed using
   Transformation block. See `minmaxBy`.

  ```
  [ 1 2 3 ] [ ] minBy leaves: 1
  ```
  """
  minmaxBy drop
] @: minBy


[ """( Lb Tb -- Max ): leaves the maximum value in List
   block. Each element of List block is transformed using
   Transformation block. See `minmaxBy`.

  ```
  [ 1 2 3 ] [ ] maxBy leaves: 3
  ```
  """
  minmaxBy nip
] @: maxBy


[ """( Lb Tb -- Sum ): leaves Sum of List block elements
   transformed into decimals by Transformation block.
   Similar to `minmaxBy`.

  ```
  [ 'a' 'aaa' 'aa' ] [ count ] sumBy leaves: 6
  ```
  """
  $: transformer

  [ enclose transformer there cherry + ] 0 reduce
] @: sumBy


[ """( Lb sumBy: Tb -- Sum ): infix version of `sumBy`.

  ```
  [ 'a' 'aaa' 'aa' ] sumBy: count leaves: 6
  ```
  """
  ahead thruBlock sumBy
] @: sumBy:


[ """( Lb Tb -- P ): leaves Product of List block elements
   transformed into decimals by Transformation block. Similar
   to `sumBy`.

  ```
  [ 'dave' 'john' ] [ count ] productBy leaves: 16 "4 * 4"
  ```
  """
  $: transformer

  [ enclose transformer there cherry * ] 1 reduce
] @: productBy


[ """( Lb productBy: Tb -- Sum ): infix version of `productBy`.

  ```
  [ 'dave' 'john' ] productBy: count leaves: 16 "4 * 4"
  ```
  """
  ahead thruBlock productBy
] @: productBy:


[ """( N B -- Lb ): leaves a List block with N results of
   opening Block with the current N. Basically a combo of
   `times` and `map`. `break` and `next` are available. The
   current result is skipped if stack is empty after opening
   Block.

  ```
  3 [ readLine br: [ stack swap slurp ] 0 ] collect
  INPUT: 0 3
  INPUT: 1 5
  INPUT: 2 12

  leaves: [ [ 3 5 12 ] ]
  ```
  """
  $: block $: max [ ] $: result

  max negative? => [ 'collect: cannot have negative amount' die ]

  0 $: current

  block [ current max < ]
  [
    current enclose swap there dup empty? not =>
      [ cherry result gulp ]
    current 1 + =: current
  ] createDetachedLoop open

  result
] @: collect


[ "( N collect: B -- Lb ): infix version of `collect`."
  ahead thruBlock collect
] @: collect:


[ """( N B -- Lb ): same as `collect`, but powered by `compiledTimes`
   under the hood. Faster than `collect` for large N, but slower if
   opened a lot of times in a row.

  Please read `compiledTimes` to understand why have the whole
  deal with *unsafe* and *fast*.

  Does **not** support `break` and `next`.
  """
  $: block $: max [ ] $: result

  max negative? => [ 'compiledCollect: cannot have negative amount' die ]
  max compiledTimes: [ "( I -- I )"
    (dup enclose block there) dup empty? not br:
      [ cherry result gulp ]
      drop
  ]

  result
] @: compiledCollect


[ "( N compiledCollect: B -- Lb ): infix version of `compiledCollect`."
  ahead thruBlock compiledCollect
] @: compiledCollect:


[ """( B Gb -- Gl ): groups forms in Block according to
   Grouper block. Leaves a Group list. Grouper block is
   opened with consequent items on top of an empty stack.
   Grouper block can leave any form except block. Order of
   groups in Group list is the same as in Block, i.e., if
   the first item in Block is is in group G1, then the first
   group in Group list will be G1.

  If necessary, the form Grouper block leaves for a particular
  group can be accessed with `.id` on each group block in
  Group list.

  Note though, that Group members do not have access to
  their Grouper block's `id`.

  ```
  [ 1 2 3 ] [ 1 > ] groupBy leaves: [ [ [ 1 ] [ 2 3 ] ] ]
  [ 1 2 3 ] [ 1 <= ] groupBy leaves: [ [ [ 1 ] [ 2 3 ] ] ]

  [ 1 2 3 ] [ 1 <= ] groupBy [ .id ] map
    leaves: [ [ true false ] ] "The two groups, true and false."

  [ 1 2 3 ] [ 1 <= 'foo' 'bar' sel ] groupBy [ dup .id 2enclose ] map
    leaves: [ [ [ [ 1 ] 'foo' ] [ [ 2 3 ] 'bar' ] ] ]
  ```
  """
  asBlock $: grouper asBlock $: block

  block empty? => [ [ ] ^ ]

  orphan $: groupMap

  block each: [ $: element
    element enclose grouper there cherry $: group
    groupMap group entry:exists? br:
      [ groupMap group entry:fetch ]
      [ "Create an orphan for ID, and another orhpan child for
         group elements. This lets the user '=' but still have
         'id' without additional trickery."
        orphan orphan dup #id group pushes reparent dup
        <| groupMap group |> pushes ]
    element shove
  ]

  groupMap ls map: [ groupMap swap entry:fetch ]
] @: groupBy


[ """( B Gb -- Gl ): infix version of `groupBy`. See
   `groupBy` for information.

  ```
  [ 1 2 3 ] groupBy: [ 1 > ] leaves: [ [ [ 1 ] [ 2 3 ] ] ]
  [ 1 2 3 ] groupBy: [ 1 <= ] leaves: [ [ [ 1 ] [ 2 3 ] ] ]

  [ 1 2 3 ] groupBy: [ 1 <= ] map: [ .id ]
    leaves: [ [ true false ] ]

  [ 1 2 3 ] groupBy: [ 1 <= 'foo' 'bar' sel ] map: [ dup .id 2enclose ]
    leaves: [ [ [ [ 1 ] 'foo' ] [ [ 2 3 ] 'bar' ] ] ]
  ```
  """
  ahead thruBlock groupBy
] @: groupBy:


[ """( B E -- Rb ): leaves Range block containing decimals
   between the given Begin, End decimal boundaries: [B; E],
   [E; B] if  E < B.

  ```
  "Note: `...` means there's more. These 'leaves:'
   expressions won't run right away."

  1 100 range leaves: [ 1 2 3 "..." 98 99 100 ]
  -10 10 range leaves: [ -10 -9 -8 "..." 8 9 10 ]
  10 0 range leaves: [ 10 9 8 "..." 0 ]
  ```
  """
  $: e $: b

  e b <
    [ b e - 1 + compiledCollect: [ b swap - ] ]
    [ e b - 1 + compiledCollect: [ b + ] ]
  br
] @: range


[ """( B to: E -- Rb ): infix version of `range`.

  ```
  "Note: `...` means there's more. These 'leaves:'
   expressions won't run right away."

  1 to: 100 leaves: [ 1 2 3 "..." 98 99 100 ]
  10 to: 0 leaves: [ 10 9 8 "..." 0 ]
  ```
  """
  ahead thruVal range
] @: to:


[ """( B from: Bi to: Ei -- Bs ): takes a slice of Block, starting
   at Begin index, and ending at End index. Both ends are inclusive.
   Leaves the resulting Block slice.

  Block slice is an orphan. Both ends are clamped to Block bounds.

  ```
  [ ] from: 0 to: 0 leaves: [ [ ] ]
  [ 1 2 3 4 ] from: 1 to: 2 leaves: [ [ 2 3 ] ]
  [ 1 2 3 4 ] from: 0 to: 200 leaves: [ [ 1 2 3 4 ] ]
  [ 1 2 3 4 ] from: 100 to: 200 leaves: [ [ ] ]
  ```
  """
  toTape $: block

  ahead thruVal asDecimal clamp: 0 [ block count ] $: b
  ahead thruWord: to:
  "We have to add one because $e is a form index but
   we want a cursor index for it."
  ahead thruVal asDecimal 1 + clamp: 0 [ block count ] $: e

  block empty? => [ block ^ ]

  "[ 1 2 3 4 ] from: 1 to: 2"
  "[ 1 2 3 | 4 ]"
  "[ 1 2 3 | ] [ 4 | ]"
  "[ 1 | 2 3 ]"
  "[ 1 | ] [ 2 3 | ]"
  "[ 2 3 | ]"
  block (dup e |to) |slice drop
        (dup b |to) |slice nip

  toOrphan
] @: from:


[ """( Fl -- Q ): stitches enquoted forms from Form list and
   leaves the resulting Quote.

  ```
  [ 'A' 'B' 'C' ] join leaves: 'ABC'

  1 $: x
  2 $: y
  [ x '; ' y ] here join leaves: '1; 2'
  ```
  """
  asBlock [ toQuote stitch ] '' reduce
] @: join


[ """( Fl Df -- Q ): stitches enquoted forms from Form
   list and leaves the resulting Quote. Enquotes and
   inserts Delimiter form between the pairs.

  ```
  [ 'a' 'b' '=' 1 ] ' ' sepBy leaves: 'a b = 1'
  ```
  """
  toQuote $: sep
  asBlock $: formList

  '' $: result

  formList eachWithIndex: [ $: form $: index
    result form toQuote stitch
    index formList count 1 - = not =>
      [ sep stitch ]
    =: result
  ]

  result
] @: sepBy


[ "( Fl sepBy:/join: D -- Q ): infix version of `sepBy`."
  ahead thruVal sepBy
] dup @: sepBy:
      @: join:


[ """( B1 B2 -- B1 ): adds elements before cursor in B2
   after cursor in B1. Advances the cursor in B1 by the
   number of added elements.

  ```
  [ 1 2 3 ] [ 4 5 6 ] concat!
    leaves: [ [ 1 2 3 4 5 6 ] ]
  ```
  """
  nup shove*
] @: concat!


[ """( B1 B2 -- Br ): concatenates two Blocks.

  ```
  [ 1 2 3 ] [ 4 5 6 ] concat
    leaves: [ [ 1 2 3 4 5 6 ] "(a new block!)" ]
  ```
  """
  <| shallowCopy |> concat!
] @: concat


[ """( -- Wl ): leaves Word list block that contains words
   defined (*resolvable*) in caller and in its relatives.

  ```
  0 $: y [ 1 $: x ls* ] open leaves: [ [ "..." y x ] ]
  ```

  As opposed to `ls`, which leaves only block's own words:

  ```
  0 $: y [ 1 $: x this ls ] open leaves: [ [ x ] ]
  ```
  """
  [ ] $: result
  [
    result over ls concat! drop
    dup orphan?
      [ drop ]
      [ parent rec ]
    br
  ] @: rec

  ahead rec result
] @: ls*


[ "( B -- true/false ): leaves whether Block has a description."
  desc 'a block' = not
] @: hasDesc?


[ """( Lb C -- Sfb true/false ): slides right (see `|slideRight`)
   through List block, executes Condition block for each form under
   the cursor. Stops *after* form if Condition block left true for it.
   Leaves Skipped forms block. Leaves true when Condition matched,
   false when reached the end of List block without a match.

  Note: if Condition is not a block, it is wrapped like so:
  `[ C = ]`.

  Useful for writing parsers for Novika DSLs.

  ```
  [ 1 2 3 4 5 6 ] $: a
  a 1 |to
  a toQuote leaves: '[ 1 | 2 3 4 5 6 ]''

  [ 4 = ] |afterOrToEnd? leaves: [ [ 2 3 ] true ]

  a echo
  "STDOUT: [ 1 2 3 4 | 5 6 ]⏎"
  ```
  """
  ahead $: caller

  "Support literal pattern arguments like `[ 1 2 3 4 ] 3 |afterOrToEnd?`
   by wrapping in a block together with '=' (`[ 3 = ]`)."
  dup block? not => [ #= 2enclose caller reparent ] @: cond

  false  $: match
  orphan $: memo

  |-> [ dup cond => [ true =: match break ] dup memo gulp ] drop

  memo match
] @: |afterOrToEnd?


[ "( Lb |afterOrToEnd?: C -- Sfb ): infix version of `|afterOrToEnd?`."
  ahead thru |afterOrToEnd?
] @: |afterOrToEnd?:


[ "( Lb C -- Sfb ): same as `|afterOrToEnd?`, but disregards
   whether the end was reached instead of Condition matching."
  |afterOrToEnd? drop
] @: |afterOrToEnd


[ "( Lb |afterOrToEnd: C -- Sfb ): infix version of `|afterOrToEnd`."
  ahead thru |afterOrToEnd
] @: |afterOrToEnd:


[ """( Lb C -- Sfb ): same as `|afterOrToEnd?`, but dies when reached
   end of List block without matching.

  When Condition is a block, its desc, if available, is
  displayed as the thing that was expected. Otherwise,
  Condition itself is displayed.

  ```
  [ 1 2 3 4 5 6 ] $: a
  a 1 |to
  a toQuote leaves: '[ 1 | 2 3 4 5 6 ]''

  a 4 |afterOrDie leaves: [ [ 2 3 ] ]
  a echo
  "STDOUT: [ 1 2 3 4 | 5 6 ]⏎"
  ```
  """
  dup $: cond

  |afterOrToEnd? => ^

  drop

  cond dup block? =>
    [ dup hasDesc? => desc ]
  $: what

  [ 'expected ⸢' what '⸥ to match, but reached end of block' ] ~* die
] @: |afterOrDie


[ "( Lb |afterOrDie: C -- Sfb ): infix version of `|afterOrDie`."
  ahead thru |afterOrDie
] @: |afterOrDie:


[ """( Lb C -- Sfb true/false ): similar to `|afterOrToEnd?`, but
   leaves the cursor in List block *before* the matching
   item.

  ```
  [ 1 2 3 4 5 6 ] $: a
  a 1 |to
  a toQuote leaves: '[ 1 | 2 3 4 5 6 ]'

  a 4 |beforeOrToEnd leaves: [ [ 2 3 ] ]
  a echo
  "STDOUT: [ 1 2 3 | 4 5 6 ]⏎"
  ```
  """
  over $: list

  |afterOrToEnd? dup => [ list 1 |- ]
] @: |beforeOrToEnd?


[ "( Lb |beforeOrToEnd?: C -- Sfb true/false ): infix version of `|beforeOrToEnd?`."
  ahead thru |beforeOrToEnd?
] @: |beforeOrToEnd?:


[ "( Lb C -- Sfb ): same as `|beforeOrToEnd?`, but disregards
   whether the end was reached instead of Condition
   matching."
  |beforeOrToEnd? drop
] @: |beforeOrToEnd


[ "( Lb |beforeOrToEnd: C -- Sfb ): infix version of `|beforeOrToEnd`."
  ahead thru |beforeOrToEnd
] @: |beforeOrToEnd:


[ """( Lb C -- Sfb ): similar to `|afterOrDie`, but leaves the
   cursor in List block *before* the matching item.

  ```
  [ 1 2 3 4 5 6 ] $: a
  a 1 |to
  a toQuote leaves: '[ 1 | 2 3 4 5 6 ]'

  a 4 |beforeOrDie leaves: [ [ 2 3 ] ]
  a echo
  "STDOUT: [ 1 2 3 | 4 5 6 ]⏎"
  ```
  """
  over $: list

  |afterOrDie

  list empty? not => [ list 1 |- ]
] @: |beforeOrDie


[ "( Lb |beforeOrDie: C -- Sfb ): infix version of `|beforeOrDie`."
  ahead thru |beforeOrDie
] @: |beforeOrDie:


[ """( L B -- S ): opens Block with each `form count` pair,
   preceded by previous results of Block (if any), as the
   active Stack. Forms are taken from List block. Resulting
   Stack is left.

  ```
  [ 1 2 2 3 3 2 1 ] [ swap 2echo ] tally
  "STDOUT: 2⏎ 1⏎ (two ones)"
  "STDOUT: 3⏎ 2⏎ (three twos"
  "STDOUT: 2⏎ 3⏎ (two threes)"

  leaves: [ ] "all were consumed by 2echo"
  ```
  """
  over empty? => [ 2drop orphan ^ ]

  asBlock @: body

  orphan $: bag
  each: [ $: item
    bag item entry:flatFetch? br: [ 1 + ] 1
    bag item rot pushes
  ]

  bag ls ||-> [ bag over entry:fetch body ]
] @: tally


[ "( L tally: B -- ): infix version of `tally`."
  ahead thruBlock tally
] @: tally:


"TODO: implement `sortUsing!` in Novika."


[ """( B sortUsing!: Cb -- B ): infix version of `sortUsing!`.

  ```
  [ 3 1 2 4 0 -3 ] sortUsing!: - leaves: [ [ -3 0 1 2 3 4 ] ]
  ```
  """
  ahead thruBlock sortUsing!
] @: sortUsing!:


[ """( Dlb -- Dlb ): inplace sort of Decimal list block.
   Chokes on non-decimal forms.

  ```
  [ 3 1 2 4 0 -3 ] sort! leaves: [ [ -3 0 1 2 3 4 ] ]
  ```
  """
  sortUsing!: -
] @: sort!


[ """( B Mb -- B ): inplace sort for Block using the
   Mapper block, which must be able to map *all* forms
   in Block to a decimal.

  ```
  [ 'hi' 'worldish' 'hi' 'foobar' ] [ count ] sortBy! leaves: [ [ 'hi' 'hi' 'foobar' 'worldish' ] ]
  ```
  """
  @: mapper

  sortUsing!: [ bi*: mapper mapper - ]
] @: sortBy!


[ """( B sortBy!: Mb -- B ): infix version of `sortBy!`.

  ```
  [ 'hi' 'worldish' 'hi' 'foobar' ] sortBy!: count leaves: [ [ 'hi' 'hi' 'foobar' 'worldish' ] ]
  ```
  """
  ahead thruBlock sortBy!
] @: sortBy!:


[ """( L N -- Fab ): leaves a Forms around block with N/2 forms
   before the cursor, and N/2 forms after the cursor in List.

  Forms around block may consist of less than N forms, but only
  when there are less than N forms in List (in this case, Forms
  around block is essentially a shallow copy of List).

  Forms around block is an orphan with two dictionary entries:
  `start`, which stores the index of the first item in List,
  and `end`, which stores the index of the last item in List.

  Dies when N is zero or when List is empty, because in these
  cases it is impossible to find the pivot form.

  ```
  [ 1 2 3 4 ] $: block
  block 2 |to
  block echo "STDOUT: [ 1 2 | 3 4 ]⏎ "
  block 2 |around echo "STDOUT: [ 2 3 · ${start :: 1} ${end :: 3} ]⏎ "
  ```
  """

  "TODO: I'm sure this thing is super slow, look into optimizing it
   (but AFTER sort is implemented in Novika)."

  asDecimal $: amount
    asBlock $: block

  block empty? => [ '|around: cannot choose pivot when given empty list' die ]
  amount zero? => [ '|around: cannot choose pivot when amount is 0' die ]

  0 $: start
  block count $: end

  end amount <= br:
    [ block toTape ]
    [ block |at 1 - $: pivot

      "Get [ index <dist from pivot> ] for each form in the block:"
      block count collect: [ dup pivot - abs 2enclose ] $: costmap

      "Sort by cost from pivot:"
      costmap sortBy!: last

      "Get N (amount) [ index <cost from pivot> ]s:"
      dup amount |to |slice drop toOrphan

      "Sort them by index:"
      sortBy!: first

      "Get first and last item indices and save them under
       start and end."
      dup first first =: start
      dup last  first =: end

      0 $: cursorTo
      0 $: index

      "Fetch & leave only items at corresponding indices. Also
       remember where pivot is and save under cursorTo."
      ||-> [
        dup last 0 = => [ index 1 + =: cursorTo ]
        first block swap fromLeft
        index 1 + =: index
      ]

      dup cursorTo |to
    ]

  dup #start start pushes
  dup #end end pushes
] @: |around


[ """( B N -- Rb ): leaves a Ring block of N (if possible)
   forms left and right of the cursor in Block. If either
   side contains less forms than N, leaves all forms found
   in it. Puts cursor in Ring block after last form in the
   left-hand side of the ring.

  Dies if N <= 0 (there are only >zero rings). Dies if Block
  is empty (because it cannot contain >zero rings).

  Ring block also holds Block index of where the first
  form of the ring is (entry `firstAt`), and where the
  last form of the ring is (entry `lastAt`).

  Here is a diagram which may help you understand what a
  ring is:

  ```text
  ┌───────────────────────┐
  │ 3 |ring               │
  │                       │
  │   ┌───────────────┐   │
  │   │ 2 |ring       │   │
  │   │               │   │
  │   │   ┌───────┐   │   │
  │   │   │1 |ring│   │   │
  │   │   │       │   │   │
  │ 1 │ 2 │ 3 | 4 │ 5 │ 6 │
  │   │   │       │   │   │
  │   │   └───────┘   │   │
  │   │               │   │
  │   └───────────────┘   │
  │                       │
  └───────────────────────┘
  ```

  And in code:

  ```
  [ 1 2 3 "|" 4 5 6 ] dup 3 |to $: block

  block 1 |ring toQuote leaves: '[ 3 | 4 · ${firstAt :: 2} ${lastAt :: 3} ]'
  block 2 |ring toQuote leaves: '[ 2 3 | 4 5 · ${firstAt :: 1} ${lastAt :: 4} ]'
  block 3 |ring toQuote leaves: '[ 1 2 3 | 4 5 6 · ${firstAt :: 0} ${lastAt :: 5} ]'
  block 4 |ring toQuote leaves: '[ 1 2 3 | 4 5 6 · ${firstAt :: 0} ${lastAt :: 5} ]'
  block 100 |ring toQuote leaves: '[ 1 2 3 | 4 5 6 · ${firstAt :: 0} ${lastAt :: 5} ]'
  ```
  """
  asDecimal $: dist
    asBlock $: block

  dist 0 <= =>
    [ '|ring: only >= 1 rings exist' die ]

  block empty? =>
    [ '|ring: block cannot contain >= 1 rings' die ]

  0 $: firstAt

  "Cut the block at cursor"
  block |slice
    bi*:
      "For the left slice, take N items from the end (right):"
      [ dup dist fromRight* tuck bi@: count - =: firstAt ]
      "For the right slice, take N items from the start (left):"
      [ dist fromLeft* ]
    "Concat the pieces, keeping the count below:"
    bi*: [ keep: count ] concat

  "Move cursor in concatted block to the end of the
   left piece."
  tuck swap |to

  "Compute where the last item is: we know the amount of
   items in the ring, and where the ring starts. Rings
   have no holes, so we can simply do the math."
  dup count firstAt + 1 - $: lastAt

  dup #firstAt firstAt pushes
  dup #lastAt lastAt pushes
] @: |ring


[ """( B -- Rf ): leaves a Random form from the given Block.

  ```
  [ 1 2 3 4 ] sample leaves: "... a random form from the block, let's say 2"
  ```
  """
  $: block

  block (0 randTo: [ block count 1 - ]) fromLeft
] @: sample


[ """( B sample: C -- S ): samples the given Block Count times,
   and leaves the resulting block of Samples

  ```
  [ 1 2 3 4 ] sample: 2 leaves: "... [ (a random form) (a random form) ]"
  ```
  """
  $: block

  (ahead thruVal asDecimal) collect: [ block sample ]
] @: sample:


[ """( B -- Dfb ): leaves Deeply flattened block for the
   given Block.

  Self-references are ignored. **Most importantly**, deeply
  flattened block is a child of Block.

  ```
  [ ] flat leaves: [ [ ] ]
  [ 1 2 3 ] flat leaves: [ [ 1 2 3 ] ]
  [ [ 1 ] [ 2 ] [ 3 ] ] flat leaves: [ [ 1 2 3 ] ]
  "... etc."

  [ [ 100 ] $: x ] obj $: foo

  foo flat $: flattened
  flattened leaves: [ [ 100 $: x ] ]
  flattened.x leaves: 100
  "... etc."

  [ ] $: bar
  bar bar shove
  bar flat leaves: [ [ ] ]
  ```
  """
  dup child $: forms
  dup empty? => [ drop forms ^ ]

  orphan $: _seen

  [
    _seen (over address) entry:exists? => [ drop ^ ]
    _seen (over address) true pushes

    each: [
      dup block? => [ visit next ]
      forms gulp
    ]
  ] @: visit

  visit
  forms
] dup @: flat:deep
      @: flat

"TODO: flat:broad"


[ """( B P R -- ): global (of all occurences), deep (nesting
   doesn't matter) substitution of Pattern with Replacement
   in Block.

  Some important points:

  * Self-references are skipped.

  * This word goes through the whole block, no matter where the
    cursor was beforehand, sliding the latter *back to front*
    (from the end to the beginning), and afterwards restoring its
    position to that before substitution (taking growth or shrinkage
    due to substitution into account).

  * If Pattern is a block, it is opened with Block as the stack
    and cursor just after the form-to-check. This word then expects
    Pattern to leave a truthy/falsey value *for whether the visited
    form should be replaced* with Replacement.

  * The stack effect for Pattern, in case it is a block, must be
    the following: `( ... F -- ... F true/false )`, where F is the
    form to check. Otherwise, *stable behavior is yours to ensure*!

  * If Pattern is not a block, the following template block is
    used instead: `[ dup Pattern = ]`.

  * Replacement, when this word decides it's time to use it, is
    opened with Block as the stack and cursor as if it was after
    the form- to-replace, *but without the latter on the stack*.
    Insertion is expected. Therefore, the stack effect of Replacement
    is recommended to be `( -- ... )` where `...` stands for one
    or more forms. Anything is possible, though, even cursor movement.
    But in this case remember that *stable behavior is yours to ensure*.

  ```
  [ `a `b + ] $: temp

  temp #`a 100 gsub
  temp #`b 200 gsub
  temp leaves: [ [ 100 200 + ] ]
  temp open leaves: 300
  ```
  """
  @: rep $: pat

  dup empty? => [ drop ^ ]

  ahead $: caller

  pat block? not =>
    [ "Pattern is *not* a block. If it is a word, quote it;
       otherwise it would get evaluated prematurely."
      pat word? => [ pat toQuotedWord =: pat ]

      "Use the template `[ dup Pattern = ]`, a child of the
       caller block, instead of the pattern."
      caller ([ dup pat = ] here) adopt =: pat
    ]

  orphan $: seen

  [ "( F -- F/Rb' ): leaves the result of Replacement block
     if Form matches the Pattern. Otherwise, visits Form if
     it is a block."
    pat open br:
      [ drop rep ]
      [ dup block? br: visit [ ] ]
  ] $: sub

  [ $: block

    "Quit if we've already seen this block. This prevents
     us from recursing indefinitely."
    seen (block address) entry:exists? => [ block ^ ]
    seen (block address) true pushes

    block |at $: curs

    0 $: delta

    (block count) times: [ dup 1 + $: n
      (block count) over - $: fromEnd

      fromEnd curs > br:
        [ "Do not modify delta if replacement occurs after
           the recorded cursor position."
          block fromEnd |to
          block sub hydrate!
        ]
        [
          block count $: preCount
          block fromEnd |to
          block sub hydrate!
          block count $: postCount
          postCount preCount - delta + =: delta
        ]
    ]

    block (curs delta +) |to
    block
  ] @: visit

  visit drop
] @: gsub


[ """( B P gsub: R -- ): infix version of `gsub`.

  ```
  [ 100 `cmd
    200 `cmd ] $: block

  block #`cmd gsub: #echo
  block leaves: [ [ 100 echo 200 echo ] ]
  block open "STDOUT: 100⏎200⏎"
  ```
  """
  ahead thruBlock gsub
] @: gsub:


[ """( B R gsubOn: P -- ): another infix version of `gsub`.

  ```
  [ 100 `cmdA
    200 `cmdB ] $: block

  block [ 2 * #echo ] gsubOn: #`cmdA
  block [ 4 * #echo ] gsubOn: #`cmdB

  block leaves: [ [ 200 echo 800 echo ] ]
  block open "STDOUT: 200⏎800⏎"
  ```
  """
  ahead thruVal swap gsub
] @: gsubOn:
