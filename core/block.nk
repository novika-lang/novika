[ """( [ ... | F ... ]B -- F S / S ): leaves Form and/or Status
   boolean for whether Form exists.

  >>> [ 1 2 3 ] 1 |to
  === [ 1 | 2 3 ]
  >>> peek?
  === 2 true

  >>> [ 1 2 3 ]
  === [ 1 2 3 | ]
  >>> peek?
  === false
  """
  dup |at over count = => [ drop false ^ ]
  dup |at fromLeft true
] @: peek?


[ """( B N -- B ): decrements block cursor position: moves
   cursor back N times in Block.

  >>> [ 1 2 3 ]
  === [ 1 2 3 | ]
  >>> 2 |-
  === [ 1 | 2 3 ]
  """

  "Hydrating here may seem redundant at first, but remember
   cases like:

    >>> stack 1 |-

   Thanks to the custom stack created by `2enclose`, we avoid
   the problems of changing the stack at right times, since
   words `stack` and `1` affect the cursor too."

  2enclose [ over |at swap - |to ] hydrate
] @: |-


[ """( B N -- B ): increments block cursor position: moves
   cursor forward N times in Block.

  >>> [ 1 2 3 ]
  === [ 1 2 3 | ]
  >>> 2 |-
  === [ 1 | 2 3 ]
  >>> 2 |+
  === [ 1 2 3 | ]
  """
  2enclose [ over |at + |to ] hydrate
] @: |+


[ """( F [ ... | ... ]B -- [ ... F | ... ]B -- ): adds Form
   to Block, and drops both.

  >>> 3 [ 1 2 ] gulp
  === [ 1 2 3 | ]
  """
  swap shove
] @: gulp


[ """( [ ... F | ... ]B -- F [ ... | ... ]B ] ): drops Form
   from Block onto stack, before Block. Inverse of `gulp`.

  >>> [ 1 2 3 ] spit
  === 3 [ 1 2 | ]
  """
  dup cherry swap
] @: spit


[ """( [ ... | ... ]B F -- [ ... F | ... ]B ): adds Form into
    the given Block.

  >>> [ 1 2 ] 3 <<
  === [ 1 2 3 | ]
  """
  over gulp
] @: <<


[ """( [ ... F | ... ]B -- [ ... | ... ]B F ): drops Form from
   block. Inverse of `<<`.

  >>> [ 1 2 3 ] >>
  === [ 1 2 | ] 3
  """
  dup cherry
] @: >>


[ """( F -- [ F ] ): encloses Form in a block.

  >>> 'Hi!' enclose
  === [ 'Hi!' | ]
  """
  orphan swap <<
] @: enclose


[ """( F1 F2 -- [ F1 F2 ] ): encloses a pair of Forms in a block.

  >>> 'Hello' 'World' 2enclose
  === [ 'Hello' 'World' | ]
  """
  swap

  orphan swap <<
         swap <<
] @: 2enclose


[ """( B I -- F ): leaves Index-th Form from right in Block.

  >>> [ 1 2 3 ] 0 fromRight
  === 3

  >>> [ 1 2 3 ] 1 fromRight
  === 2

  >>> [ 1 2 3 ] 2 fromRight
  === 1
  """
  over count 1 - swap - fromLeft
] @: fromRight


[ """( B -- F ): leaves first Form in Block.

  >>> [ ] first
  [dies]

  >>> [ 0 ] first
  === 0

  >>> [ 1 2 3 ] first
  === 1
  """
  0 fromLeft
] @: first


[ """( B -- F ): leaves last Form in Block.

  >>> [ ] last
  [dies]

  >>> [ 0 ] last
  === 0

  >>> [ 1 2 3 ] last
  === 3
  """
  0 fromRight
] @: last


[ "( B -- Bc ): leaves an empty Block child."
  orphan swap reparent
] @: child


[ """( T -> N -- F ): infix for `entry:fetch`.

  >>> [ 200 $: x
        100 $: y
        [ x y + ] @: sum
        this
      ] open
  === [ | . x y sum ]
  >>> dup -> x
  === [ | . x y sum ] 200
  >>> over -> y
  === [ | . x y sum ] 200 100
  >>> rot -> sum
  === 200 100 [ x y + ]
  >>> open
  === 200 100 300 (note: [ x y + ] block is a closure)
  """
  ahead thru entry:fetch
] @: ->


[ "( T C N -- F ): postfix version of `.`. See `.` for usage
   examples. Caller block is assumed."
  $: name $: caller

  "( T )" dup name entry:fetch $: form

  name entry:isOpenEntry? =>
    [ caller [ #open <| ] hydrate ]

  form
] @: entry:open


[ """( T . N -- F ): same as `entry:fetch`, but adds `open`
   ahead if the entry is an open(er) entry.

  >>> [ 200 $: x
        100 $: y
        [ x y + ] @: sum
        this
      ] open
  === [ | . x y sum ]
  >>> dup . x over . y
  === [ | . x y sum ] 200 100
  >>> rot . sum
  === 200 100 300

  Preserves (carries through) `ahead`, but makes the caller
  block's instance dirty (which should not cause any trouble
  from the user's perspective).

  >>> [ $: bool

        [ ahead thru
            bool
              [ echo ]
              [ drop ]
            br
        ] @: bar:

        this
      ] @: foo
  >>> true foo
  === [ | . bar ]
  >>> . bar: 100
  STDOUT: 100
  ===
  >>> false foo
  === [ | . bar ]
  >>> . bar: 100
  ===
  """
  ahead dup thru entry:open
] @: .


[ """( T N fetch: B -- ): looks up under Name in Table block,
   and opens Block with that on ToS (on caller stack). If not
   found (or T is not block), does nothing.

  >>> 'This is not a block!' #x fetch: [ echo ]
  ===

  >>> [ 100 $: x 200 $: y this ] open
  === [ | . x y ]
  >>> dup #x fetch: [ echo ]
  STDOUT: 100
  === [ | . x y ]
  >>> dup #undefinedThing fetch: [ echo ]
  === [ | . x y ]
  """
  ahead thruBlock @: block

  [ over block? ] [ 2dup entry:exists? ] and
    [ entry:fetch block ] "Has the entry, fetch and open Block."
    [ 2drop             ] "Doesnt have, drop T N."
  br
] @: fetch:


[ """( Lb B -- Lb ): slides cursor in List block from left to right,
   in steps of one. Opens Block with List block as the stack *after*
   each step. Leaves List block. `break` and `next` are available.

  >>> [ 1 2 3 ] dup 1 |to [ + ] |slideRight

  ! Sliding step is marked with '*', block iteration postfixed
    by a '+'.

   +------+-------+-------------+
   | #    | form  |    list     |
   +======+=======+=============+
   | 0    |       | [ 1 2 3 | ] |
   | 1    | 1 |to | [ 1 | 2 3 ] |
   | *    |       | [ 1 2 | 3 ] |
   | 3+   |    +  | [ 3 | 3 ]   |
   | *    |       | [ 3 3 | ]   |
   | 5+   |    +  | [ 6 | ]     |
   +------+-------+-------------+

  === [ 6 ]
  """
  $: body $: list

  body
  [ list dup |at over count < ]
  [ list dup |at 1 + |to
    list swap hydrate ]
  createDetachedLoop open

  list
] @: |slideRight


[ "( Lb |-> B -- Lb ): infix version of `|slideRight`."
  ahead thruBlock |slideRight
] @: |->


[ "( Lb B -- Lb ): similar to `|->`, but slides the cursor
   from right to left. Consult `|slideRight`. `break` and
   `next` are available."
  $: body $: list

  body
  [ list |at 0 > ]
  [ list count $: tmp
    list swap hydrate
    list count tmp >= => [
      "If the amount of items in the list has not changed,
       or increased, slide leftwards by delta + 1, meaning
       by the amount of items added, plus once leftwards to
       maintain the movement left."
      list count tmp - 1 + $: delta
      list dup |at delta - |to
    ]
  ] createDetachedLoop open

  list
] @: |slideLeft


[ "( Lb <-| B -- Lb ): infix version of `|slideLeft`."
  ahead thruBlock |slideLeft
] @: <-|


[ """( Lb B -- ): opens Block with each item of List block on
   top of a new stack, and its index below. List block is unchanged.
   `break` and `next` are available.

  >>> [ 1 2 3 ] [ 2echo ] eachWithIndex
  STDOUT: 0 1
  STDOUT: 1 2
  STDOUT: 2 3
  """
  $: body $: list 0 $: index

  body [ index list count < ] [
    index list index fromLeft 2enclose swap hydrate
    index 1 + =: index
  ] createDetachedLoop open
] @: eachWithIndex


[ """( Lb B -- ): opens Block with each item of List block on
   top of a new stack. List block is unchanged. `break` and
   `next` are available.

  >>> [ 1 2 3 ] [ echo ] each
  STDOUT: 1
  STDOUT: 2
  STDOUT: 3
  """
  $: body $: list 0 $: index

  body [ index list count < ] [
    list index fromLeft enclose swap hydrate
    index 1 + =: index
  ] createDetachedLoop open
] @: each


[ """( Lb each: B -- ): infix version of `each`.

  >>> [ 1 2 3 ] each: [ echo ]
  STDOUT: 1
  STDOUT: 2
  STDOUT: 3
  """
  ahead thruBlock each
] @: each:


[ """( Lb eachWithIndex: B -- ): infix version of `eachWithIndex`.

  >>> [ 1 2 3 ] eachWithIndex: [ 2echo ]
  STDOUT: 0 1
  STDOUT: 1 2
  STDOUT: 2 3
  """
  ahead thruBlock eachWithIndex
] @: eachWithIndex:


[ """( Lb B -- ): opens Block with pairs of items from List block
   on top of an empty stack. `break` and `next` are available.

  >>> [ ] [ + echo ] pairs
  [Does nothing]

  >>> [ 1 ] [ + echo ] pairs
  >>> [ 1 2 3 ] [ + echo ] pairs
  [Dies: odd count]

  >>> [ 1 2 3 4 ] [ + echo ] pairs
  STDOUT: 3 (i.e., 1 + 2)
  STDOUT: 7 (i.e., 3 + 4)
  """
  $: block

  dup empty? => [ drop ^ ]
  dup count odd? => [ 'for pairs to work, there should be an even count of items in block' die ]

  $: list 0 $: index

  block [ index list count < ]
  [
    list index     fromLeft
    list index 1 + fromLeft
    2enclose swap hydrate
    index 2 + =: index
  ] createDetachedLoop open
] @: pairs


[ """( Lb pairs: B -- ): infix version of `pairs`.

  >>> [ 1 2 3 4 ] pairs: [ + echo ]
  STDOUT: 3
  STDOUT: 7
  """
  ahead thruBlock pairs
] @: pairs:


[ """( Lb B -- ): opens Block with consequtive pairs of items
   from List block on top of an empty stack. `break` and `next`
   are available.

  >>> [ ] [ + echo ] consPairs
  >>> [ 1 ] [ + echo ] consPairs
  [Does nothing]

  >>> [ 1 2 ] [ + echo ] consPairs
  STDOUT: 3 (i.e, 1 + 2)

  >>> [ 1 2 3 ] [ + echo ] consPairs
  STDOUT: 3 (i.e., 1 + 2)
  STDOUT: 5 (i.e., 2 + 3)
  """
  $: block

  dup empty? => [ drop ^ ]

  $: list 0 $: index

  block [ index list count 1 - < ]
  [
    list index     fromLeft
    list index 1 + fromLeft
    2enclose swap hydrate
    index 1 + =: index
  ] createDetachedLoop open
] @: consPairs


[ """( Lb B -- ): infix version of `consPairs`.

  >>> [ 1 2 3 ] consPairs: [ + echo ]
  STDOUT: 3
  STDOUT: 5
  """
  ahead thruBlock consPairs
] @: consPairs:


[ """( Lb B -- Mlb ): opens Block with each item of List block
   on top of an empty stack. Replaces item in List block with
   Block's stack top after opening it. Leaves the resulting
   Modified version of List block. `break` and `next` are available.

  >>> [ 1 2 3 ] [ 1 + ] map
  === [ 2 3 4 | ] (a different block!)

  >>> [ 1 2 3 ] $: a
  >>> a [ 1 + ] map
  === [ 2 3 4 | ] (a different block!)

  >>> a
  === [ 1 2 3 | ]
  """
  $: block $: list [ ] $: result

  list empty? => [ result ^ ]

  0 $: index

  block [ index list count < ]
  [
    list index fromLeft enclose swap there dup empty?
      [ "No result: probably the user wants it out." drop ]
      [ cherry result gulp ]
    br
    index 1 + =: index
  ] createDetachedLoop open

  result
] @: map


[ """( Lb B -- MLb ): infix version of `map`.

  >>> [ 1 2 3 ] map: [ 1 + ]
  """
  ahead thruBlock map
] @: map:


[ """( Lb B -- MLb ): opens Block with each item of List block
   on top of an empty stack. Removes that item in Modified List
   block if Block's stack top is false after it was opened.
   `break` and `next` are available.

  >>> [ ] [ 100 > ] only
  === [ | ] (a different block!)

  >>> [ 1 2 3 ] [ ] only
  === [ 1 2 3 | ] (a different block!)

  >>> [ 1 100 2 300 4 600 10 ] [ 100 > ] only
  === [ 300 600 | ]
  """
  $: block $: list [ ] $: result

  list empty? => [ result ^ ]

  0 $: index

  block [ index list count < ]
  [
    list index fromLeft dup enclose rot there dup empty?
      [ "No result: probably the user wants it out." drop ]
      [ cherry => [ result gulp ] ]
    br
    index 1 + =: index
  ] createDetachedLoop open

  result
] @: only


[ """( Lb B -- MLb ): infix version of `only`.

  >>> [ 1 100 2 300 4 600 10 ] only: [ 100 > ]
  === [ 300 600 | ]
  """
  ahead thruBlock only
] @: only:


[ """( Lb B M -- M ): reduces List block using Block. Block
   is opened with Memo, current item on top of an empty stack.
   Memo is updated to Block's value after Block is opened.
   `break` and `next` are available.

  >>> [ ] [ + ] 0 reduce
  === 0

  >>> [ 1 ] [ + ] 0 reduce
  === 1 (i.e., 0 + 1)

  >>> [ 1 2 3 ] [ + ] 0 reduce
  === 6

  >>> [ 'Hellope, ' 'Europe!' ' ' 'Huh?' ] [ stitch ] '' reduce
  === 'Hellope, Europe! Huh?'

  Supports stack reduction:

  >>> '1' '2' '3'
  === '1' '2' '3'
  >>> stack [ stitch ] '' reduce
  === '123'
  """
  $: memo $: block $: list

  "List is empty: just leave the memo."
  list empty?    => [ memo ^ ]

  "List is the stack. This is a special-case, for we must drop
   instead of peeking."
  list stack same? =>
    [
      [ "For extra safety, we're running under 'do', which will
          protect us from modifying our own stack (which `stack`
          is) and causing all sorts of weirdness."
        list |slice
          $: afterCursor
          $: beforeCursor

        beforeCursor block memo reduce enclose afterCursor concat!
          $: result

        result list resub list 1 |to
     ] do
     ^
    ]

  0 $: index

  block [ index list count < ]
  [
    memo list index fromLeft 2enclose swap there cherry =: memo
    index 1 + =: index
  ] createDetachedLoop open

  memo
] @: reduce


[ """( Lb B -- A ): leaves the Amount of items for which Block,
   when opened with an item on top of an empty stack, leaves
   a truthy form. `break` and `next` are available.

  >>> [ 1 2 3 ] [ 2 > ] amount
  === 1 (i.e., 3)

  >>> [ 1 2 3 ] [ 100 > ] amount
  === 0

  >>> [ 1 5000 2 4400 1 100 102 ] [ 100 <= ] amount
  === 4 (i.e., 1, 2, 1, 100)
  """
  $: block $: list

  list empty? => [ 0 ^ ]

  0 $: amt
  0 $: index

  "Go thru each item and check if block opens to true there,
   if it does, increment the count."
  block [ index list count < ]
  [
    list index fromLeft enclose swap there cherry => [ amt 1 + =: amt ]
    index 1 + =: index
  ] createDetachedLoop open

  amt
] @: amount


[ """( Lb B -- A ): infix version of `amount`.

  >>> [ 1 2 3 ] # [ 2 > ]
  === 1
  """
  ahead thruBlock amount
] @: #


[ """( Lb B -- true/false ): whether Block leaves true for all
   items in List block, when opened with each item on top of
   an empty stack.

  >>> [ ] [ 100 < ] all?
  === true (BEWARE)

  >>> [ 1 2 3 ] [ 100 < ] all?
  === true

  >>> [ 101 2 3 4 ] [ 100 < ] all?
  === false (i.e., because of 101)
  """
  @: block true $: status

  "Go thru each item and check if block opens to true there;
   if it doesn't, quit the loop with status = false."
  each: [ block not => [ false =: status break ] ]

  status
] @: all?


[ """( Lb B -- true/false ): whether Block leaves true for any
   item in List block, when opened with each item on top of an
   empty stack.

  >>> [ ] [ 100 < ] any?
  === false (BEWARE)

  >>> [ 1 2 3 ] [ 3 = ] any?
  === true

  === [ 101 3 2000 ] [ 100 < ] any?
  === true (i.e., because of 3)

  >>> [ 1002 350 2000 ] [ 100 < ] any?
  === false
  """
  @: block false $: status

  "Go thru each item and check if block opens to true there;
   if it does, quit the loop with status = true."
  each: [ block => [ true =: status break ] ]

  status
] @: any?


[ """( A B -- Z ): leaves Zipped A, B.

  >>> [ ] [ ] zip
  === [ | ]

  >>> [ 1 2 ] [ 3 4 ] zip
  === [ [ 1 3 | ] [ 2 4 | ] | ]

  >>> [ 1 2 ] [ 3 ] zip
  [dies]
  """
  $: b $: a a count $: aCount

  aCount b count = not => [ 'counts must be equal with zip, otherwise use zipWithDefault' die ]

  [ ] $: result

  aCount times: [ dup
    a swap fromLeft swap
    b swap fromLeft 2enclose
    result gulp
  ]

  result
] @: zip


[ """( A B D -- Z ): leaves Zipped A, B with holes filled by
   the given Default form.

  >>> [ ] [ ] #hole zipWithDefault
  === [ | ]

  >>> [ 1 2 ] [ 3 4 ] #hole zipWithDefault
  === [ [ 1 3 | ] [ 2 4 | ] | ]

  >>> [ 1 2 ] [ 3 ] #hole zipWithDefault
  === [ [ 1 3 | ] [ 2 hole | ] | ]

  >>> [ 1 ] [ 3 4 ] #hole zipWithDefault
  === [ [ 1 3 | ] [ hole 4 | ] | ]
  """
  $: default

  #_    $: longer
  #_    $: smaller
  0     $: missing
  false $: swapped

  over count "A count"
  over count "B count"
  2dup < "A < B"
    [ swap -  =: missing
      true    =: swapped
      "B"     =: longer
      "A" shallowCopy =: smaller ]
    [ -       =: missing
      "B" shallowCopy =: smaller
      "A"     =: longer ]
  br

  missing times: [ smaller default shove ]

  longer smaller swapped => [ swap ] zip
] @: zipWithDefault


[ """( S D -- Di ): given a Source block and a Destination
   block, leaves an instance of Destination block with all
   words (see `word?`) replaced with entry values from table
   Source (they are **not** opened), and all quoted words
   unquoted (see `quotedWord?`). Recurses on sub-blocks.

  >>> 1 $: x  2 $: y  #+ $: plus
  >>> this [ x y plus #dup plus [ ##foo #echo ] #open ] conjure
  === [ 1 2 + dup + [ #foo echo | ] #open | ]
  >>> open
  STDOUT: foo
  === 6
  """
  swap $: source

  "If it's a word, replace it with word's value in source, if
   it's a quoted word, unquote it, if it's a block, then recurse
   on its elements, else, leave it."
  dup word?       => [ source swap entry:fetch      ^ ]
  dup block?      => [ map: [ source swap conjure ] ^ ]
  dup quotedWord? => [ open ^ ]
] @: conjure


[ """( B -- Bi ): `conjure` with Source block set to caller.

  >>> 1 $: x  2 $: y  #+ $: plus
  >>> [ x y plus #dup plus [ ##foo #echo ] #open ] here
  === [ 1 2 + dup + [ #foo echo | ] #open | ]
  >>> open
  STDOUT: foo
  === 6
  """
  ahead swap conjure
] @: here


[ """( Lb -- Min Max ): leaves decimal minimum, maximum in
   List block. Use `minmaxBy` if List block doesn't (or doesn't
   always) contain solely decimals. If an empty block is given,
   dies, so make sure to handle that yourself.

  >>> [ 1 2 3 ] minmax
  === 1 3
  """

  "NOTE: this is separate from minmaxBy for performance reasons only;
   otherwise, having `[ ] minmaxBy` would be sufficient here."

  dup empty? => [ 'Cannot minmax an empty block' die ]

  dup first
    dup $: min
        $: max

  each: [
    dup min < => [ =: min ^ ]
    dup max > => [ =: max ^  ]
  ]

  min max
] @: minmax


[ """( Lb -- Min ): leaves decimal minimum. See `minmax`.

  >>> [ 1 2 3 ] min
  === 1
  """
  minmax drop
] @: min


[ """( Lb -- Max ): leaves decimal maximum. See `minmax`.

  >>> [ 1 2 3 ] max
  === 3
  """
  minmax nip
] @: max


[ """( Lb -- Sum ): leaves decimal sum of List block elements.
   For more control (or if not always decimal), use sumBy.

  >>> [ ] sum
  === 0

  >>> [ 1 ] sum
  === 1

  >>> [ 1 2 3 ] sum
  === 6
  """
  [ + ] 0 reduce
] @: sum


[ """( Lb T -- Min Max ): leaves the minimum and maximum values
   in List block. Decimal values are obtained via the Transformation
   block, which is opened with each element of List block on top
   of an empty stack. If List block is empty, dies, so make sure
   to handle that yourself.

  >>> [ ] [ ] minmaxBy
  === [dies]

  >>> [ 1 2 3 ] [ ] minmaxBy
  === 1 3

  >>> [ 'A short quote' 'A loooonger quote' 'Veeeeeeeeeeery long quote' ] [ count ] minmax
  === 'A short string' 'Veeeeeeeeeeery long string'
  """
  dup empty? => [ drop minmax ^ ] $: transformer
  dup empty? => [ 'Cannot minmax an empty block' die ]

  dup first "Get the first item in the List block."
    dup $: min "Original minimum."
    dup $: max "Original maximum."
    enclose transformer there cherry
      dup $: dMin "Transformed minimum."
          $: dMax "Transformed maximum."

  each: [
    dup enclose transformer there cherry
    dup dMin < => [ =: dMin =: min ^ ]
    dup dMax > => [ =: dMax =: max ^ ]
  ]

  min max
] @: minmaxBy


[ """( Lb T -- Min ): leaves the minimum value in List block. Each
   element of List block is transformed using Transformation
   block. See `minmaxBy`.

  >>> [ 1 2 3 ] [ ] minBy
  === 1
  """
  minmaxBy drop
] @: minBy


[ """( Lb T -- Max ): leaves the maximum value in List block. Each
   element of List block is transformed using Transformation
   block. See `minmaxBy`.

  >>> [ 1 2 3 ] [ ] maxBy
  === 3
  """
  minmaxBy nip
] @: maxBy


[ """( Lb T -- Sum ): leaves Sum of List block elements transformed
   into decimals by Transformation block. Similar to `minmaxBy`.

  >>> [ 'a' 'aaa' 'aa' ] [ count ] sumBy
  === 6
  """
  $: transformer

  [ enclose transformer there cherry + ] 0 reduce
] @: sumBy


[ """( N B -- Lb ): leaves a List block with N results of opening
   Block with the current N. Basically a combo of `times` and `map`.
   `break` and `next` are available. The current result is skipped
   if stack is empty after opening Block.

  >>> 3 [ readLine [ stack swap slurp ] [ drop 0 ] br ] collect
  INPUT: 0 3
  INPUT: 1 5
  INPUT: 2 12
  === [ 3 5 12 ]
  """
  $: block $: max [ ] $: result

  max negative? => [ 'collect: cannot have negative amount' die ]

  0 $: current

  block [ current max < ]
  [
    current enclose swap there dup empty? not =>
      [ cherry result gulp ]
    current 1 + =: current
  ] createDetachedLoop open

  result
] @: collect


[ "( N collect: B -- Lb ): infix version of `collect`."
  ahead thruBlock collect
] @: collect:


[ """( B G -- Lg ): groups forms in Block according to Grouper
   block. Leaves a List of groups. Grouper block is opened
   with consequent items on top of an empty stack. Grouper
   block can leave any form except block. Order of groups
   in List of groups is the same as in Block, i.e., if the
   first item in Block is is in group G1, then the first group
   in List of groups will be G1.

  If necessary, the form Group left for a particular group
  can be accessed with `.id`. Group members do not have access
  to their group block's `id`.

  >>> [ 1 2 3 ] [ 1 > ] groupBy
  === [ [ 1 ] [ 2 3 ] ]

  >>> [ 1 2 3 ] [ 1 <= ] groupBy
  === [ [ 1 ] [ 2 3 ] ]

  >>> [ 1 2 3 ] [ 1 <= ] groupBy [ .id ] map
  === [ true false ]

  >>> [ 1 2 3 ] [ 1 <= 'foo' 'bar' sel ] groupBy [ dup .id 2enclose ] map
  === [ [ [ 1 ] 'foo' ] [ [ 2 3 ] 'bar' ] ]
  """
  asBlock $: grouper asBlock $: block

  block empty? => [ [ ] ^ ]

  orphan $: groupMap

  block each: [ $: element
    element enclose grouper there cherry $: group
    groupMap group entry:exists? br:
      [ groupMap group entry:fetch ]
      [ "Create an orphan for ID, and another orhpan child for
         group elements. This lets the user '=' but still have
         'id' without additional trickery."
        orphan orphan dup #id group pushes reparent dup
        <| groupMap group |> pushes ]
    element shove
  ]

  groupMap ls map: [ groupMap swap entry:fetch ]
] @: groupBy


[ """( B G -- Lg ): infix version of `groupBy`. See `groupBy`
   for information on what this word does.

  >>> [ 1 2 3 ] groupBy: [ 1 > ]
  === [ [ 1 ] [ 2 3 ] ]

  >>> [ 1 2 3 ] groupBy: [ 1 <= ]
  === [ [ 1 ] [ 2 3 ] ]

  >>> [ 1 2 3 ] groupBy: [ 1 <= ] map: [ .id ]
  === [ true false ]

  >>> [ 1 2 3 ] groupBy: [ 1 <= 'foo' 'bar' sel ] map: [ dup .id 2enclose ]
  === [ [ [ 1 ] 'foo' ] [ [ 2 3 ] 'bar' ] ]
  """
  ahead thruBlock groupBy
] @: groupBy:


[ """( B E -- Rb ): leaves Range block containing decimals
   between the given Begin, End decimal boundaries: [B; E],
   [E; B] if  E < B.

  >>> 1 100 range
  === [ 1 2 3 ... 98 99 100 | ]

  >>> -10 10 range
  === [ -10 -9 -8 ... 8 9 10 | ]

  >>> 10 0 range
  === [ 10 9 8 ... 0 | ]
  """
  $: e $: b

  e b <
    [ b e - 1 + collect: [ b swap - ] ]
    [ e b - 1 + collect: [ b + ] ]
  br
] @: range


[ """( B to: E -- Rb ): infix version of `range`.

  >>> 1 to: 100
  === [ 1 2 3 ... 98 99 100 | ]

  >>> 10 to: 0
  === [ 10 9 8 ... 0 | ]
  """
  ahead thru range
] @: to:


[ """( Fl -- Q ): stitches enquoted forms from Form list
   into Quote.

  >>> [ 'A' 'B' 'C' ] join
  === 'ABC'

  >>> 1 $: x
  >>> 2 $: y
  >>> [ x '; ' y ] here join
  === '1; 2'
  """
  [ toQuote stitch ] '' reduce
] @: join


[ """( Fl S -- Q ): stitches enquoted forms from Form list
   into Quote, inserting enquoted Separator in the middle
   of pairs.

  >>> [ 'a' 'b' '=' 1 ] ' ' sepBy
  === 'a b = 1'
  """
  toQuote $: sep
  asBlock $: formList

  '' $: result

  formList eachWithIndex: [ $: form $: index
    result form toQuote stitch
    index formList count 1 - = not =>
      [ sep stitch ]
    =: result
  ]

  result
] @: sepBy


[ "( Fl sepBy:/join: S -- Q ): infix version of `sepBy`."
  ahead thruBlock sepBy
] dup @: sepBy:
      @: join:


[ """( B1 B2 -- B1 ): adds elements from B2 into B1.

  >>> [ 1 2 3 ] [ 4 5 6 ] concat!
  === [ 1 2 3 4 5 6 ]
  """
  [ << ] rot reduce
] @: concat!


[ """( B1 B2 -- Br ): concatenates two Blocks.

  >>> [ 1 2 3 ] [ 4 5 6 ]
  === [ 1 2 3 4 5 6 ] (a new block!)
  """
  <| shallowCopy |> concat!
] @: concat


[ """( -- Lw ): leaves a List of words which are defined in
   caller. Recurses to caller's parents while there are any.

  >>> 0 $: y [ 1 $: x ls* ] open
  === [ ... y x ]

  As opposed to `ls`, which leaves only block's own words:

  >>> 0 $: y [ 1 $: x this ls ] open
  === [ x ]
  """
  [ ] $: result
  [
    result over ls concat! drop
    dup orphan?
      [ drop ]
      [ parent rec ]
    br
  ] @: rec

  ahead rec result
] @: ls*


[ """( B -- Tb ): leaves Tape block for Block. Useful for e.g.
   comparing two blocks only for tape contents, when Block may
   have table entries.

  Lookup hierarchy is destroyed: Tape block is an orphan.

  >>> [ 1 2 3 ] $: a
  >>> a #x 0 pushes
  >>> a a toTape 2echo
  [ 1 2 3 | . x ]
  [ 1 2 3 | ]
  """
  new toOrphan
] @: toTape
