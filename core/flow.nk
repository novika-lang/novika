[ "( B -- B' ): opens Block in the active stack."
  stack swap ahead #hydrate inject
] @: open


[ "( S B -- ): hydrates Block with Stack, but does not create
   an instance of Block like the regular hydrate does. Essentially
   an inplace hydrate, hence the bang."
  dup 0 |to newContinuation conts gulp
] @: hydrate!


[ "( B -- T ): activates an empty stack for the duration of Block,
   and leaves Top form in the stack. Dies if none."
  [ ] swap there cherry
] @: val


[ "( B -- ): activates an empty stack for the duration of Block."
  [ ] swap hydrate
] @: do


[ "( D T F -- ? ): opens True/False forms depending on Determiner
   being true/false."
  sel open
] @: br


[ "( D br: T F -- ? ): infix version of `br`."
  ahead eject "T"
  ahead eject "F"
  br
] @: br:


[ "( D => T -- ? ): opens True form if Determiner is truthy."
  ahead eject [ ] br
] @: =>


[ "( A B -- A/false ): leaves whether both A and B are truthy."
  $: b @: a

  a b false br
] @: and


[ "( A B -- true/A ): leaves whether A or B or both are truthy."
  $: b @: a

  a true b br
] @: or


[ "( B -- ): makes shallow copy of continuations stack the
   stack for the duration of Block. Attaches after Block."
  conts shallowCopy
    "Don't forget to drop the call to continues (as it will
     obscure what the caller expects continuations block to be)"
    [ drop ] there swap there
  conts attach
] @: continues


[ "( -- ): executes caller again. Looping primitive. Too low-
   level for users, prefer not to use (use `loop` instead).
   Beware that it does not re-instantiate the block."
  ahead 0 |to
] @: repeat


[ "( B -- ): drops all continuations before (and including)
   those for which Block leaves truthy value when opened with
   the continuation on top of an empty stack, coming from the
   right-hand side."
  $: needle?

  [
    enclose needle? there cherry
      [ ]  "Hit the needle! Don't recurse."
      rec  "Not the needle. Recurse."
    br
  ] dup $: rec continues
] @: dropContinuationsUntil


[ "( B -- ): closes blocks all the way up to, but not
   including, Block."
  $: block

  [
    dup continuationBlock block same?
      [ ]
      [ drop rec ]
    br
  ] dup @: rec continues
] @: resume


[ "( -- ): closes blocks all the way up to, and including,
   its *opener's parent*."
  ahead prototype parent $: above

  [ continuationBlock prototype above same? ] dropContinuationsUntil
] @: ^


[ "( Ib -- Sh Bh Ch ): takes an Iteration body block and leaves
    three handles: one to Start the loop, one to Break the loop,
    and one to next the loop."
  $: iterBody

  #nil $: breakTo

  [ orphan iterBody hydrate repeat ] $: loopBody

  [ this =: breakTo orphan loopBody hydrate! ]
  [  breakTo resume ]
  [ loopBody resume ]
] @: createLoop


[ "( Bb Ctb Cdb -- Sh ): defines `break` and `next` for a Body
   block that is being evaluated indirectly by a Control block,
   and only if the Condition block leaves a truthy value on top
   of the stack it hydrated. `next` resumes the Control block."
 $: ctrl $: cond new $: bodyInstance

  #nil $: ctrlNow

  [ cond val
      [ ctrl new =: ctrlNow bodyInstance enclose ctrlNow hydrate! ]
      breakLoop
    br
  ] createLoop drop $: breakLoop @: startLoop

  [ bodyInstance #break breakLoop opens
    bodyInstance #next [ ctrlNow resume ] opens
    startLoop ]
] @: createDetachedLoop


[ "( Ib -- ): basic infinite loop over an Iteration body block.
   `break` and `next` are available in the block. A new
   stack created for each iteration."
  new $: iterBody

  iterBody createLoop
    $: nextLoop
    $: breakLoop
    @: startLoop

  iterBody #break breakLoop opens
  iterBody #next nextLoop opens

  startLoop
] @: loop


[ "( loop: Ib -- ): prefix version of `loop`."
  ahead eject loop
] @: loop:


[ "( C B -- ): hydrates an empty stack with Condition; if ToS
   is truthy afterwards, Block is opened over an empty stack.
   Repeats until ToS is false. Similar to `loop`, words `break`
   and `next` are available in Block."
  swap [ open ] createDetachedLoop open
] @: while


[ "( while: C B -- ): prefix version of `while`."
  ahead eject
  ahead eject
  while
] @: while:


[ "( C B -- ): inverse of `while` (opens Block while Condition
   is **false**), for more info see `while`."
  <| shallowCopy #not << |> while
] @: until


[ "( until: C B -- ): prefix version of `until`."
  ahead eject
  ahead eject
  until
] @: until:


[ "( N B -- ): opens Block N times. Block is opened in a new
   stack with current N. `break` and `next` available."
  $: block $: max

  max negative? => [ 'times: cannot have negative bound' die ]

  0 $: current

  block
  [ current max < ]
  [ current swap open current 1 + =: current ]
  createDetachedLoop open
] @: times


[ "( N times: B -- ): infix version of `times`."
  ahead eject times
] @: times:
